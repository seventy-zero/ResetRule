<!DOCTYPE html>
<html lang="en">
<head>
    <title>ResetRule</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/virtual-joystick/1.10.0/virtual-joystick.min.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #000000;
            overflow: hidden; /* Prevent scrollbars */
        }
        canvas {
            display: block;
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            z-index: 1000;
        }
        #instructions.hidden {
            display: none;
        }
        #username {
            margin: 10px 0;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-size: 16px;
            width: 200px;
            text-align: center;
        }
        #startButton {
            margin-top: 15px;
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #45a049;
        }
        #startButton:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            height: 120px;
            width: 120px;
            pointer-events: auto;
            z-index: 1000;
        }
        .joystick-zone {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 60px;
            pointer-events: auto;
            z-index: 1000;
            touch-action: none;
        }
        .joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        #flingButton {
            display: none;
            position: fixed;
            bottom: 160px;
            left: 40px;
            width: 60px;
            height: 60px;
            background: rgba(76, 175, 80, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            line-height: 60px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            z-index: 1000;
            touch-action: none;
        }
        #flingButton.active {
            background: rgba(76, 175, 80, 0.9);
        }
        /* Show mobile controls on touch devices */
        @media (pointer: coarse) {
            .mobile-controls {
                display: block !important;
            }
            #flingButton {
                display: block !important;
            }
        }
        #roomInfo {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        #playerList {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            display: none;
            min-width: 150px;
        }

        #playerList.visible {
            display: block;
        }

        .playerListItem {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .playerListItem:hover {
            background-color: rgba(76, 175, 80, 0.2);
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>Welcome to ResetRule</h2>
        <input type="text" id="username" placeholder="Enter your username" maxlength="15">
        <button id="startButton" disabled>Start Game</button>
        <p style="margin-top: 20px;">
            Desktop Controls:<br>
            WASD = Move<br>
            Mouse = Look around<br>
            ESC = Exit<br>
            Left Click / E = Aim & Release to Fling<br>
            F = Fire Shotgun
        </p>
        <p id="mobileInstructions" style="display: none; margin-top: 20px;">
            Mobile Controls:<br>
            Right Stick = Look around<br>
            Fling Button = Aim & Release to Fling<br>
            (Shotgun fire not implemented for mobile yet)
        </p>
    </div>

    <div id="playerList"></div>
    <div id="roomInfo"></div>

    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div id="rightJoystick" class="joystick-zone"></div>
    </div>
    <div id="flingButton">âš¡</div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- Consolidated Constants ---
        const playerHeight = 10;
        const playerRadius = 2;
        const moveSpeed = 0.05; // Base speed impulse factor
        const gravity = 0.044; // Acceleration per frame^2 (scaled by delta*60 later)
        const flingStrength = 2.5; // Base fling impulse strength
        const flingDamping = 0.985; // Multiplier per frame (scaled by delta*60 later)
        const clock = new THREE.Clock();

        // Shotgun Constants (Consolidated)
        const SHOTGUN_PELLET_COUNT = 8;
        const SHOTGUN_SPREAD_ANGLE = 0.2; // Radians for spread cone (increased)
        const SHOTGUN_PELLET_SPEED = 50; // Units per second (increased)
        const SHOTGUN_DAMAGE_PER_PELLET = 20;
        const SHOTGUN_RANGE = 2000; // Maximum distance pellets travel (increased)
        const SHOTGUN_FIRE_RATE = 1000; // Milliseconds between shots (cooldown)
        let lastShotTime = 0; // Timestamp of the last shot

        // Game state variables
        let gameStarted = false;
        let playerUsername = '';
        let isGrounded = true;
        let isFlinging = false;
        let showLine = false;
        let lineCollisionPoint = null;
        let verticalVelocity = 0; // Current vertical speed
        let ws = null;

        // Projectile Management
        const projectiles = [];
        const projectileGeometry = new THREE.SphereGeometry(0.3, 4, 4); // Small sphere for pellets
        const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 }); // Orange pellets

        // Movement state variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        // Scene-related variables
        let scene, camera, renderer, controls;

        // Collections
        const towers = []; // Stores { mesh: collisionMesh, boundingBox: Box3, visualGroup: Group }
        const nebulas = [];
        const playerStates = new Map(); // Stores PlayerState instances (username -> PlayerState)
        const collectibles = new Map(); // Stores { mesh: Mesh, position: Vector3, color: hex, userData: {...} }
        const playerItems = new Map(); // Stores items collected by each player (username -> Set<itemId>)

        // Vectors and other THREE.js objects (reusable)
        const velocity = new THREE.Vector3(); // Stores current horizontal movement velocity
        const flingVelocity = new THREE.Vector3(); // Stores current horizontal fling velocity impulse
        const direction = new THREE.Vector3(); // Temp vector for movement direction calculation
        const playerCollider = new THREE.Sphere(new THREE.Vector3(), playerRadius); // Player collision sphere
        const raycaster = new THREE.Raycaster(); // Reusable raycaster

        // Collectible item properties
        const ITEM_COUNT = 20; // Target number of items to spawn
        const ITEM_RADIUS = 3;
        const ITEM_HEIGHT = 2; // Not directly used?
        const MIN_DISTANCE_BETWEEN_ITEMS = 100;
        const ITEM_COLORS = [
            0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff,
            0x00ffff, 0xff8800, 0x8800ff, 0x00ff88, 0xff0088,
            0x88ff00, 0x0088ff, 0xff8800, 0x8800ff, 0x00ff88,
            0xff0088, 0x88ff00, 0x0088ff, 0xff8800, 0x8800ff
        ];

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Interpolation settings for remote players
        const INTERPOLATION_SPEED = 0.15; // Base interpolation lerp factor

        // Culling settings
        const RENDER_DISTANCE = 2000; // Max distance check (not actively used for culling currently)
        const CULL_DISTANCE = 1500;   // Distance at which to hide objects

        // Function to check if an object is within render distance (not currently used)
        // function isWithinRenderDistance(position) {
        //     return camera.position.distanceTo(position) <= RENDER_DISTANCE;
        // }

        // Store player states for interpolation and health
        class PlayerState {
            constructor(username, mesh) {
                this.username = username;
                this.mesh = mesh; // Reference to the player's visual THREE.Mesh
                this.targetPosition = new THREE.Vector3(); // Position goal from server
                this.targetRotation = new THREE.Euler(); // Rotation goal from server (use Euler)
                this.currentPosition = new THREE.Vector3(); // Interpolated position
                this.currentRotation = new THREE.Euler(); // Interpolated rotation (use Euler)
                this.lastUpdateTime = Date.now();
                this.interpolationSpeed = INTERPOLATION_SPEED; // Base interpolation speed
                this.positionThreshold = 10; // Distance threshold for position snapping
                this.health = 100; // Player health
            }

            update(deltaTime) {
                if (!this.mesh) return;

                const timeSinceUpdate = (Date.now() - this.lastUpdateTime) / 1000; // Seconds since last server update

                // Adjust interpolation speed based on update frequency and distance (optional)
                const distanceToTarget = this.currentPosition.distanceTo(this.targetPosition);
                let currentSpeed = this.interpolationSpeed; // Use base speed for now

                // Snap to position if too far away or haven't received updates in a while
                if (distanceToTarget > this.positionThreshold || timeSinceUpdate > 1.0) { // 1 second threshold
                    this.currentPosition.copy(this.targetPosition);
                    this.currentRotation.copy(this.targetRotation);
                } else {
                    // Smoothly interpolate position and rotation
                    const lerpFactor = 1.0 - Math.exp(-currentSpeed * deltaTime * 10); // Smoother lerp
                    this.currentPosition.lerp(this.targetPosition, lerpFactor);
                    // Lerp Euler rotations (handle wrapping carefully if needed, simple lerp often okay)
                    this.currentRotation.x = THREE.MathUtils.lerp(this.currentRotation.x, this.targetRotation.x, lerpFactor);
                    this.currentRotation.y = THREE.MathUtils.lerp(this.currentRotation.y, this.targetRotation.y, lerpFactor);
                    this.currentRotation.z = THREE.MathUtils.lerp(this.currentRotation.z, this.targetRotation.z, lerpFactor);
                }

                // Update mesh position and rotation
                this.mesh.position.copy(this.currentPosition);
                this.mesh.rotation.copy(this.currentRotation);
            }

             // Method to apply damage
             takeDamage(amount) {
                this.health = Math.max(0, this.health - amount);
                console.log(`${this.username} took ${amount} damage, health remaining: ${this.health}`);
                // TODO: Update visual representation of health (e.g., player mesh color flash, health bar UI)
                if (this.health <= 0) {
                    console.log(`${this.username} has been eliminated.`);
                    // TODO: Handle player elimination (e.g., respawn logic, disable input, show message)
                     if(this.mesh) this.mesh.visible = false; // Hide model on death
                }
                 // Ensure health update reflects in UI
                 updatePlayerList();
            }
        }

        // Function to create player model
        function createPlayerModel(username) {
            console.log('Creating player model for:', username);

            // Check if player model already exists
            if (playerStates.has(username)) {
                console.log('Player model already exists for:', username);
                return playerStates.get(username).mesh; // Return existing mesh
            }

            const geometry = new THREE.CapsuleGeometry(playerRadius, 6, 4, 8); // Use playerRadius
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff00, // Default color
                wireframe: true
            });
            const playerMesh = new THREE.Mesh(geometry, material);
            playerMesh.position.set(0, -1000, 0); // Start hidden below floor initially

            // Add username label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            context.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent background
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.font = '32px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(username, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, transparent: true }); // Ensure visibility
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(15, 3.75, 1); // Adjust scale as needed
            sprite.position.y = playerHeight / 2 + 4; // Position above the capsule top
            playerMesh.add(sprite); // Add sprite label to the player mesh

            scene.add(playerMesh); // Add mesh to scene

            // Create and store player state
            const playerState = new PlayerState(username, playerMesh);
            playerState.currentPosition.copy(playerMesh.position); // Initialize current pos
            playerState.targetPosition.copy(playerMesh.position); // Initialize target pos
            playerStates.set(username, playerState);

            // Hide own player model
            if (username === playerUsername) {
                playerMesh.visible = false;
            }

            console.log('Player model created successfully for:', username);
            return playerMesh;
        }

        // Function to update player position based on server data
        function updatePlayerPosition(username, positionArray, rotationArray) {
            const playerState = playerStates.get(username);
            if (playerState) {
                // Ensure player model exists
                if (!playerState.mesh) {
                     console.warn(`Mesh not found for player ${username} during position update.`);
                     createPlayerModel(username); // Attempt to recreate if missing
                     if(!playerStates.get(username).mesh) return; // Exit if still no mesh
                }

                // Update target position
                if (positionArray && Array.isArray(positionArray)) {
                     playerState.targetPosition.fromArray(positionArray);
                }

                // Update target rotation (receive Euler array [x, y, z])
                if (rotationArray && Array.isArray(rotationArray)) {
                     playerState.targetRotation.fromArray(rotationArray);
                }

                playerState.lastUpdateTime = Date.now();

                // Snap current position if it's the very first update
                if (playerState.currentPosition.y === -1000) { // Check initial hidden position
                    playerState.currentPosition.copy(playerState.targetPosition);
                    playerState.currentRotation.copy(playerState.targetRotation);
                    playerState.mesh.position.copy(playerState.targetPosition);
                    playerState.mesh.rotation.copy(playerState.targetRotation);
                }
            } else if (username !== playerUsername) { // Don't warn for self before joining
                console.warn('No player state found for username:', username);
                 // Optionally create player model here if missing (e.g., joined before client loaded)
                 handlePlayerJoined(username, positionArray, rotationArray);
            }
        }

        // Function to remove player model and state
        function removePlayer(username) {
            console.log('Removing player:', username);
            const playerState = playerStates.get(username);
            if (playerState) {
                if (playerState.mesh) {
                     scene.remove(playerState.mesh); // Remove mesh from scene
                }
                playerStates.delete(username); // Remove state entry
                playerItems.delete(username); // Remove associated items
                console.log('Player removed successfully:', username);
                updatePlayerList(); // Update UI
            }
        }

        // --- World Object Creation Functions ---

        // Function to create tower from server data
        function createTowerFromData(towerData) {
            let geometry;
            const height = towerData.height;
            const isFloating = towerData.isFloating;
            const baseHeightOffset = towerData.baseHeight || 0; // Use offset from server

            // Shared materials
            const solidMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 }); // Darker solid
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xeeeeee }); // Lighter edges

            // Collision geometry (often simpler or same as visual)
            let collisionGeometry;

            // Select geometry based on type
            switch(towerData.type) {
                case 0: // Cylindrical tower
                    geometry = new THREE.CylinderGeometry(18, 18, height, 8);
                    collisionGeometry = geometry.clone();
                    break;
                case 1: // Tapered tower
                    geometry = new THREE.CylinderGeometry(12, 24, height, 6);
                    collisionGeometry = new THREE.CylinderGeometry(24, 24, height, 6); // Wider base for collision
                    break;
                case 2: // Square tower
                    geometry = new THREE.BoxGeometry(36, height, 36);
                    collisionGeometry = geometry.clone();
                    break;
                case 3: // Hexagonal tower
                    geometry = new THREE.CylinderGeometry(20, 20, height, 6);
                    collisionGeometry = geometry.clone();
                    break;
                case 4: // Twisted tower
                    geometry = new THREE.CylinderGeometry(15, 15, height, 8, 1, true); // Open ended for twist
                    // Apply twist (simplified)
                    const twistAmount = Math.PI / 2; // 90 degree twist
                    const positions = geometry.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const y = positions.getY(i);
                        const progress = (y + height / 2) / height; // 0 to 1
                        const theta = progress * twistAmount;
                        const x = positions.getX(i);
                        const z = positions.getZ(i);
                        positions.setX(i, x * Math.cos(theta) - z * Math.sin(theta));
                        positions.setZ(i, x * Math.sin(theta) + z * Math.cos(theta));
                    }
                    geometry.computeVertexNormals(); // Recalculate normals after twisting
                    collisionGeometry = new THREE.CylinderGeometry(15, 15, height, 8); // Simple cylinder collision
                    break;
                case 5: // Pyramid tower
                    geometry = new THREE.ConeGeometry(24, height, 4);
                    collisionGeometry = geometry.clone();
                    break;
                case 6: // Octagonal tower
                    geometry = new THREE.CylinderGeometry(19, 19, height, 8);
                    collisionGeometry = geometry.clone();
                    break;
                case 7: // Double width tower
                    geometry = new THREE.BoxGeometry(42, height, 42);
                    collisionGeometry = geometry.clone();
                    break;
                case 8: // Inverse pyramid
                    geometry = new THREE.CylinderGeometry(28, 12, height, 4); // Inverted radii
                    collisionGeometry = new THREE.CylinderGeometry(28, 28, height, 4); // Wider collision
                    break;
                case 9: // Star tower (approximate with cylinder)
                    geometry = new THREE.CylinderGeometry(18, 24, height, 5); // 5 sides
                    collisionGeometry = geometry.clone();
                    break;
                case 10: // Thin spire
                    geometry = new THREE.CylinderGeometry(8, 16, height, 6);
                    collisionGeometry = new THREE.CylinderGeometry(16, 16, height, 6); // Wider collision
                    break;
                case 11: // Complex tower (stacked shapes)
                    const baseH = height * 0.6;
                    const topH = height * 0.4;
                    const baseGeo = new THREE.BoxGeometry(38, baseH, 38);
                    const topGeo = new THREE.ConeGeometry(28, topH, 6);
                    collisionGeometry = new THREE.BoxGeometry(38, height, 38); // Simple box collision

                    // Create group for visual parts
                    const complexGroup = new THREE.Group();
                    const baseMesh = new THREE.Mesh(baseGeo, solidMaterial);
                    const baseEdges = new THREE.LineSegments(new THREE.EdgesGeometry(baseGeo), edgeMaterial);
                    const topMesh = new THREE.Mesh(topGeo, solidMaterial);
                    const topEdges = new THREE.LineSegments(new THREE.EdgesGeometry(topGeo), edgeMaterial);

                    // Position top part relative to base part (centered at base's top)
                    topMesh.position.y = baseH / 2 + topH / 2;
                    topEdges.position.y = topMesh.position.y;

                    complexGroup.add(baseMesh, baseEdges, topMesh, topEdges);
                    complexGroup.position.set(towerData.x, baseH / 2 + baseHeightOffset, towerData.z); // Position group pivot at base center

                    // Add visibility data
                    complexGroup.userData.originalPosition = complexGroup.position.clone();
                    complexGroup.userData.isVisible = true;
                    scene.add(complexGroup);

                    // Add collision mesh separately
                    const complexCollisionMesh = new THREE.Mesh(collisionGeometry); // No material needed for collision mesh
                    complexCollisionMesh.position.set(towerData.x, height / 2 + baseHeightOffset, towerData.z); // Center collision box vertically
                    towers.push({
                        mesh: complexCollisionMesh,
                        boundingBox: new THREE.Box3().setFromObject(complexCollisionMesh),
                        visualGroup: complexGroup
                    });
                    return; // Exit early for complex tower type

                 default: // Fallback to cylinder
                    console.warn("Unknown tower type:", towerData.type);
                    geometry = new THREE.CylinderGeometry(18, 18, height, 8);
                    collisionGeometry = geometry.clone();
            }

            // Create visual mesh and edges for standard towers
            const mesh = new THREE.Mesh(geometry, solidMaterial);
            const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geometry), edgeMaterial);

            // Group visual parts
            const group = new THREE.Group();
            group.add(mesh);
            group.add(edges);
            group.position.set(towerData.x, height / 2 + baseHeightOffset, towerData.z); // Center group vertically

            // Add visibility data
            group.userData.originalPosition = group.position.clone();
            group.userData.isVisible = true;
            scene.add(group);

            // Add collision mesh separately
            const collisionMesh = new THREE.Mesh(collisionGeometry); // No material needed
            collisionMesh.position.copy(group.position); // Position collision mesh same as visual pivot
            towers.push({
                mesh: collisionMesh, // Used for raycasting/physics checks
                boundingBox: new THREE.Box3().setFromObject(collisionMesh), // Precompute bounding box
                visualGroup: group // Reference to the visible group for culling
            });
        }

        // Function to create bridge from server data
        function createBridgeFromData(bridgeData) {
            // Calculate bridge dimensions and orientation
            const bridgeWidth = 8; // Visual width
            const collisionDepth = bridgeWidth * 0.6; // Narrower collision depth
            const startPos = new THREE.Vector3(bridgeData.startX, bridgeData.height, bridgeData.startZ);
            const endPos = new THREE.Vector3(bridgeData.endX, bridgeData.height, bridgeData.endZ);
            const distance = startPos.distanceTo(endPos);
            const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5);
            const directionVec = endPos.clone().sub(startPos).normalize();
            const angle = Math.atan2(directionVec.x, directionVec.z); // Correct angle calculation for Y-up

            // Shared materials
            const solidMaterial = new THREE.MeshBasicMaterial({ color: 0x111111 });
            const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xeeeeee });

            // Visual geometry
            const bridgeGeometry = new THREE.BoxGeometry(bridgeWidth, bridgeWidth, distance); // Width, Height, Length

            // Create visual mesh and edges
            const bridgeMesh = new THREE.Mesh(bridgeGeometry, solidMaterial);
            const bridgeEdges = new THREE.LineSegments(new THREE.EdgesGeometry(bridgeGeometry), edgeMaterial);

            // Group visual parts
            const bridgeGroup = new THREE.Group();
            bridgeGroup.add(bridgeMesh);
            bridgeGroup.add(bridgeEdges);
            bridgeGroup.position.copy(midPoint);
            bridgeGroup.rotation.y = angle; // Rotate group to align with direction

            // Add visibility data
            bridgeGroup.userData.originalPosition = bridgeGroup.position.clone();
            bridgeGroup.userData.isVisible = true;
            scene.add(bridgeGroup);

            // Collision geometry (aligned with visual but possibly different size)
            const collisionGeometry = new THREE.BoxGeometry(bridgeWidth, bridgeWidth, distance); // Use same dimensions for simplicity now
            const collisionMesh = new THREE.Mesh(collisionGeometry); // No material needed
            collisionMesh.position.copy(midPoint);
            collisionMesh.rotation.y = angle;

            towers.push({ // Add bridges to the 'towers' array for collision checks
                mesh: collisionMesh,
                boundingBox: new THREE.Box3().setFromObject(collisionMesh),
                visualGroup: bridgeGroup
            });
        }

        // --- WebSocket Communication ---

        // WebSocket setup with Railway support and reconnection logic
        const getWebSocketUrl = () => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            // Use Railway's environment variable if available, otherwise default
            const host = window.location.host; // Assumes server runs on same host/port
            return `${protocol}//${host}`;
        };

        let wsReconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const RECONNECT_BASE_DELAY = 3000; // 3 seconds base

        function setupWebSocket() {
            const wsUrl = getWebSocketUrl();
            console.log(`Attempting to connect WebSocket to: ${wsUrl}`);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected successfully.');
                wsReconnectAttempts = 0; // Reset attempts on successful connection
                // Send join message if game has already started (e.g., after reconnect)
                if (gameStarted && playerUsername) {
                    ws.send(JSON.stringify({
                        type: 'join',
                        username: playerUsername
                    }));
                }
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // console.log('Received message:', data.type, data); // Verbose logging

                    switch (data.type) {
                        case 'world_data':
                            console.log('Received world data');
                            // Clear existing world objects
                            towers.forEach(tower => {
                                if (tower.visualGroup) scene.remove(tower.visualGroup);
                                // Collision mesh wasn't added to scene, no need to remove
                            });
                            towers.length = 0; // Clear the towers array

                            collectibles.forEach(item => {
                                if (item.mesh) scene.remove(item.mesh);
                            });
                            collectibles.clear();

                            // Create new world objects
                            if (data.towers && Array.isArray(data.towers)) {
                                data.towers.forEach(createTowerFromData);
                            }
                             if (data.bridges && Array.isArray(data.bridges)) {
                                data.bridges.forEach(createBridgeFromData);
                            }

                            // Initialize collectibles after world is built
                            initializeCollectibles();
                            break;

                        case 'room_info':
                            console.log(`Joined room ${data.name} with ${data.playerCount} players`);
                            const roomInfoEl = document.getElementById('roomInfo');
                            if(roomInfoEl) roomInfoEl.textContent = `${data.name} - Players: ${data.playerCount}/20`;
                            updatePlayerList(); // Update list as player count might change
                            break;

                        case 'player_joined':
                            console.log('Player joined:', data.username);
                            // Create model only if it doesn't exist and isn't self
                            if (data.username !== playerUsername && !playerStates.has(data.username)) {
                                handlePlayerJoined(data.username, data.position, data.rotation);
                            } else if (playerStates.has(data.username) && data.position && data.rotation) {
                                // If player already exists (e.g., reconnected), update position immediately
                                updatePlayerPosition(data.username, data.position, data.rotation);
                            }
                            updatePlayerList(); // Update UI
                            break;

                        case 'position':
                            // Update remote player position if game started and not self
                            if (data.username !== playerUsername && gameStarted) {
                                updatePlayerPosition(data.username, data.position, data.rotation);
                            }
                            break;

                        case 'player_left':
                            console.log('Player left:', data.username);
                            handlePlayerLeft(data.username); // Removes model and updates UI
                            break;

                        case 'item_collected':
                             // Server confirms item collection
                             console.log(`Item ${data.itemId} collected by ${data.username}`);
                            handleItemCollection(data.itemId, data.username);
                            break;

                        case 'player_hit':
                            console.log('Received player_hit confirmation:', data);
                            if (data.targetUsername && data.damage != null) {
                                const targetPlayerState = playerStates.get(data.targetUsername);
                                if (targetPlayerState) {
                                    targetPlayerState.takeDamage(data.damage);
                                    // UI updated within takeDamage via updatePlayerList
                                } else {
                                    console.warn(`Target player ${data.targetUsername} not found locally for hit.`);
                                }
                            }
                            break;

                        // Optional: Handle effects for other players firing
                        case 'player_fired_shotgun':
                           if (data.username !== playerUsername) {
                               // Find player and trigger visual/audio effect
                               const firingPlayerState = playerStates.get(data.username);
                               if (firingPlayerState && firingPlayerState.mesh) {
                                    // console.log(`${data.username} fired shotgun (visual effect placeholder)`);
                                    // TODO: Add muzzle flash at firingPlayerState.mesh.position + direction
                                    // TODO: Add shotgun sound originating from player position
                               }
                           }
                           break;

                        default:
                            console.warn("Received unknown message type:", data.type);
                    }
                } catch (error) {
                     console.error('Error processing WebSocket message:', error, 'Data:', event.data);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket encountered error:', error);
                // Optionally close and trigger reconnect attempt?
                ws.close(); // Trigger onclose handler
            };

            ws.onclose = (event) => {
                console.log(`WebSocket disconnected. Code: ${event.code}, Reason: ${event.reason}`);
                // Clear remote players when disconnected? Or let them time out?
                 playerStates.forEach((state, username) => {
                     if(username !== playerUsername) removePlayer(username);
                 });
                 updatePlayerList();


                if (wsReconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    wsReconnectAttempts++;
                    const delay = RECONNECT_BASE_DELAY * Math.pow(2, wsReconnectAttempts - 1); // Exponential backoff
                    console.log(`Attempting WebSocket reconnect (${wsReconnectAttempts}/${MAX_RECONNECT_ATTEMPTS}) in ${delay / 1000}s...`);
                    setTimeout(setupWebSocket, delay);
                } else {
                     console.error('Max WebSocket reconnect attempts reached. Please refresh the page.');
                     // Optionally display a message to the user
                     const instructionsEl = document.getElementById('instructions');
                     if (instructionsEl) {
                         instructionsEl.innerHTML = `<h2>Connection Lost</h2><p>Could not reconnect to the server. Please refresh the page.</p>`;
                         instructionsEl.classList.remove('hidden');
                     }
                }
            };
        }

        // --- UI Update Functions ---

        // Function to update player list UI
        function updatePlayerList() {
            const playerList = document.getElementById('playerList');
            if (!playerList) return; // Guard against missing element

            playerList.innerHTML = '<div style="margin-bottom: 10px; font-weight: bold;">Players:</div>';

            // Add current player first (if game started)
            if (gameStarted && playerUsername) {
                const currentPlayerItem = document.createElement('div');
                currentPlayerItem.className = 'playerListItem';
                const currentPlayerState = playerStates.get(playerUsername);
                const currentPlayerHealth = currentPlayerState ? currentPlayerState.health : 100;
                const currentItems = playerItems.get(playerUsername)?.size || 0;
                currentPlayerItem.textContent = `${playerUsername} (You) - HP: ${currentPlayerHealth} - Items: ${currentItems}/${ITEM_COUNT}`;
                playerList.appendChild(currentPlayerItem);
            }

            // Add other players
            playerStates.forEach((playerState, username) => {
                if (username !== playerUsername && playerState.mesh) { // Ensure mesh exists
                    const playerItem = document.createElement('div');
                    playerItem.className = 'playerListItem';
                    const items = playerItems.get(username)?.size || 0;
                    playerItem.textContent = `${username} - HP: ${playerState.health} - Items: ${items}/${ITEM_COUNT}`;
                    playerList.appendChild(playerItem);
                }
            });
        }

        // Function to handle player joining
        function handlePlayerJoined(username, initialPosition, initialRotation) {
             if (username !== playerUsername && gameStarted && !playerStates.has(username)) {
                 console.log(`Handling join for ${username}`);
                createPlayerModel(username);
                // Set initial position immediately if provided
                if(initialPosition && initialRotation) {
                     updatePlayerPosition(username, initialPosition, initialRotation); // Update target
                     const playerState = playerStates.get(username);
                     if (playerState && playerState.mesh) { // Apply to current immediately
                         playerState.currentPosition.fromArray(initialPosition);
                         playerState.currentRotation.fromArray(initialRotation);
                         playerState.mesh.position.copy(playerState.currentPosition);
                         playerState.mesh.rotation.copy(playerState.currentRotation);
                     }
                }
                updatePlayerList();
            }
        }

        // Function to handle player leaving
        function handlePlayerLeft(username) {
            removePlayer(username); // Removes model, state, and updates list
        }

        // Add orb counter UI element
        const orbCounter = document.createElement('div');
        orbCounter.id = 'orbCounter'; // Add ID for easier selection if needed
        orbCounter.style.position = 'fixed';
        orbCounter.style.top = '10px';
        orbCounter.style.left = '50%';
        orbCounter.style.transform = 'translateX(-50%)';
        orbCounter.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        orbCounter.style.color = '#4CAF50';
        orbCounter.style.padding = '10px 15px';
        orbCounter.style.borderRadius = '5px';
        orbCounter.style.zIndex = '1000';
        orbCounter.style.fontFamily = 'Arial, sans-serif';
        orbCounter.style.fontSize = '16px';
        orbCounter.style.fontWeight = 'bold';
        orbCounter.style.textShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
        orbCounter.textContent = 'Orbs: 0/0 | In Scene: 0'; // Initial text
        document.body.appendChild(orbCounter);

        // Function to update orb counter UI
        function updateOrbCounter() {
            const collectedOrbs = playerItems.get(playerUsername)?.size || 0;
            const remainingInScene = collectibles.size; // Orbs currently visible
            orbCounter.textContent = `Your Orbs: ${collectedOrbs}/${ITEM_COUNT} | In Scene: ${remainingInScene}`;
        }

        // --- Collectible Item Logic ---

        // Function to find valid spawn position for collectible item
        function findValidTowerPosition() {
            const validTowers = towers.filter(tower => {
                // Check if tower collision mesh has valid geometry and height
                if (!tower.mesh || !tower.mesh.geometry || !tower.mesh.geometry.parameters) return false;
                const towerHeight = tower.mesh.geometry.parameters.height || 0;
                // Base height offset might be needed if pivot isn't at base
                const towerBaseY = tower.mesh.position.y - towerHeight / 2;
                // Check if tower top is above a certain threshold (e.g., above ground plane)
                return towerHeight > 20 && towerBaseY > -50; // Min height and not sunk below ground
            });

            if (validTowers.length === 0) {
                console.warn('No valid towers found for item placement');
                return null;
            }

            // Try random towers multiple times
            let attempts = 0;
            const maxPlacementAttempts = Math.min(validTowers.length * 2, 50); // Limit attempts

            while (attempts < maxPlacementAttempts) {
                 attempts++;
                 const randomTower = validTowers[Math.floor(Math.random() * validTowers.length)];
                 const towerHeight = randomTower.mesh.geometry.parameters.height;
                 const towerPosition = randomTower.mesh.position;

                 // Place slightly above the top surface of the collision mesh
                 const heightOffset = ITEM_RADIUS + 1; // Offset by item radius + buffer
                 const position = new THREE.Vector3(
                     towerPosition.x,
                     towerPosition.y + towerHeight / 2 + heightOffset,
                     towerPosition.z
                 );

                 // Check minimum distance from other existing collectibles
                 let isValid = true;
                 for (const item of collectibles.values()) {
                     if (position.distanceTo(item.position) < MIN_DISTANCE_BETWEEN_ITEMS) {
                         isValid = false;
                         break;
                     }
                 }

                 if (isValid) return position; // Found a valid spot
            }

            console.warn(`Failed to find valid item position after ${maxPlacementAttempts} attempts.`);
            return null; // No valid position found
        }

        // Function to create collectible item mesh and state
        function createCollectible(id, position, color) {
            const geometry = new THREE.SphereGeometry(ITEM_RADIUS, 8, 8); // Slightly lower poly
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData.id = id; // Store ID in mesh userData

            // Add floating animation data to mesh userData
            mesh.userData.originalY = position.y;
            mesh.userData.floatOffset = Math.random() * Math.PI * 2;

            scene.add(mesh);
            // Store relevant data in collectibles map
            collectibles.set(id, {
                mesh: mesh,
                position: position.clone(), // Keep original position separate
                color: color,
                userData: mesh.userData // Reference mesh userData for animation
            });
        }

        // Function to initialize collectibles on the map
        function initializeCollectibles() {
            console.log('Initializing collectibles...');
            let successfulPlacements = 0;
            for (let i = 0; i < ITEM_COUNT; i++) {
                let position = findValidTowerPosition();
                if (position) {
                    // Use modulo to wrap colors if ITEM_COUNT > ITEM_COLORS.length
                    createCollectible(i, position, ITEM_COLORS[i % ITEM_COLORS.length]);
                    successfulPlacements++;
                } else {
                    console.warn(`Failed to find valid position for collectible ${i}, stopping placement.`);
                    break; // Stop trying if placement fails
                }
            }
            console.log(`Initialized ${successfulPlacements} collectibles out of ${ITEM_COUNT} attempted.`);
            updateOrbCounter(); // Update UI
        }

        // Function to handle item collection based on server message
        function handleItemCollection(itemId, collectorUsername) {
            const item = collectibles.get(itemId);
            if (item && item.mesh) { // Check if item exists locally
                console.log(`Processing collection for item ${itemId} by ${collectorUsername}`);
                scene.remove(item.mesh); // Remove mesh from scene
                collectibles.delete(itemId); // Remove from local map

                // Update collector's item count
                if (!playerItems.has(collectorUsername)) {
                    playerItems.set(collectorUsername, new Set());
                }
                playerItems.get(collectorUsername).add(itemId);

                // Update UI
                updatePlayerList();
                updateOrbCounter();

                // Play collection sound (only if collected by self)
                if (collectorUsername === playerUsername) {
                     // Placeholder for sound
                     console.log("Collected an orb!");
                     // const collectSound = new Audio('path/to/collect.wav');
                     // collectSound.play().catch(e => console.warn("Sound play failed:", e));
                }
            } else {
                 console.warn(`Item ${itemId} not found locally for collection.`);
            }
        }

        // --- Starfield and Nebula Creation ---

        // Nebula shader code
        const nebulaVertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        const nebulaFragmentShader = `
            uniform float time;
            uniform vec3 color;
            varying vec2 vUv;

            // Perlin noise functions (example implementation)
            float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }
            float noise(vec2 co){
                vec2 i = floor(co);
                vec2 f = fract(co);
                float a = rand(i);
                float b = rand(i + vec2(1.0, 0.0));
                float c = rand(i + vec2(0.0, 1.0));
                float d = rand(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }
            float fbm(vec2 co){
                float H = 0.6; // Hurst exponent, controls roughness (0.0-1.0)
                float lacunarity = 2.1; // Gap between successive frequencies ( > 1.0)
                float octaves = 5.0; // Number of noise layers
                float value = 0.0;
                float frequency = 1.0;
                float amplitude = 0.5;
                for(int i = 0; i < int(octaves); i++){
                    value += amplitude * noise(co * frequency);
                    frequency *= lacunarity;
                    amplitude *= H;
                }
                return value;
            }

            void main() {
                vec2 uv = vUv * 2.0 - 1.0; // Center UVs
                float noiseValue = fbm(uv * 2.5 + time * 0.05); // Scale UVs and add time evolution

                // Create a soft, fading edge
                float dist = length(uv);
                float edgeFade = smoothstep(1.0, 0.6, dist); // Fade from distance 0.6 to 1.0

                // Combine noise and edge fade
                float alpha = pow(noiseValue, 1.5) * edgeFade; // Enhance contrast with pow

                gl_FragColor = vec4(color, alpha * 0.8); // Use passed color, adjust overall opacity
            }
        `;

        function createNebula(position, scale, rotation) {
            const nebulaGeometry = new THREE.PlaneGeometry(500 * scale, 500 * scale); // Large plane
            const nebulaMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    color: { value: new THREE.Color(Math.random() * 0.5 + 0.2, Math.random() * 0.5 + 0.2, Math.random() * 0.5 + 0.5) } // Random bluish/purplish
                },
                vertexShader: nebulaVertexShader,
                fragmentShader: nebulaFragmentShader,
                transparent: true,
                depthWrite: false, // Don't obscure objects behind
                blending: THREE.AdditiveBlending // Brighter where overlaps
            });

            const nebulaMesh = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            nebulaMesh.position.copy(position);
            nebulaMesh.rotation.copy(rotation);
            scene.add(nebulaMesh);
            return nebulaMesh; // Return the mesh for animation updates
        }

        function createStars() {
             // Stars
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(10000);
                const y = THREE.MathUtils.randFloatSpread(10000);
                const z = THREE.MathUtils.randFloatSpread(10000);
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                sizeAttenuation: false // Consistent size regardless of distance
            });
            starField = new THREE.Points(starGeometry, starMaterial); // Assign to global
            scene.add(starField);

             // Larger, closer stars
             const largeStarGeometry = new THREE.BufferGeometry();
             const largeStarVertices = [];
             for (let i = 0; i < 500; i++) {
                 const x = THREE.MathUtils.randFloatSpread(6000);
                 const y = THREE.MathUtils.randFloatSpread(6000);
                 const z = THREE.MathUtils.randFloatSpread(6000);
                 largeStarVertices.push(x, y, z);
             }
             largeStarGeometry.setAttribute('position', new THREE.Float32BufferAttribute(largeStarVertices, 3));
             const largeStarMaterial = new THREE.PointsMaterial({
                 color: 0xeeeeff,
                 size: 5,
                 sizeAttenuation: false
             });
             largeStarField = new THREE.Points(largeStarGeometry, largeStarMaterial); // Assign to global
             scene.add(largeStarField);
        }

        // --- Main Setup and Game Loop ---

        // Scene setup wrapped in try...catch
        try {
            // Scene initialization
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            // scene.fog = new THREE.FogExp2(0x000000, 0.00025); // Optional exponential fog
            console.log('Scene created');

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000); // Far plane
            camera.position.set(0, playerHeight, 0);
            console.log('Camera initialized');

            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                antialias: true, // Smoother edges
                powerPreference: "high-performance",
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
            renderer.setClearColor(0x000000, 1);
            document.body.appendChild(renderer.domElement);
            console.log('Renderer initialized');

            // Controls setup
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject()); // Add camera pivot to scene for movement
            console.log('Controls initialized');

            // --- World Visuals ---
            // Nebulas
            const nebulaPositions = []; // Avoid overlap
            const minNebulaDistance = 1500;
            for (let i = 0; i < 10; i++) { // Reduced nebula count slightly
                let pos;
                let isValid = false;
                for(let attempt = 0; attempt < 10 && !isValid; attempt++) {
                     const angle = Math.random() * Math.PI * 2;
                     const radius = 4000 + Math.random() * 4000; // Wider radius range
                     pos = new THREE.Vector3(
                         Math.cos(angle) * radius,
                         Math.random() * 3000 - 1500,
                         Math.sin(angle) * radius
                     );
                     isValid = nebulaPositions.every(p => p.distanceTo(pos) > minNebulaDistance);
                }
                if (isValid) {
                     nebulaPositions.push(pos);
                     const scale = 5 + Math.random() * 7;
                     const rotation = new THREE.Euler(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                     nebulas.push(createNebula(pos, scale, rotation));
                }
            }
            // Grids
            const gridHelper = new THREE.GridHelper(8000, 160, 0x444444, 0x222222); // Main grid
            scene.add(gridHelper);
            const farGridHelper = new THREE.GridHelper(16000, 160, 0x333333, 0x111111); // Far grid
            scene.add(farGridHelper);
            // Stars
            let starField, largeStarField; // Declare variables
            createStars(); // Populate star fields

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0x606060); // Softer ambient
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); // Main light source
            directionalLight.position.set(70, 120, 100);
            scene.add(directionalLight);

            // --- Fling Line Trace ---
            const curvePoints = [new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,1)];
            const curve = new THREE.CatmullRomCurve3(curvePoints, false, 'catmullrom', 0.1);
            const tubeGeometry = new THREE.TubeGeometry(curve, 2, 0.1, 6, false); // Simpler geometry
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.7,
                depthWrite: false
            });
            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tubeMesh.visible = false; // Start hidden
            scene.add(tubeMesh);

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);
            // Input listeners (Desktop) added later based on isMobile check
            // Start Button listener
            const instructionsEl = document.getElementById('instructions');
            const usernameInput = document.getElementById('username');
            const startButton = document.getElementById('startButton');
            usernameInput.addEventListener('input', () => {
                startButton.disabled = usernameInput.value.trim().length === 0;
            });
            startButton.addEventListener('click', handleStartGameClick);
            // Pointer Lock controls listeners
            controls.addEventListener('lock', handleControlsLock);
            controls.addEventListener('unlock', handleControlsUnlock);
            // Initialize Mobile Controls if necessary
            if (isMobile) initializeMobileControls();
            // Add Desktop Input Listeners if not mobile
            else addDesktopInputListeners();


             // --- Helper Functions for Setup ---
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

             function handleStartGameClick(event) {
                event.preventDefault();
                const desiredUsername = usernameInput.value.trim();
                if (desiredUsername) {
                    playerUsername = desiredUsername;
                    gameStarted = true;
                    instructionsEl.classList.add('hidden');

                    // Ensure own player model exists and reset state
                    if (!playerStates.has(playerUsername)) createPlayerModel(playerUsername);
                    const selfState = playerStates.get(playerUsername);
                    if (selfState) {
                         selfState.health = 100;
                         if(selfState.mesh) selfState.mesh.visible = false; // Ensure own model is hidden
                    }
                    updatePlayerList(); // Show initial state in UI

                    // Send join message
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'join', username: playerUsername }));
                    } else {
                         console.warn("WebSocket not open when clicking Start Game.");
                         // Connection will likely happen via setupWebSocket -> onopen
                    }

                    // Activate controls
                    controls.lock();
                }
            }

            function handleControlsLock() {
                instructionsEl.classList.add('hidden');
                moveForward = moveBackward = moveLeft = moveRight = showLine = false; // Reset state
            }

             function handleControlsUnlock() {
                 // Don't immediately show instructions on unlock, could be temporary (e.g., ESC)
                 // Reset aiming state
                 showLine = false;
                 tubeMesh.visible = false;
                 // Stop holding Z for player list
                 document.getElementById('playerList').classList.remove('visible');
                 // Don't reset gameStarted here
            }

            function addDesktopInputListeners() {
                 document.addEventListener('keydown', onKeyDown);
                 document.addEventListener('keyup', onKeyUp);
                 document.addEventListener('mousedown', onMouseDown);
                 document.addEventListener('mouseup', onMouseUp);
            }

            // --- Input Handler Functions (Desktop) ---
            function onKeyDown(event) {
                if (!controls.isLocked) return; // Only process keys when locked
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = true; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                    case 'ArrowRight': case 'KeyD': moveRight = true; break;
                    case 'KeyE': showLine = true; break; // Aim Fling
                    case 'KeyF': fireShotgun(); break; // Fire
                    case 'KeyZ': document.getElementById('playerList').classList.add('visible'); break; // Show players
                }
            }

             function onKeyUp(event) {
                // Process key up even if not locked (to cancel movement/actions)
                switch (event.code) {
                    case 'ArrowUp': case 'KeyW': moveForward = false; break;
                    case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                    case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                    case 'ArrowRight': case 'KeyD': moveRight = false; break;
                    case 'KeyE': // Release Fling Aim Key
                        showLine = false;
                        triggerFling(); // Attempt fling on key release
                        break;
                    case 'KeyZ': document.getElementById('playerList').classList.remove('visible'); break; // Hide players
                }
            }

            function onMouseDown(event) {
                 if (controls.isLocked && event.button === 0) { // Left Mouse Button
                     showLine = true; // Aim Fling
                 }
                  if (controls.isLocked && event.button === 2) { // Right Mouse Button (Optional: Alt fire?)
                      // fireShotgun(); // Example: Right click fires too?
                  }
            }

            function onMouseUp(event) {
                 if (controls.isLocked && event.button === 0) { // Left Mouse Button Release
                     showLine = false;
                     triggerFling(); // Attempt fling on release
                 }
            }

             // Helper to trigger fling action (used by KeyUp and MouseUp)
            function triggerFling() {
                 if (lineCollisionPoint) {
                    const flingDirection = lineCollisionPoint.clone().sub(controls.getObject().position).normalize();
                    const distanceToTarget = controls.getObject().position.distanceTo(lineCollisionPoint);
                    // Scale strength based on distance (adjust multiplier as needed)
                    const scaledStrength = Math.min(distanceToTarget * 0.1, flingStrength * 1.5);
                    // Apply impulse directly to flingVelocity (additive might be complex)
                    flingVelocity.copy(flingDirection).multiplyScalar(scaledStrength);
                    // Add upward boost based on direction and strength
                    verticalVelocity = Math.max(0.5, flingDirection.y * scaledStrength * 0.8); // Ensure minimum upward boost
                    isFlinging = true;
                    isGrounded = false; // Become airborne
                    lineCollisionPoint = null; // Consume collision point
                 }
                 tubeMesh.visible = false; // Ensure line hidden
            }


            // --- Game Logic / Shotgun Functions ---

             function fireShotgun() {
                if (!gameStarted || !controls.isLocked) return;

                const now = Date.now();
                if (now - lastShotTime < SHOTGUN_FIRE_RATE) {
                    return; // Cooldown active
                }
                lastShotTime = now;

                console.log("Firing shotgun!");
                // TODO: Add sound effect at player position

                const cameraObject = controls.getObject();
                const fireDirection = new THREE.Vector3();
                cameraObject.getWorldDirection(fireDirection);
                // Start pellets slightly in front of camera
                const fireOrigin = cameraObject.position.clone().addScaledVector(fireDirection, 1.5);

                for (let i = 0; i < SHOTGUN_PELLET_COUNT; i++) {
                    // Calculate spread using random angle offsets
                    const spreadAngleX = (Math.random() - 0.5) * SHOTGUN_SPREAD_ANGLE * 2;
                    const spreadAngleY = (Math.random() - 0.5) * SHOTGUN_SPREAD_ANGLE * 2;

                    // Create quaternion for spread rotation
                    const spreadQuat = new THREE.Quaternion();
                    spreadQuat.setFromEuler(new THREE.Euler(spreadAngleX, spreadAngleY, 0, 'YXZ')); // Apply spread rotation

                    // Apply spread to fire direction
                    const pelletDirection = fireDirection.clone().applyQuaternion(spreadQuat).normalize();

                    createProjectile(fireOrigin, pelletDirection);
                }

                // Notify server that this player fired (for effects on other clients)
                 if (ws && ws.readyState === WebSocket.OPEN) {
                     ws.send(JSON.stringify({ type: 'fire_shotgun', username: playerUsername }));
                 }
            }

            function createProjectile(origin, direction) {
                // Consider Object Pooling here if performance becomes an issue
                const projectileMesh = new THREE.Mesh(projectileGeometry, projectileMaterial);
                projectileMesh.position.copy(origin);
                projectileMesh.userData.direction = direction.clone(); // Store normalized direction
                projectileMesh.userData.speed = SHOTGUN_PELLET_SPEED; // Store speed
                projectileMesh.userData.distanceTravelled = 0;
                projectileMesh.userData.owner = playerUsername; // Track owner

                scene.add(projectileMesh);
                projectiles.push(projectileMesh); // Add to active projectiles list
            }


            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);

                const delta = clock.getDelta(); // Time since last frame
                const time = performance.now() * 0.001; // Current time in seconds

                // --- Update Projectiles ---
                const projectilesToRemoveIndexes = []; // Store indexes to remove
                const worldCollisionCheckSphere = new THREE.Sphere(); // Reusable sphere for world collision
                const playerCheckSphere = new THREE.Sphere(); // Reusable sphere for player collision

                projectiles.forEach((projectile, index) => {
                    const moveDistance = projectile.userData.speed * delta;
                    projectile.position.addScaledVector(projectile.userData.direction, moveDistance);
                    projectile.userData.distanceTravelled += moveDistance;

                    // Check range limit
                    if (projectile.userData.distanceTravelled > SHOTGUN_RANGE) {
                        projectilesToRemoveIndexes.push(index);
                        return;
                    }

                    // Prepare collision sphere for this projectile
                    playerCheckSphere.set(projectile.position, projectileGeometry.parameters.radius);

                    // Check collision with other players
                    let hitRegistered = false;
                    playerStates.forEach((playerState, username) => {
                        if (hitRegistered) return; // Stop checking this pellet if it hit someone
                        if (username !== projectile.userData.owner && playerState.mesh && playerState.health > 0 && playerState.mesh.visible) { // Check alive and visible
                             const playerBox = new THREE.Box3().setFromObject(playerState.mesh);
                             if (playerBox.intersectsSphere(playerCheckSphere)) {
                                console.log(`Projectile hit ${username}!`);
                                projectilesToRemoveIndexes.push(index);
                                hitRegistered = true; // Mark pellet as consumed

                                // Send hit message to server for validation/broadcast
                                if (ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({
                                        type: 'hit_player',
                                        targetUsername: username,
                                        damage: SHOTGUN_DAMAGE_PER_PELLET,
                                        attackerUsername: projectile.userData.owner
                                    }));
                                }
                            }
                        }
                    });

                     // Check collision with world geometry (if not already removed)
                     if (!hitRegistered) {
                         worldCollisionCheckSphere.set(projectile.position, projectileGeometry.parameters.radius);
                         for (const tower of towers) {
                             if (tower.boundingBox.intersectsSphere(worldCollisionCheckSphere)) {
                                 projectilesToRemoveIndexes.push(index);
                                 // TODO: Add impact effect (e.g., particle spark) at projectile.position
                                 hitRegistered = true; // Mark pellet as consumed
                                 break; // Stop checking world objects for this pellet
                             }
                         }
                     }
                });

                // Remove projectiles marked for removal (iterate backwards for safe splicing)
                // Sort indexes descending to avoid index shifting issues during splice
                projectilesToRemoveIndexes.sort((a, b) => b - a);
                projectilesToRemoveIndexes.forEach(index => {
                    if (projectiles[index]) {
                         scene.remove(projectiles[index]);
                         projectiles.splice(index, 1);
                    }
                });


                // --- Update Object Visibility Culling ---
                 towers.forEach(tower => {
                     if (tower.visualGroup && tower.visualGroup.userData.originalPosition) { // Check required properties
                         const distance = controls.getObject().position.distanceTo(tower.visualGroup.userData.originalPosition);
                         const shouldBeVisible = distance <= CULL_DISTANCE;

                         if (shouldBeVisible !== tower.visualGroup.userData.isVisible) { // Only update if state changes
                             tower.visualGroup.visible = shouldBeVisible;
                             tower.visualGroup.userData.isVisible = shouldBeVisible;
                         }
                     }
                 });


                // --- Update Animations (Nebulas, Stars, Collectibles) ---
                // Update nebula uniforms and rotations (frame-rate independent)
                nebulas.forEach(nebula => {
                    if (nebula.material.uniforms) nebula.material.uniforms.time.value = time;
                    nebula.rotation.y += 0.0001 * delta * 60;
                    nebula.rotation.x += 0.00005 * delta * 60;
                });
                // Rotate star fields (frame-rate independent)
                if (starField) starField.rotation.y += 0.00005 * delta * 60;
                if (largeStarField) largeStarField.rotation.y += 0.00008 * delta * 60;
                // Update collectible floating animation
                collectibles.forEach(item => {
                     if (item.mesh && item.userData) { // Ensure mesh and userData exist
                         const floatSpeed = 1.5;
                         const floatHeight = 0.5;
                         item.mesh.position.y = item.userData.originalY + Math.sin(time * floatSpeed + item.userData.floatOffset) * floatHeight;
                     }
                });


                // --- Update Remote Player Interpolation ---
                if (gameStarted) {
                    playerStates.forEach((playerState, username) => {
                        if (username !== playerUsername) {
                            // Check for inactive player timeout
                            if ((Date.now() - playerState.lastUpdateTime) > 10000) { // 10 seconds
                                console.log('Removing inactive player:', username);
                                removePlayer(username);
                            } else if (playerState.mesh) { // Ensure mesh exists
                                playerState.update(delta); // Interpolate position/rotation
                            }
                        }
                    });
                }


                // --- Update Local Player Physics & Controls ---
                if (gameStarted && controls.isLocked) {
                    const cameraObject = controls.getObject(); // Player's camera/control object

                    // --- Calculate Movement Impulse ---
                    direction.set(0, 0, 0); // Reset direction vector
                    direction.z = Number(moveForward) - Number(moveBackward);
                    direction.x = Number(moveRight) - Number(moveLeft);
                    direction.normalize(); // Prevent faster diagonal movement

                    // Apply movement impulse relative to camera direction
                    const moveImpulse = new THREE.Vector3();
                    moveImpulse.z = direction.z * moveSpeed * delta * 100; // Scale by delta and factor
                    moveImpulse.x = direction.x * moveSpeed * delta * 100;
                    moveImpulse.applyQuaternion(cameraObject.quaternion); // Rotate impulse to world space
                    velocity.add(moveImpulse); // Add impulse to current velocity

                    // --- Fling Line Trace ---
                    tubeMesh.visible = showLine;
                    if (showLine) {
                         const lineDirection = new THREE.Vector3();
                         camera.getWorldDirection(lineDirection);
                         const startPoint = cameraObject.position.clone().addScaledVector(lineDirection, 0.5); // Start slightly in front
                         startPoint.y -= 0.5; // Start slightly lower

                         raycaster.set(startPoint, lineDirection);
                         raycaster.far = 330; // Max fling range

                         const intersects = raycaster.intersectObjects(towers.map(t => t.mesh), false); // Check only collision meshes

                         let finalEndPoint;
                         if (intersects.length > 0) {
                             // intersects are sorted by distance automatically
                             lineCollisionPoint = intersects[0].point;
                             finalEndPoint = lineCollisionPoint;
                             tubeMaterial.color.setHex(0x00ff00); // Green: Target locked
                         } else {
                             lineCollisionPoint = null;
                             finalEndPoint = startPoint.clone().addScaledVector(lineDirection, raycaster.far); // Extend to max range
                             tubeMaterial.color.setHex(0xff0000); // Red: No target
                         }

                         // Update tube geometry vertices smoothly
                         curvePoints[0].lerp(startPoint, 0.6);
                         curvePoints[1].lerp(finalEndPoint, 0.6);
                         tubeMesh.geometry.setFromPoints(curve.getPoints(8)); // Update existing geometry vertices
                         tubeMesh.geometry.verticesNeedUpdate = true; // Flag for update
                    } else {
                         lineCollisionPoint = null; // Ensure reset when not showing line
                    }

                    // --- Apply Physics (Gravity, Velocity, Fling) ---
                    const oldPosition = cameraObject.position.clone();
                    if (!isGrounded) {
                        verticalVelocity -= gravity * delta * 60; // Apply scaled gravity
                    }
                    // Apply horizontal fling impulse (damps over time)
                    if (isFlinging) {
                        velocity.x += flingVelocity.x * delta * 60;
                        velocity.z += flingVelocity.z * delta * 60;
                        // Apply damping (frame-rate independent)
                        flingVelocity.multiplyScalar(Math.pow(flingDamping, delta * 60));
                        if (flingVelocity.lengthSq() < 0.01) {
                            isFlinging = false;
                            flingVelocity.set(0, 0, 0);
                        }
                    }
                    // Apply final velocity (movement + fling + gravity)
                    cameraObject.position.x += velocity.x * delta;
                    cameraObject.position.z += velocity.z * delta;
                    cameraObject.position.y += verticalVelocity * delta;

                    // --- Collision Detection & Response ---
                    isGrounded = false; // Assume airborne
                    playerCollider.set(cameraObject.position, playerRadius); // Update collider

                    let collisionDetected = false;
                    for (const tower of towers) {
                         if (tower.boundingBox.intersectsSphere(playerCollider)) {
                             collisionDetected = true;
                             // More accurate check: OBB vs Sphere or AABB vs Sphere penetration
                             const closestPoint = tower.boundingBox.clampPoint(playerCollider.center, new THREE.Vector3());
                             const penetrationVector = playerCollider.center.clone().sub(closestPoint);
                             const penetrationDepth = playerCollider.radius - penetrationVector.length();

                             if (penetrationDepth > 0.001) { // Check for actual penetration
                                 const pushDirection = penetrationVector.normalize();
                                 cameraObject.position.addScaledVector(pushDirection, penetrationDepth); // Resolve penetration

                                 // Check if collision normal indicates ground
                                 if (pushDirection.y > 0.6) { // Steeper angle threshold for ground
                                      isGrounded = true;
                                      verticalVelocity = Math.max(0, verticalVelocity); // Stop downward or bounce slightly? Set to 0 for now.
                                      if(isFlinging) isFlinging = false; // Stop fling on ground impact
                                 } else {
                                      // Wall collision: Dampen velocity components into the wall
                                      const wallNormal = pushDirection.clone(); // Horizontal component of push
                                      wallNormal.y = 0;
                                      wallNormal.normalize();
                                      const wallVel = velocity.dot(wallNormal);
                                      if (wallVel < 0) { // Moving into the wall
                                          velocity.subScaledVector(wallNormal, wallVel * 1.1); // Reduce velocity into wall
                                      }
                                      // Also handle vertical component if hitting underside/slight slope
                                      const vertVelComp = verticalVelocity * pushDirection.y;
                                      if(vertVelComp < 0 && pushDirection.y < 0.6) { // Hitting something above
                                          verticalVelocity = 0; // Stop upward movement
                                      }
                                 }
                             }
                         }
                    }

                    // Update collider center after potential position adjustments
                    playerCollider.center.copy(cameraObject.position);


                    // Check for falling out of world
                    if (cameraObject.position.y < -200) { // Lower threshold
                        console.log("Fell out, respawning...");
                        cameraObject.position.set(0, playerHeight + 50, 0); // Respawn higher
                        velocity.set(0, 0, 0);
                        verticalVelocity = 0;
                        isGrounded = true;
                        isFlinging = false;
                        flingVelocity.set(0, 0, 0);
                        // TODO: Reset health? Send respawn message?
                         const selfState = playerStates.get(playerUsername);
                         if(selfState) selfState.health = 100; // Reset health on respawn
                         updatePlayerList();
                    }

                    // Apply damping/friction to horizontal movement velocity (frame-rate independent)
                    const dampingFactor = Math.pow(0.85, delta * 60); // Adjust base friction (0.85) as needed
                    velocity.x *= dampingFactor;
                    velocity.z *= dampingFactor;


                    // --- Item Collection Check (Player runs over item) ---
                    const playerCheckSphereCollect = new THREE.Sphere(cameraObject.position, playerRadius + ITEM_RADIUS); // Slightly larger check radius
                    collectibles.forEach((item, itemId) => {
                        if (item.mesh && playerCheckSphereCollect.containsPoint(item.mesh.position)) {
                            // Send collection attempt to server
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'item_collected',
                                    itemId: itemId,
                                    username: playerUsername
                                }));
                                // Client doesn't remove immediately, waits for server confirmation via 'item_collected' broadcast
                            }
                        }
                    });


                    // --- Update Own Player Model Position (Hidden) ---
                     const selfState = playerStates.get(playerUsername);
                     if(selfState && selfState.mesh) {
                         selfState.mesh.position.copy(cameraObject.position);
                         selfState.mesh.rotation.copy(cameraObject.rotation);
                     }

                } else {
                     // If controls not locked, gradually stop all movement
                     velocity.multiplyScalar(Math.pow(0.9, delta * 60));
                     verticalVelocity *= Math.pow(0.9, delta * 60);
                     flingVelocity.multiplyScalar(Math.pow(0.9, delta * 60));
                     if(flingVelocity.lengthSq() < 0.01) isFlinging = false;
                }

                // Always render the scene at the end of the frame
                renderer.render(scene, camera);
            } // End of animate()

            // Start the animation loop
            animate();

            // Start sending position updates periodically
            setInterval(sendPositionUpdate, 40); // Send updates ~25 times per second

        } catch (error) {
            // Display initialization error prominently
            console.error('Critical Error during Initialization:', error);
            document.body.innerHTML = `
                <div style="color: #ff8888; background: #111; border: 2px solid red; padding: 20px; margin: 20px; font-family: monospace; white-space: pre-wrap;">
                    <h2>Initialization Error</h2>
                    <p>The game could not start due to the following error:</p>
                    <pre>${error.stack || error}</pre>
                    <p>Please check the browser console (F12) for more details and try refreshing the page.</p>
                </div>
            `;
        }

        // Initialize WebSocket connection after initial setup attempt
        setupWebSocket();

    </script>
</body>
</html>
