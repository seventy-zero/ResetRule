<!DOCTYPE html>
<html lang="en">
<head>
    <title>ResetRule</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/virtual-joystick/1.10.0/virtual-joystick.min.js"></script>
    <style>
        body { 
            margin: 0; 
            background-color: #000000;
        }
        canvas { 
            display: block; 
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            z-index: 1000;
        }
        #instructions.hidden {
            display: none;
        }
        #username {
            margin: 10px 0;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-size: 16px;
            width: 200px;
            text-align: center;
        }
        #startButton {
            margin-top: 15px;
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #45a049;
        }
        #startButton:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            height: 120px;
            width: 120px;
            pointer-events: auto;
            z-index: 1000;
        }
        .joystick-zone {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 60px;
            pointer-events: auto;
            z-index: 1000;
            touch-action: none;
        }
        .joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            pointer-events: none;
            transform: translate(-50%, -50%);
        }
        #flingButton {
            display: none;
            position: fixed;
            bottom: 160px;
            left: 40px;
            width: 60px;
            height: 60px;
            background: rgba(76, 175, 80, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            line-height: 60px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            z-index: 1000;
            touch-action: none;
        }
        #flingButton.active {
            background: rgba(76, 175, 80, 0.9);
        }
        /* Show mobile controls on touch devices */
        @media (pointer: coarse) {
            .mobile-controls {
                display: block !important;
            }
            #flingButton {
                display: block !important;
            }
        }
        #roomInfo {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        #playerList {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            display: none;
            min-width: 150px;
        }

        #playerList.visible {
            display: block;
        }

        .playerListItem {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .playerListItem:hover {
            background-color: rgba(76, 175, 80, 0.2);
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>Welcome to ResetRule</h2>
        <input type="text" id="username" placeholder="Enter your username" maxlength="15">
        <button id="startButton" disabled>Start Game</button>
        <p style="margin-top: 20px;">
            Desktop Controls:<br>
            WASD = Move<br>
            Mouse = Look around<br>
            ESC = Exit<br>
            Left Click = Aim & Release to Fling
        </p>
        <p id="mobileInstructions" style="display: none; margin-top: 20px;">
            Mobile Controls:<br>
            Right Stick = Look around<br>
            Fling Button = Aim & Release to Fling
        </p>
    </div>
    
    <div id="playerList"></div>
    <div id="roomInfo"></div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div id="rightJoystick" class="joystick-zone"></div>
    </div>
    <div id="flingButton">âš¡</div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Global variables and constants
        const playerHeight = 10;
        const playerRadius = 2;
        const moveSpeed = 0.05;
        const gravity = 0.044;
        const flingStrength = 2.5;
        const flingDamping = 0.985;
        const clock = new THREE.Clock();

        // Game state variables
        let gameStarted = false;
        let playerUsername = '';
        let isGrounded = true;
        let isFlinging = false;
        let showLine = false;
        let lineCollisionPoint = null;
        let verticalVelocity = 0;
        let ws = null;

        // Movement state variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        // Scene-related variables
        let scene, camera, renderer, controls;

        // Collections
        const towers = [];
        const nebulas = [];
        const playerStates = new Map();
        const collectibles = new Map(); // Store collectible items
        const playerItems = new Map(); // Store items collected by each player

        // Vectors and other THREE.js objects
        const velocity = new THREE.Vector3();
        const flingVelocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Collectible item properties
        const ITEM_COUNT = 20;
        const ITEM_RADIUS = 3;
        const ITEM_HEIGHT = 2;
        const MIN_DISTANCE_BETWEEN_ITEMS = 100;
        const ITEM_COLORS = [
            0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff,
            0x00ffff, 0xff8800, 0x8800ff, 0x00ff88, 0xff0088,
            0x88ff00, 0x0088ff, 0xff8800, 0x8800ff, 0x00ff88,
            0xff0088, 0x88ff00, 0x0088ff, 0xff8800, 0x8800ff
        ];

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Add interpolation settings
        const INTERPOLATION_SPEED = 0.15;

        // Add performance optimization settings
        const PERFORMANCE_SETTINGS = {
            LOD_DISTANCES: {
                NEAR: 800,     // Reduced from 1000
                MEDIUM: 1500,  // Reduced from 2000
                FAR: 2000      // Reduced from 3000
            },
            MAX_VISIBLE_TOWERS: 50,  // Maximum number of towers to render at once
            STAR_COUNT: 15000,       // Reduced from 30000
            LARGE_STAR_COUNT: 500,   // Reduced from 1000
            GRID_DIVISIONS: 200,     // Reduced from 300
            FAR_GRID_DIVISIONS: 100, // Reduced from 150
            MID_GRID_DIVISIONS: 150  // Reduced from 225
        };

        // Add frustum culling
        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();

        // Function to check if object is in view
        function isInView(object) {
            if (!object) return false;
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);
            return frustum.containsObject(object);
        }

        // Store player states for interpolation
        class PlayerState {
            constructor(username, mesh) {
                this.username = username;
                this.mesh = mesh;
                this.targetPosition = new THREE.Vector3();
                this.targetRotation = new THREE.Vector3();
                this.currentPosition = new THREE.Vector3();
                this.currentRotation = new THREE.Vector3();
                this.lastUpdateTime = Date.now();
                this.interpolationSpeed = 0.15; // Base interpolation speed
                this.positionThreshold = 10; // Distance threshold for position snapping
            }

            update(deltaTime) {
                if (!this.mesh) return;

                const timeSinceUpdate = (Date.now() - this.lastUpdateTime) / 1000; // Convert to seconds
                
                // Adjust interpolation speed based on update frequency and distance
                const distanceToTarget = this.currentPosition.distanceTo(this.targetPosition);
                let currentSpeed = this.interpolationSpeed;
                
                // Snap to position if too far away or haven't received updates in a while
                if (distanceToTarget > this.positionThreshold || timeSinceUpdate > 1) {
                    this.currentPosition.copy(this.targetPosition);
                    this.currentRotation.copy(this.targetRotation);
                } else {
                    // Smoothly interpolate position with dynamic speed
                    currentSpeed = Math.min(deltaTime * 10, 1); // Limit maximum speed
                    
                    this.currentPosition.lerp(this.targetPosition, currentSpeed);
                    this.currentRotation.lerp(this.targetRotation, currentSpeed);
                }
                
                // Update mesh position and rotation
                this.mesh.position.copy(this.currentPosition);
                this.mesh.rotation.set(
                    this.currentRotation.x,
                    this.currentRotation.y,
                    this.currentRotation.z
                );
            }
        }

        // Function to create player model
        function createPlayerModel(username) {
            console.log('Creating player model for:', username);
            
            // Check if player model already exists
            if (playerStates.has(username)) {
                console.log('Player model already exists for:', username);
                return;
            }

            const geometry = new THREE.CapsuleGeometry(2, 6, 2, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                wireframe: true 
            });
            const playerMesh = new THREE.Mesh(geometry, material);
            
            // Add username label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '32px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(username, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 2.5, 1);
            sprite.position.y = 6;
            playerMesh.add(sprite);
            
            // Add to scene
            scene.add(playerMesh);
            
            // Create and store player state
            const playerState = new PlayerState(username, playerMesh);
            playerState.targetPosition.set(0, playerHeight, 0);
            playerState.targetRotation.set(0, 0, 0);
            playerStates.set(username, playerState);
            
            console.log('Player model created successfully for:', username);
            return playerMesh;
        }

        // Function to update player position
        function updatePlayerPosition(username, position, rotation) {
            const playerState = playerStates.get(username);
            if (playerState) {
                // Update target position
                if (position) {
                    if (Array.isArray(position)) {
                        playerState.targetPosition.fromArray(position);
                    } else {
                        playerState.targetPosition.set(position.x, position.y, position.z);
                    }
                    
                    // Initialize current position if it's the first update
                    if (playerState.currentPosition.lengthSq() === 0) {
                        playerState.currentPosition.copy(playerState.targetPosition);
                    }
                }
                
                // Update target rotation
                if (rotation) {
                    if (Array.isArray(rotation)) {
                        playerState.targetRotation.fromArray(rotation);
                    } else {
                        playerState.targetRotation.set(rotation.x, rotation.y, rotation.z);
                    }
                    
                    // Initialize current rotation if it's the first update
                    if (playerState.currentRotation.lengthSq() === 0) {
                        playerState.currentRotation.copy(playerState.targetRotation);
                    }
                }
                
                playerState.lastUpdateTime = Date.now();
            } else {
                console.warn('No player state found for username:', username);
            }
        }

        // Function to remove player
        function removePlayer(username) {
            console.log('Removing player:', username);
            const playerState = playerStates.get(username);
            if (playerState) {
                scene.remove(playerState.mesh);
                playerStates.delete(username);
                console.log('Player removed successfully:', username);
            }
        }

        // Add LOD settings
        const LOD_DISTANCES = {
            NEAR: 1000,    // High detail
            MEDIUM: 2000,  // Medium detail
            FAR: 3000      // Low detail
        };

        // Function to create LOD versions of a geometry
        function createLODGeometry(baseGeometry, type) {
            const lodLevels = [];
            
            // High detail (original)
            lodLevels.push({
                geometry: baseGeometry,
                distance: 0
            });

            // Medium detail (reduced segments)
            let mediumGeometry;
            if (type === 'cylinder') {
                mediumGeometry = new THREE.CylinderGeometry(
                    baseGeometry.parameters.radiusTop,
                    baseGeometry.parameters.radiusBottom,
                    baseGeometry.parameters.height,
                    Math.max(4, Math.floor(baseGeometry.parameters.radialSegments / 2)),
                    Math.max(1, Math.floor(baseGeometry.parameters.heightSegments / 2))
                );
            } else if (type === 'box') {
                mediumGeometry = new THREE.BoxGeometry(
                    baseGeometry.parameters.width,
                    baseGeometry.parameters.height,
                    baseGeometry.parameters.depth
                );
            }
            lodLevels.push({
                geometry: mediumGeometry,
                distance: LOD_DISTANCES.NEAR
            });

            // Low detail (minimal geometry)
            let lowGeometry;
            if (type === 'cylinder') {
                lowGeometry = new THREE.CylinderGeometry(
                    baseGeometry.parameters.radiusTop,
                    baseGeometry.parameters.radiusBottom,
                    baseGeometry.parameters.height,
                    4,
                    1
                );
            } else if (type === 'box') {
                lowGeometry = new THREE.BoxGeometry(
                    baseGeometry.parameters.width,
                    baseGeometry.parameters.height,
                    baseGeometry.parameters.depth
                );
            }
            lodLevels.push({
                geometry: lowGeometry,
                distance: LOD_DISTANCES.MEDIUM
            });

            return lodLevels;
        }

        // Modified createTowerFromData function to use LOD
        function createTowerFromData(towerData) {
            let geometry;
            const height = towerData.height;
            const isFloating = towerData.isFloating;
            const baseHeight = towerData.baseHeight;
            
            // Create materials for the tower
            const materials = [
                new THREE.MeshBasicMaterial({ color: 0x000000 }),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            ];

            // Create collision box for the tower
            let collisionGeometry;
            let geometryType;

            switch(towerData.type) {
                case 0: // Cylindrical tower
                    geometry = new THREE.CylinderGeometry(18, 18, height, 8);
                    collisionGeometry = new THREE.CylinderGeometry(18, 18, height, 8);
                    geometryType = 'cylinder';
                    break;
                case 1: // Tapered tower
                    geometry = new THREE.CylinderGeometry(12, 24, height, 6);
                    collisionGeometry = new THREE.CylinderGeometry(24, 24, height, 6);
                    geometryType = 'cylinder';
                    break;
                case 2: // Square tower
                    geometry = new THREE.BoxGeometry(36, height, 36);
                    collisionGeometry = geometry;
                    geometryType = 'box';
                    break;
                case 3: // Hexagonal tower
                    geometry = new THREE.CylinderGeometry(20, 20, height, 6);
                    collisionGeometry = geometry;
                    geometryType = 'cylinder';
                    break;
                case 4: // Twisted tower
                    geometry = new THREE.CylinderGeometry(15, 15, height, 8, 10, true);
                    // Add twist to vertices
                    const twistAmount = Math.PI * 2;
                    const positions = geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        const y = positions[i + 1];
                        const progress = (y + height/2) / height;
                        const theta = progress * twistAmount;
                        const x = positions[i];
                        const z = positions[i + 2];
                        positions[i] = x * Math.cos(theta) - z * Math.sin(theta);
                        positions[i + 2] = x * Math.sin(theta) + z * Math.cos(theta);
                    }
                    collisionGeometry = new THREE.CylinderGeometry(15, 15, height, 8);
                    geometryType = 'cylinder';
                    break;
                case 5: // Pyramid tower
                    geometry = new THREE.ConeGeometry(24, height, 4);
                    collisionGeometry = geometry;
                    geometryType = 'cylinder';
                    break;
                case 6: // Octagonal tower
                    geometry = new THREE.CylinderGeometry(19, 19, height, 8);
                    collisionGeometry = geometry;
                    geometryType = 'cylinder';
                    break;
                case 7: // Double width tower
                    geometry = new THREE.BoxGeometry(42, height, 42);
                    collisionGeometry = geometry;
                    geometryType = 'box';
                    break;
                case 8: // Inverse pyramid
                    geometry = new THREE.CylinderGeometry(12, 28, height, 4);
                    collisionGeometry = new THREE.CylinderGeometry(28, 28, height, 4);
                    geometryType = 'cylinder';
                    break;
                case 9: // Star tower
                    geometry = new THREE.CylinderGeometry(24, 24, height, 5);
                    collisionGeometry = geometry;
                    geometryType = 'cylinder';
                    break;
                case 10: // Thin spire
                    geometry = new THREE.CylinderGeometry(8, 16, height, 6);
                    collisionGeometry = new THREE.CylinderGeometry(16, 16, height, 6);
                    geometryType = 'cylinder';
                    break;
                case 11: // Complex tower (stacked shapes)
                    const baseHeight = height * 0.6;
                    const topHeight = height * 0.4;
                    geometry = new THREE.BoxGeometry(38, baseHeight, 38);
                    const topGeometry = new THREE.ConeGeometry(28, topHeight, 6);
                    collisionGeometry = new THREE.BoxGeometry(38, height, 38);
                    
                    // Create base with edges
                    const baseMesh = new THREE.Mesh(geometry, materials[0]);
                    const baseEdges = new THREE.LineSegments(
                        new THREE.EdgesGeometry(geometry),
                        materials[1]
                    );
                    
                    // Create top with edges
                    const topMesh = new THREE.Mesh(topGeometry, materials[0]);
                    const topEdges = new THREE.LineSegments(
                        new THREE.EdgesGeometry(topGeometry),
                        materials[1]
                    );
                    
                    topMesh.position.y = (baseHeight + topHeight) / 2;
                    topEdges.position.y = (baseHeight + topHeight) / 2;
                    
                    const group = new THREE.Group();
                    group.add(baseMesh);
                    group.add(baseEdges);
                    group.add(topMesh);
                    group.add(topEdges);
                    group.position.set(towerData.x, height/2 + baseHeight, towerData.z);

                    // Add collision data
                    const collisionMesh = new THREE.Mesh(collisionGeometry);
                    collisionMesh.position.copy(group.position);
                    towers.push({
                        mesh: collisionMesh,
                        boundingBox: new THREE.Box3().setFromObject(collisionMesh)
                    });

                    scene.add(group);
                    return;
            }

            // Create LOD levels
            const lodLevels = createLODGeometry(geometry, geometryType);
            
            // Create LOD group
            const lodGroup = new THREE.LOD();
            
            // Add each LOD level
            lodLevels.forEach(level => {
                const mesh = new THREE.Mesh(level.geometry, materials[0]);
                const edges = new THREE.LineSegments(
                    new THREE.EdgesGeometry(level.geometry),
                    materials[1]
                );
                const group = new THREE.Group();
                group.add(mesh);
                group.add(edges);
                lodGroup.addLevel(group, level.distance);
            });

            // Position the LOD group
            lodGroup.position.set(towerData.x, height/2 + baseHeight, towerData.z);
            scene.add(lodGroup);

            // Add collision data
            const collisionMesh = new THREE.Mesh(collisionGeometry);
            collisionMesh.position.copy(lodGroup.position);
            towers.push({
                mesh: collisionMesh,
                boundingBox: new THREE.Box3().setFromObject(collisionMesh),
                lodGroup: lodGroup
            });
        }

        // Modified createBridgeFromData function to use LOD
        function createBridgeFromData(bridgeData) {
            const bridgeWidth = 8;
            const startPos = new THREE.Vector3(bridgeData.startX, bridgeData.height, bridgeData.startZ);
            const endPos = new THREE.Vector3(bridgeData.endX, bridgeData.height, bridgeData.endZ);
            const distance = startPos.distanceTo(endPos);
            
            // Create base bridge geometry
            const bridgeGeometry = new THREE.BoxGeometry(distance, bridgeWidth, bridgeWidth);
            
            // Create materials
            const bridgeMaterials = [
                new THREE.MeshBasicMaterial({ color: 0x000000 }),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            ];
            
            // Create LOD levels
            const lodLevels = createLODGeometry(bridgeGeometry, 'box');
            
            // Create LOD group
            const lodGroup = new THREE.LOD();
            
            // Add each LOD level
            lodLevels.forEach(level => {
                const mesh = new THREE.Mesh(level.geometry, bridgeMaterials[0]);
                const edges = new THREE.LineSegments(
                    new THREE.EdgesGeometry(level.geometry),
                    bridgeMaterials[1]
                );
                const group = new THREE.Group();
                group.add(mesh);
                group.add(edges);
                lodGroup.addLevel(group, level.distance);
            });
            
            // Position bridge
            const midPoint = startPos.clone().add(endPos).multiplyScalar(0.5);
            lodGroup.position.copy(midPoint);
            
            // Rotate bridge
            const direction = endPos.clone().sub(startPos);
            const angle = Math.atan2(direction.z, direction.x);
            lodGroup.rotation.y = angle;
            
            scene.add(lodGroup);
            
            // Create collision box
            const collisionGeometry = new THREE.BoxGeometry(distance, bridgeWidth * 0.8, bridgeWidth * 0.6);
            const collisionMesh = new THREE.Mesh(collisionGeometry);
            collisionMesh.position.copy(lodGroup.position);
            collisionMesh.rotation.copy(lodGroup.rotation);
            towers.push({
                mesh: collisionMesh,
                boundingBox: new THREE.Box3().setFromObject(collisionMesh),
                lodGroup: lodGroup
            });
        }

        // WebSocket setup with Railway support
        const getWebSocketUrl = () => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            if (window.location.hostname.includes('.railway.app')) {
                return `${protocol}//${window.location.host}`;
            }
            return 'ws://localhost:3000';
        };

        let wsReconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        function setupWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}`;
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('Connected to server');
                // Send join message with username
                ws.send(JSON.stringify({
                    type: 'join',
                    username: playerUsername
                }));
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('Received message:', data.type);
                
                switch (data.type) {
                    case 'world_data':
                        console.log('Received world data');
                        // Clear existing towers and collectibles
                        towers.forEach(tower => {
                            scene.remove(tower.mesh);
                        });
                        towers.length = 0;
                        
                        collectibles.forEach(item => {
                            scene.remove(item.mesh);
                        });
                        collectibles.clear();
                        
                        // Create towers from server data
                        data.towers.forEach(towerData => {
                            createTowerFromData(towerData);
                        });
                        
                        // Create bridges from server data
                        data.bridges.forEach(bridgeData => {
                            createBridgeFromData(bridgeData);
                        });

                        // Initialize collectibles
                        initializeCollectibles();
                        break;

                    case 'room_info':
                        console.log(`Joined room ${data.name} with ${data.playerCount} players`);
                        document.getElementById('roomInfo').textContent = `${data.name} - Players: ${data.playerCount}/20`;
                        break;

                    case 'player_joined':
                        console.log('Player joined:', data.username);
                        handlePlayerJoined(data.username);
                        break;

                    case 'position':
                        if (data.username !== playerUsername && gameStarted) {
                            updatePlayerPosition(data.username, data.position, data.rotation);
                        }
                        break;

                    case 'player_left':
                        console.log('Player left:', data.username);
                        handlePlayerDisconnection(data.username);
                        handlePlayerLeft(data.username);
                        break;

                    case 'item_collected':
                        handleItemCollection(data.itemId, data.username);
                        break;
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onclose = () => {
                console.log('Disconnected from server');
                // Attempt to reconnect after a delay
                setTimeout(setupWebSocket, 3000);
            };
        }

        // Function to update player list
        function updatePlayerList() {
            const playerList = document.getElementById('playerList');
            playerList.innerHTML = '<div style="margin-bottom: 10px; font-weight: bold;">Players:</div>';
            
            // Add current player first
            const currentPlayerItem = document.createElement('div');
            currentPlayerItem.className = 'playerListItem';
            const currentItems = playerItems.get(playerUsername) || new Set();
            currentPlayerItem.textContent = `${playerUsername} (You) - Items: ${currentItems.size}/${ITEM_COUNT}`;
            playerList.appendChild(currentPlayerItem);
            
            // Add other players
            playerStates.forEach((playerState, username) => {
                if (username !== playerUsername) {
                    const playerItem = document.createElement('div');
                    playerItem.className = 'playerListItem';
                    const items = playerItems.get(username) || new Set();
                    playerItem.textContent = `${username} - Items: ${items.size}/${ITEM_COUNT}`;
                    playerList.appendChild(playerItem);
                }
            });
        }

        // Update player list when players join/leave
        function handlePlayerJoined(username) {
            if (username !== playerUsername && gameStarted) {
                createPlayerModel(username);
                updatePlayerPosition(username, data.position, data.rotation);
                updatePlayerList();
            }
        }

        function handlePlayerLeft(username) {
            removePlayer(username);
            updatePlayerList();
        }

        // Add orb counter UI
        const orbCounter = document.createElement('div');
        orbCounter.style.position = 'fixed';
        orbCounter.style.top = '10px';
        orbCounter.style.left = '50%';
        orbCounter.style.transform = 'translateX(-50%)';
        orbCounter.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        orbCounter.style.color = '#4CAF50';
        orbCounter.style.padding = '10px';
        orbCounter.style.borderRadius = '5px';
        orbCounter.style.zIndex = '1000';
        orbCounter.style.fontFamily = 'Arial, sans-serif';
        orbCounter.style.fontSize = '16px';
        orbCounter.style.fontWeight = 'bold';
        orbCounter.style.textShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
        document.body.appendChild(orbCounter);

        // Function to update orb counter
        function updateOrbCounter() {
            const totalOrbs = ITEM_COUNT;
            const collectedOrbs = playerItems.get(playerUsername)?.size || 0;
            const remainingOrbs = totalOrbs - Array.from(playerItems.values()).reduce((sum, items) => sum + items.size, 0);
            orbCounter.textContent = `Your Orbs: ${collectedOrbs} | Remaining: ${remainingOrbs}`;
        }

        // Function to find valid tower position for item
        function findValidTowerPosition() {
            console.log('Finding valid tower position...');
            const validTowers = towers.filter(tower => {
                // Check if tower is tall enough
                const towerHeight = tower.mesh.geometry.parameters.height;
                return towerHeight > 20; // Minimum tower height for item placement
            });
            console.log(`Found ${validTowers.length} valid towers (height > 20)`);

            if (validTowers.length === 0) {
                console.warn('No valid towers found for item placement');
                return null;
            }

            // Try each tower until we find a valid position
            for (const tower of validTowers) {
                const towerHeight = tower.mesh.geometry.parameters.height;
                const towerPosition = tower.mesh.position;
                console.log(`Trying tower at position (${towerPosition.x}, ${towerPosition.y}, ${towerPosition.z}) with height ${towerHeight}`);
                
                // Try different heights on the tower
                for (let height = 10; height < towerHeight - 10; height += 20) {
                    const position = new THREE.Vector3(
                        towerPosition.x,
                        towerPosition.y + height,
                        towerPosition.z
                    );

                    // Check if position is valid (not too close to other items)
                    let isValid = true;
                    for (const item of collectibles.values()) {
                        const distance = position.distanceTo(item.position);
                        if (distance < MIN_DISTANCE_BETWEEN_ITEMS) {
                            console.log(`Position too close to existing item (distance: ${distance})`);
                            isValid = false;
                            break;
                        }
                    }

                    if (isValid) {
                        console.log(`Found valid position at (${position.x}, ${position.y}, ${position.z})`);
                        return position;
                    }
                }
            }

            console.warn('No valid positions found for item placement');
            return null;
        }

        // Function to create collectible item
        function createCollectible(id, position, color) {
            console.log(`Creating collectible ${id} at position (${position.x}, ${position.y}, ${position.z}) with color ${color}`);
            const geometry = new THREE.SphereGeometry(ITEM_RADIUS, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.userData.id = id;
            
            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(ITEM_RADIUS * 1.2, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3
            });
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            mesh.add(glowMesh);
            
            // Add floating animation
            mesh.userData.originalY = position.y;
            mesh.userData.floatOffset = Math.random() * Math.PI * 2;
            
            scene.add(mesh);
            collectibles.set(id, {
                mesh: mesh,
                position: position.clone(),
                color: color
            });
            console.log(`Collectible ${id} created successfully`);
        }

        // Function to initialize collectibles
        function initializeCollectibles() {
            console.log('Initializing collectibles...');
            console.log(`Total towers: ${towers.length}`);
            let attempts = 0;
            const maxAttempts = 100;
            let successfulPlacements = 0;
            
            for (let i = 0; i < ITEM_COUNT; i++) {
                let position;
                do {
                    position = findValidTowerPosition();
                    attempts++;
                } while (!position && attempts < maxAttempts);
                
                if (position) {
                    createCollectible(i, position, ITEM_COLORS[i]);
                    successfulPlacements++;
                    console.log(`Successfully placed collectible ${i} (${successfulPlacements}/${ITEM_COUNT})`);
                } else {
                    console.warn(`Failed to find valid position for collectible ${i} after ${maxAttempts} attempts`);
                }
            }
            
            console.log(`Initialized ${successfulPlacements} collectibles out of ${ITEM_COUNT} total`);
            updateOrbCounter();
        }

        // Function to handle item collection
        function handleItemCollection(itemId, playerUsername) {
            const item = collectibles.get(itemId);
            if (item) {
                // Check if item is already collected
                for (const [username, items] of playerItems.entries()) {
                    if (items.has(itemId)) {
                        console.log(`Item ${itemId} already collected by ${username}`);
                        return;
                    }
                }

                scene.remove(item.mesh);
                collectibles.delete(itemId);
                
                // Update player's collected items
                if (!playerItems.has(playerUsername)) {
                    playerItems.set(playerUsername, new Set());
                }
                playerItems.get(playerUsername).add(itemId);
                
                // Update UI
                updatePlayerList();
                updateOrbCounter();
                
                // Play collection sound
                const audio = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU');
                audio.play().catch(() => {}); // Ignore errors if audio can't play
            }
        }

        // Function to handle player disconnection
        function handlePlayerDisconnection(username) {
            const items = playerItems.get(username);
            if (items) {
                // Drop all items at player's last position
                const playerState = playerStates.get(username);
                if (playerState) {
                    items.forEach(itemId => {
                        const color = ITEM_COLORS[itemId];
                        createCollectible(itemId, playerState.mesh.position.clone(), color);
                    });
                }
                playerItems.delete(username);
            }
        }

        // Scene setup with error handling
        try {
            // Scene initialization
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            console.log('Scene created');

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 12000);
            camera.position.set(0, playerHeight, 0);
            scene.add(camera);
            console.log('Camera initialized at height:', playerHeight);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                powerPreference: "high-performance",
                alpha: false,
                precision: "mediump"
            });
            
            if (!renderer.capabilities.isWebGL2) {
                throw new Error('WebGL 2 not supported');
            }
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 1);
            document.body.appendChild(renderer.domElement);
            console.log('Renderer initialized');

            // Controls setup
            controls = new PointerLockControls(camera, document.body);
            console.log('Controls initialized');

            // Add ambient light immediately
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add directional light immediately
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Create and add grid immediately
            const size = 6000;
            const gridHelper = new THREE.GridHelper(size, PERFORMANCE_SETTINGS.GRID_DIVISIONS);
            gridHelper.material.opacity = 0.75;
            gridHelper.material.transparent = true;
            gridHelper.material.depthWrite = false;
            scene.add(gridHelper);

            // Create and add star field immediately
            const [starField, largeStarField] = createStars();
            scene.add(starField);
            scene.add(largeStarField);

            // Create and add nebulas immediately
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = 4500;
                const position = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.random() * 2400 - 600,
                    Math.sin(angle) * radius
                );
                const scale = 4 + Math.random() * 6;
                const rotation = new THREE.Euler(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                nebulas.push(createNebula(position, scale, rotation));
            }

            // Create line trace
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, 1)
            ]);
            const tubeGeometry = new THREE.TubeGeometry(curve, 1, 0.15, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(tubeMesh);

            // Initial render
            renderer.render(scene, camera);
            console.log('Initial render completed');

            // Animation loop with error handling
            function animate() {
                try {
                    requestAnimationFrame(animate);
                    
                    // Always render the scene
                    renderer.render(scene, camera);
                    
                    const deltaTime = clock.getDelta();
                    
                    if (gameStarted) {
                        // Rest of the animation code...
                    }
                } catch (error) {
                    console.error('Error during animation:', error);
                }
            }
            animate();

            // Send position updates
            function sendPositionUpdate() {
                if (ws.readyState === WebSocket.OPEN && gameStarted) {
                    ws.send(JSON.stringify({
                        type: 'position',
                        position: camera.position.toArray(),
                        rotation: camera.rotation.toArray()
                    }));
                }
            }

            // Update position periodically
            setInterval(sendPositionUpdate, 50); // 20 updates per second
        } catch (error) {
            console.error('Error during initialization:', error);
            document.body.innerHTML = `
                <div style="color: white; background: rgba(0,0,0,0.8); padding: 20px; text-align: center;">
                    An error occurred while initializing the game.<br>
                    Please try refreshing the page or use a different browser.
                </div>
            `;
            throw error;
        }

        // Initialize WebSocket connection AFTER scene is set up
        setupWebSocket();
    </script>
</body>
</html>
