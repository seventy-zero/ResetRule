<!DOCTYPE html>
<html lang="en">
<head>
    <title>ResetRule</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/virtual-joystick/1.10.0/virtual-joystick.min.js"></script>
    <style>
        body { 
            margin: 0; 
            background-color: #000000;
        }
        canvas { 
            display: block; 
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            z-index: 1000;
        }
        #instructions.hidden {
            display: none;
        }
        #username {
            margin: 10px 0;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-size: 16px;
            width: 200px;
            text-align: center;
        }
        #startButton {
            margin-top: 15px;
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #45a049;
        }
        #startButton:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            height: 120px;
            width: 120px;
            pointer-events: auto;
            z-index: 1000;
            touch-action: none;
        }
        .joystick-zone {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 60px;
            pointer-events: auto;
            z-index: 1000;
            touch-action: none;
        }
        .joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out;
            touch-action: none;
        }
        /* Add left joystick for movement */
        .mobile-controls.left {
            left: 20px;
            right: auto;
        }
        #flingButton {
            display: none;
            position: fixed;
            bottom: 160px;
            left: 40px;
            width: 80px;
            height: 80px;
            background: rgba(76, 175, 80, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 32px;
            line-height: 80px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            z-index: 1000;
            touch-action: none;
            transition: all 0.1s ease-out;
            user-select: none;
        }
        #flingButton.active {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(0.95);
        }
        /* Show mobile controls on touch devices */
        @media (pointer: coarse) {
            .mobile-controls {
                display: block !important;
            }
            #flingButton {
                display: block !important;
            }
        }
        #roomInfo {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;  /* Increased horizontal padding */
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
            min-width: 120px;  /* Added minimum width */
            text-align: center;  /* Center the text */
        }

        #playerList {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            display: none;
            min-width: 150px;
            max-height: 300px;
            overflow-y: auto;
        }

        #playerList.visible {
            display: block;
        }

        .playerListItem {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .playerListItem:hover {
            background-color: rgba(76, 175, 80, 0.2);
        }

        .popupButton {
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.1s;
            animation: none;
        }

        .popupButton:hover {
            animation: shake 0.5s infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>Welcome to ResetRule</h2>
        <input type="text" id="username" placeholder="Enter your username" maxlength="15">
        <button id="startButton" disabled>Start Game</button>
        <p style="margin-top: 20px;">
            Desktop Controls:<br>
            WASD = Move<br>
            Mouse = Look around<br>
            ESC = Exit<br>
            Left Click = Aim & Release to Fling
        </p>
        <p id="mobileInstructions" style="display: none; margin-top: 20px;">
            Mobile Controls:<br>
            Right Stick = Look around<br>
            Fling Button = Aim & Release to Fling
        </p>
    </div>
    
    <div id="playerList"></div>
    <div id="orbCount" style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: #4CAF50; padding: 10px; border-radius: 5px; z-index: 1000; font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);">
        Orbs: 0
    </div>
    <div id="roomInfo"></div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div id="rightJoystick" class="joystick-zone"></div>
    </div>
    <div id="flingButton">âš¡</div>

    <!-- Add after the roomInfo div -->
    <div id="orbPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 10px; z-index: 2000; text-align: center; border: 2px solid #4CAF50;">
        <h2 style="color: #4CAF50; margin-bottom: 20px;">You've collected 30 orbs!</h2>
        <div style="display: flex; gap: 20px; justify-content: center;">
            <button id="resetButton" class="popupButton" style="background-color: #ff4444;">Reset (C)</button>
            <button id="ruleButton" class="popupButton" style="background-color: #4CAF50;">Rule (V)</button>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Global variables and constants
        const playerHeight = 10;
        const playerRadius = 2;
        const moveSpeed = 0.05;
        const gravity = 0.008; // Reduced from 0.015 for longer air time
        const flingStrength = 2.75;
        const flingDamping = 0.985;
        const clock = new THREE.Clock();
        const lastSentPosition = new THREE.Vector3(); // Initialize last sent position
        const lastSentRotation = new THREE.Vector3(); // Initialize last sent rotation
        let ws = null; // Initialize WebSocket variable
        let wsConnectionAttempted = false; // Track if we've attempted to connect
        let worldDataRequested = false; // Track if we've requested world data

        // Initialize WebSocket connection immediately
        if (!wsConnectionAttempted) {
            setupWebSocket();
            wsConnectionAttempted = true;
        }

        // Add object pooling system
        const objectPool = {
            vectors: [],
            spheres: [],
            boxes: [],
            getVector: function() {
                return this.vectors.pop() || new THREE.Vector3();
            },
            releaseVector: function(vector) {
                vector.set(0, 0, 0);
                this.vectors.push(vector);
            },
            getSphere: function() {
                return this.spheres.pop() || new THREE.Sphere();
            },
            releaseSphere: function(sphere) {
                sphere.center.set(0, 0, 0);
                sphere.radius = 0;
                this.spheres.push(sphere);
            },
            getBox: function() {
                return this.boxes.pop() || new THREE.Box3();
            },
            releaseBox: function(box) {
                box.makeEmpty();
                this.boxes.push(box);
            }
        };

        // Add movement smoothing constants
        const MOVEMENT_SMOOTHING = 0.85; // Reduced from 0.85 for smoother movement
        const COLLISION_PUSH_FORCE = 3.5; // Increased from 2.5 for stronger collision response
        const CORNER_SLIDE_FORCE = 0.8; // Increased from 0.7 for better sliding
        const MIN_VELOCITY_THRESHOLD = 0.001; // Threshold for stopping movement
        const STUCK_THRESHOLD = 0.3; // New constant for detecting when player is stuck
        const STUCK_PUSH_FORCE = 5.0; // New constant for extra push force when stuck

        // Game state variables
        let gameStarted = false;
        let playerUsername = '';
        let isGrounded = true;
        let isFlinging = false;
        let showLine = false;
        let lineCollisionPoint = null;
        let verticalVelocity = 0;

        // Movement state variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        // Scene-related variables
        let scene, camera, renderer, controls;

        // Collections
        const towers = [];
        const nebulas = [];
        const playerStates = new Map();
        const orbs = new Map(); // Add orbs collection
        const playerOrbs = new Map(); // Track orbs collected by each player
        const collisionBoxes = []; // Add collision boxes collection

        // Vectors and other THREE.js objects
        const velocity = new THREE.Vector3();
        const flingVelocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Add interpolation settings
        const INTERPOLATION_SPEED = 0.15;

        // Store player states for interpolation
        class PlayerState {
            constructor(username, mesh) {
                this.username = username;
                this.mesh = mesh;
                this.position = new THREE.Vector3();
                this.rotation = new THREE.Euler();
                this.speed = 0;
                this.heading = 0;
                this.verticalSpeed = 0;
                this.lastUpdateTime = Date.now();
                this.isVisible = true;
            }

            update(deltaTime) {
                if (!this.mesh) {
                    console.warn(`No mesh found for player ${this.username}`);
                    return;
                }

                const currentTime = Date.now();
                const timeSinceUpdate = currentTime - this.lastUpdateTime;
                
                // Make sure mesh is visible
                this.mesh.visible = true;

                // Calculate movement based on speed and heading
                const headingRad = (this.heading * Math.PI) / 180;
                const distanceMoved = this.speed * deltaTime;

                // Calculate target positions
                const targetX = this.position.x - Math.sin(headingRad) * distanceMoved;
                const targetZ = this.position.z - Math.cos(headingRad) * distanceMoved;
                const targetY = this.position.y + this.verticalSpeed * deltaTime;

                // Use exponential smoothing for interpolation
                const lerpFactor = 1 - Math.exp(-10 * deltaTime);

                // Smoothly interpolate position
                this.mesh.position.x += (targetX - this.mesh.position.x) * lerpFactor;
                this.mesh.position.z += (targetZ - this.mesh.position.z) * lerpFactor;
                this.mesh.position.y += (targetY - this.mesh.position.y) * lerpFactor;

                // Update rotation
                this.mesh.rotation.y = -headingRad;
            }
        }

        // Function to create player model
        function createPlayerModel(username) {
            console.log('Creating player model for:', username);
            
            // Check if player model already exists
            if (playerStates.has(username)) {
                console.log('Player model already exists for:', username);
                return;
            }

            const geometry = new THREE.CapsuleGeometry(2, 6, 2, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                wireframe: true 
            });
            const playerMesh = new THREE.Mesh(geometry, material);
            
            // Add username label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '32px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(username, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 2.5, 1);
            sprite.position.y = 6;
            playerMesh.add(sprite);
            
            // Add to scene
            scene.add(playerMesh);
            console.log('Added player mesh to scene:', {
                username: username,
                mesh: playerMesh,
                position: playerMesh.position,
                visible: playerMesh.visible
            });
            
            // Create and store player state
            const playerState = new PlayerState(username, playerMesh);
            playerState.position.set(0, playerHeight, 0);
            playerState.rotation.set(0, 0, 0);
            playerStates.set(username, playerState);
            
            console.log('Player model created successfully for:', username);
            return playerMesh;
        }

        // Function to update player position
        function updatePlayerPosition(username, position, rotation) {
            const playerState = playerStates.get(username);
            if (playerState) {
                // Update position
                if (position) {
                    if (Array.isArray(position)) {
                        playerState.position.fromArray(position);
                    } else {
                        playerState.position.set(position.x, position.y, position.z);
                    }
                }
                
                // Update rotation
                if (rotation) {
                    if (Array.isArray(rotation)) {
                        playerState.rotation.fromArray(rotation);
                    } else {
                        playerState.rotation.set(rotation.x, rotation.y, rotation.z);
                    }
                }
                
                // Calculate speed and heading from position changes
                if (playerState.lastPosition) {
                    const dx = playerState.position.x - playerState.lastPosition.x;
                    const dz = playerState.position.z - playerState.lastPosition.z;
                    playerState.speed = Math.sqrt(dx * dx + dz * dz) / (0.016); // Assuming 60fps
                    playerState.heading = Math.atan2(-dx, -dz) * 180 / Math.PI;
                    playerState.verticalSpeed = (playerState.position.y - playerState.lastPosition.y) / 0.016;
                }
                
                playerState.lastPosition = playerState.position.clone();
                playerState.lastUpdateTime = Date.now();
            } else {
                console.warn('No player state found for username:', username);
            }
        }

        // Function to remove player
        function removePlayer(username) {
            console.log('Removing player:', username);
            const playerState = playerStates.get(username);
            if (playerState) {
                scene.remove(playerState.mesh);
                playerStates.delete(username);
                console.log('Player removed successfully:', username);
            }
        }

        // Add after the global variables section
        const geometryCache = new Map();
        const materialCache = new Map();
        const COLLISION_CHECK_INTERVAL = 100; // ms
        let lastCollisionCheck = 0;

        // Add frustum culling variables
        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();

        // Add clearTowers function
        function clearTowers() {
            towers.forEach(tower => {
                if (tower.mesh) {
                    tower.mesh.traverse(child => {
                        if (child.geometry) {
                            child.geometry.dispose();
                        }
                    });
                    scene.remove(tower.mesh);
                }
            });
            towers.length = 0;
        }

        const spatialGrid = {
            cellSize: 100,
            cells: new Map(),
            getKey: function(x, z) {
                return `${Math.floor(x / this.cellSize)},${Math.floor(z / this.cellSize)}`;
            },
            add: function(object) {
                const key = this.getKey(object.position.x, object.position.z);
                if (!this.cells.has(key)) {
                    this.cells.set(key, new Set());
                }
                this.cells.get(key).add(object);
            },
            remove: function(object) {
                const key = this.getKey(object.position.x, object.position.z);
                if (this.cells.has(key)) {
                    this.cells.get(key).delete(object);
                }
            },
            getNearbyObjects: function(position, radius) {
                const nearbyObjects = new Set();
                const minX = Math.floor((position.x - radius) / this.cellSize);
                const maxX = Math.floor((position.x + radius) / this.cellSize);
                const minZ = Math.floor((position.z - radius) / this.cellSize);
                const maxZ = Math.floor((position.z + radius) / this.cellSize);
                
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = `${x},${z}`;
                        if (this.cells.has(key)) {
                            this.cells.get(key).forEach(obj => nearbyObjects.add(obj));
                        }
                    }
                }
                return nearbyObjects;
            }
        };

        // Add after the createTowerFromData function
        function getGeometryFromCache(type, params) {
            const key = `${type}-${JSON.stringify(params)}`;
            if (!geometryCache.has(key)) {
                let geometry;
                switch(type) {
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(params.radius, params.radius, params.height, Math.min(params.segments, 8)); // Limit segments
                        break;
                    case 'box':
                        geometry = new THREE.BoxGeometry(params.width, params.height, params.depth);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(params.radius, params.height, Math.min(params.segments, 6)); // Limit segments
                        break;
                }
                geometryCache.set(key, geometry);
            }
            return geometryCache.get(key);
        }

        function getMaterialFromCache(type, params) {
            const key = `${type}-${JSON.stringify(params)}`;
            if (!materialCache.has(key)) {
                let material;
                switch(type) {
                    case 'basic':
                        material = new THREE.MeshBasicMaterial(params);
                        break;
                    case 'line':
                        material = new THREE.LineBasicMaterial(params);
                        break;
                    // Add more cases as needed
                }
                materialCache.set(key, material);
            }
            return materialCache.get(key);
        }

        // Add after the material cache
        const sharedMaterials = {
            tower: new THREE.MeshBasicMaterial({ color: 0x000000 }),
            towerEdges: new THREE.LineBasicMaterial({ color: 0xffffff })
        };

        // Modify createTowerFromData to use shared materials
        function createTowerFromData(towerData) {
            const height = towerData.height;
            const baseHeight = towerData.baseHeight;
            
            let geometry;
            let towerHeight = height;
            
            switch(towerData.type) {
                case 0: // Cylindrical tower
                    geometry = getGeometryFromCache('cylinder', { radius: 18, height, segments: 8 });
                    break;
                case 1: // Tapered tower
                    geometry = getGeometryFromCache('cylinder', { radius: 12, height, segments: 6 });
                    break;
                case 2: // Square tower
                    geometry = getGeometryFromCache('box', { width: 36, height, depth: 36 });
                    break;
                case 3: // Hexagonal tower
                    geometry = getGeometryFromCache('cylinder', { radius: 20, height, segments: 6 });
                    break;
                case 4: // Twisted tower
                    geometry = getGeometryFromCache('cylinder', { radius: 15, height, segments: 8 });
                    break;
                case 5: // Pyramid tower
                    geometry = getGeometryFromCache('cone', { radius: 24, height, segments: 4 });
                    break;
                case 6: // Octagonal tower
                    geometry = getGeometryFromCache('cylinder', { radius: 19, height, segments: 8 });
                    break;
                case 7: // Double width tower
                    geometry = getGeometryFromCache('box', { width: 42, height, depth: 42 });
                    break;
                case 8: // Inverse pyramid
                    geometry = getGeometryFromCache('cylinder', { radius: 12, height, segments: 4 });
                    break;
                case 9: // Star tower
                    geometry = getGeometryFromCache('cylinder', { radius: 24, height, segments: 5 });
                    break;
                case 10: // Thin spire
                    geometry = getGeometryFromCache('cylinder', { radius: 8, height, segments: 6 });
                    break;
            }

            // Create the main mesh with solid faces using shared material
            const mesh = new THREE.Mesh(geometry, sharedMaterials.tower);
            
            // Create the edges using shared material
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                sharedMaterials.towerEdges
            );
            
            // Group the mesh and edges together
            const group = new THREE.Group();
            group.add(mesh);
            group.add(edges);
            group.position.set(towerData.x, height/2 + baseHeight, towerData.z);
            scene.add(group);

            // Create a single box collider for the tower
            const collisionBox = new THREE.Box3();
            const collisionMesh = new THREE.Mesh(
                getGeometryFromCache('box', { width: 36, height, depth: 36 })
            );
            collisionMesh.position.copy(group.position);
            collisionBox.setFromObject(collisionMesh);
            
            towers.push({
                mesh: group,
                collisionBoxes: [collisionBox]
            });
        }

        // Function to create bridge from server data
        function createBridgeFromData(bridgeData) {
            // Calculate bridge dimensions
            const bridgeWidth = 16;
            const startPos = new THREE.Vector3(
                bridgeData.startX || bridgeData.start.x,
                bridgeData.height,
                bridgeData.startZ || bridgeData.start.z
            );
            const endPos = new THREE.Vector3(
                bridgeData.endX || bridgeData.end.x,
                bridgeData.height,
                bridgeData.endZ || bridgeData.end.z
            );
            const distance = startPos.distanceTo(endPos);
            const angle = Math.atan2(endPos.x - startPos.x, endPos.z - startPos.z);
            const midPoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
            const bridgeLength = distance;

            // Create bridge group
            const bridgeGroup = new THREE.Group();

            // Create bridge geometry
            const bridgeGeometry = new THREE.BoxGeometry(distance, bridgeWidth, bridgeWidth);
            
            // Create materials for the bridge (matching tower style)
            const bridgeMaterials = [
                new THREE.MeshBasicMaterial({ color: 0x000000 }),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            ];
            
            // Create bridge mesh and edges
            const bridgeMesh = new THREE.Mesh(bridgeGeometry, bridgeMaterials[0]);
            bridgeMesh.name = 'bridge'; // Add name to identify bridges
            const bridgeEdges = new THREE.LineSegments(
                new THREE.EdgesGeometry(bridgeGeometry),
                bridgeMaterials[1]
            );

            // Position bridge
            bridgeGroup.add(bridgeMesh);
            bridgeGroup.add(bridgeEdges);
            bridgeGroup.position.copy(midPoint);
            bridgeGroup.rotation.y = angle;

            scene.add(bridgeGroup);
            
            // Create collision box that exactly matches the bridge mesh
            const collisionBox = new THREE.Box3();
            const collisionMesh = new THREE.Mesh(bridgeGeometry);
            collisionMesh.position.copy(bridgeGroup.position);
            collisionMesh.rotation.copy(bridgeGroup.rotation);
            collisionMesh.scale.set(1, 1, 1); // Ensure proper scaling
            collisionBox.setFromObject(collisionMesh);

            // Adjust collision box size to match bridge dimensions
            const size = new THREE.Vector3();
            collisionBox.getSize(size);
            const bridgeCollisionWidth = 16; // Match the bridge width constant
            const adjustedSize = new THREE.Vector3(
                size.x,
                bridgeCollisionWidth,
                bridgeCollisionWidth
            );
            collisionBox.setFromCenterAndSize(
                collisionBox.getCenter(new THREE.Vector3()),
                adjustedSize
            );

            // Add bridge to towers array for consistent handling
            const bridgeObject = {
                mesh: bridgeGroup,
                collisionBoxes: [collisionBox],
                isBridge: true // Add flag to identify bridges
            };
            towers.push(bridgeObject);
            
            // Verify collision box was added
            console.log('Bridge added to collision system:', {
                totalObjects: towers.length,
                hasCollisionBox: bridgeObject.collisionBoxes.length > 0,
                collisionBoxSize: collisionBox.getSize(new THREE.Vector3())
            });

            return bridgeGroup;
        }

        // Update collision check function to handle bridges like towers
        function checkCollision(position, radius) {
            const playerCollider = new THREE.Sphere(position, radius);
            let closestCollision = null;
            let minDistance = Infinity;

            for (const tower of towers) {
                for (const collisionBox of tower.collisionBoxes) {
                    // Get the closest point on the collision box to the player
                    const closestPoint = new THREE.Vector3();
                    collisionBox.clampPoint(position, closestPoint);
                    
                    // Calculate distance to closest point
                    const distance = position.distanceTo(closestPoint);
                    
                    // Check if this is a bridge
                    const isBridge = tower.isBridge || tower.mesh.name === 'bridge';
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCollision = {
                            collision: true,
                            tower: tower,
                            collisionBox: collisionBox,
                            distance: distance,
                            closestPoint: closestPoint,
                            isBridge: isBridge
                        };
                    }
                }
            }
            
            // Only return collision if we're actually within the collision radius
            if (closestCollision && closestCollision.distance < radius) {
                return closestCollision;
            }
            
            return {
                collision: false,
                tower: null,
                collisionBox: null,
                distance: Infinity,
                closestPoint: null,
                isBridge: false
            };
        }

        // Add after the checkCollision function
        function checkOrbCollision(position, radius) {
            const playerCollider = new THREE.Sphere(position, radius * 10); // Increased from 5x to 10x
            let closestOrb = null;
            let minDistance = Infinity;
            
            orbs.forEach((orb, orbId) => {
                const orbPosition = orb.position;
                const distance = position.distanceTo(orbPosition);
                
                if (distance < (radius * 10) + orb.userData.originalScale) { // Increased from 5x to 10x
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestOrb = { orb, orbId };
                    }
                }
            });
            
            return closestOrb;
        }

        // WebSocket setup with Railway support
        const getWebSocketUrl = () => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            if (window.location.hostname.includes('.railway.app')) {
                return `${protocol}//${window.location.host}`;
            }
            return 'ws://localhost:3000';
        };

        let wsReconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        function setupWebSocket() {
            // Don't set up if we already have a connection
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('WebSocket already connected');
                return;
            }

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}`;
            console.log('Attempting to connect to WebSocket at:', wsUrl);
            ws = new WebSocket(wsUrl);

            ws.addEventListener('open', () => {
                console.log('WebSocket connection established');
                // Request world data if we haven't already
                if (!worldDataRequested) {
                    console.log('Requesting world data...');
                    ws.send(JSON.stringify({
                        type: 'request_world_data'
                    }));
                    worldDataRequested = true;
                }
                // Only send join message if we have a username
                if (playerUsername) {
                    const joinMessage = {
                        type: 'join',
                        username: playerUsername
                    };
                    console.log('Sending join message:', joinMessage);
                    ws.send(JSON.stringify(joinMessage));
                }
            });

            ws.addEventListener('message', (event) => {
                const data = JSON.parse(event.data);
                console.log('Received WebSocket message:', {
                    type: data.type,
                    username: data.username,
                    position: data.position,
                    rotation: data.rotation,
                    timestamp: new Date().toISOString()
                });
                
                switch (data.type) {
                    case 'world_data':
                        console.log('Received world data with players:', data.players);
                        // Clear existing player states except current player
                        const currentPlayerState = playerStates.get(playerUsername);
                        playerStates.clear();
                        if (currentPlayerState) {
                            playerStates.set(playerUsername, currentPlayerState);
                        }
                        
                        // Clear existing towers and bridges using the new function
                        clearTowers();
                        
                        // Create towers from server data first
                        if (data.towers) {
                            console.log('Creating towers:', data.towers.length);
                            data.towers.forEach(towerData => {
                                createTowerFromData(towerData);
                            });
                        }
                        
                        // Create bridges from server data
                        if (data.bridges) {
                            data.bridges.forEach(bridgeData => {
                                createBridgeFromData(bridgeData);
                            });
                        }

                        // Debug logging for orbs
                        console.log('Processing orbs data:', data.orbs);
                        
                        // Clear existing orbs
                        orbs.forEach(orb => {
                            console.log('Removing existing orb:', orb);
                            scene.remove(orb);
                        });
                        orbs.clear();
                        
                        // Create new orbs
                        if (data.orbs && data.orbs.length > 0) {
                            console.log('Creating orbs:', data.orbs.length);
                            data.orbs.forEach((orbData, index) => {
                                console.log(`Creating orb ${index}:`, orbData);
                                try {
                                    const orb = createOrb(orbData);
                                    console.log(`Successfully created orb ${index}:`, orb);
                                    // Ensure orb is added to scene
                                    if (!scene.children.includes(orb)) {
                                        scene.add(orb);
                                    }
                                } catch (error) {
                                    console.error(`Error creating orb ${index}:`, error);
                                }
                            });
                        } else {
                            console.warn('No orbs data received from server');
                        }
                        break;

                    case 'room_info':
                        console.log(`Joined room ${data.name} with ${data.playerCount} players`);
                        // Only update room info if we have a valid player count
                        if (data.playerCount > 0) {
                            document.getElementById('roomInfo').textContent = `${data.name} - Players: ${data.playerCount}/20`;
                        }
                        break;

                    case 'player_joined':
                        console.log('Player joined:', {
                            username: data.username,
                            position: data.position,
                            rotation: data.rotation,
                            gameStarted: gameStarted,
                            isCurrentPlayer: data.username === playerUsername
                        });
                        // Only create player model if it's not the current player and game has started
                        if (data.username !== playerUsername && gameStarted) {
                            console.log('Creating player model for:', data.username);
                            if (!playerStates.has(data.username)) {
                                const playerMesh = createPlayerModel(data.username);
                                console.log('Player model created:', {
                                    username: data.username,
                                    mesh: playerMesh,
                                    position: playerMesh.position,
                                    visible: playerMesh.visible,
                                    inScene: scene.children.includes(playerMesh)
                                });
                            }
                            updatePlayerList();
                        }
                        break;

                    case 'position':
                        if (data.username !== playerUsername && gameStarted) {
                            console.log('Received position update for:', {
                                username: data.username,
                                position: data.position,
                                rotation: data.rotation,
                                hasPlayerState: playerStates.has(data.username)
                            });
                            
                            // Only create player model if we have valid position data
                            if (data.position && data.position.length === 3) {
                                // Ensure player model exists before updating position
                                if (!playerStates.has(data.username)) {
                                    console.log('Creating missing player model for:', data.username);
                                    const playerMesh = createPlayerModel(data.username);
                                    console.log('Created missing player model:', {
                                        username: data.username,
                                        mesh: playerMesh,
                                        position: playerMesh.position,
                                        visible: playerMesh.visible
                                    });
                                }
                                
                                // Update player state with new data
                                const playerState = playerStates.get(data.username);
                                if (playerState) {
                                    console.log('Updating player state for:', {
                                        username: data.username,
                                        oldPosition: playerState.position.clone(),
                                        newPosition: data.position,
                                        oldRotation: playerState.rotation.clone(),
                                        newRotation: data.rotation
                                    });
                                    
                                    // Update position
                                    if (data.position) {
                                        playerState.position.fromArray(data.position);
                                    }
                                    
                                    // Update rotation
                                    if (data.rotation) {
                                        playerState.rotation.fromArray(data.rotation);
                                    }
                                    
                                    // Update speed and heading if provided
                                    if (data.speed !== undefined) {
                                        playerState.speed = data.speed;
                                    }
                                    if (data.heading !== undefined) {
                                        playerState.heading = data.heading;
                                    }
                                    if (data.verticalSpeed !== undefined) {
                                        playerState.verticalSpeed = data.verticalSpeed;
                                    }
                                    
                                    playerState.lastUpdateTime = Date.now();
                                    
                                    // Verify mesh visibility
                                    if (playerState.mesh) {
                                        console.log('Player mesh state:', {
                                            username: data.username,
                                            position: playerState.mesh.position,
                                            visible: playerState.mesh.visible,
                                            inScene: scene.children.includes(playerState.mesh)
                                        });
                                    }
                                } else {
                                    console.warn('No player state found for username:', data.username);
                                }
                            }
                        }
                        break;

                    case 'player_left':
                        console.log('Player left:', data.username);
                        handlePlayerLeft(data.username);
                        break;

                    case 'shotgun_shot':
                        if (data.username !== playerUsername && gameStarted) {
                            const shooterPos = new THREE.Vector3().fromArray(data.position);
                            
                            // Create visual pellets for other players' shots using the pellet pool
                            data.directions.forEach(direction => {
                                const pellet = pelletPool.get();
                                if (pellet) {
                                    pellet.position.copy(shooterPos);
                                    pellet.velocity = new THREE.Vector3().fromArray(direction).multiplyScalar(PELLET_SPEED);
                                    pellet.spawnTime = performance.now();
                                    pellet.visible = true;
                                    pellet.bounces = 0;
                                    pelletPool.active.add(pellet);
                                }
                            });
                            
                            playShotgunSound();
                        }
                        break;

                }
            });
        }

        // Shooting system constants
        const SHOTGUN_COOLDOWN = 1000; // 1 second cooldown
        const SHOTGUN_RANGE = 2000;
        const PELLET_COUNT = 8;
        const PELLET_SPREAD = 0.4; // Increased from 0.2 to 0.4 for wider spread
        const PELLET_SPEED = 50;
        const PELLET_LIFETIME = 2000;
        const PELLET_GRAVITY = 0.5;
        const PELLET_BOUNCE = 0.3;
        const PELLET_FRICTION = 0.98;
        const PELLET_RADIUS = 0.3;
        let lastShotTime = 0;

        // Create pellet pool
        const pelletPool = {
            pellets: [],
            active: new Set(),
            get: function() {
                if (this.pellets.length === 0) {
                    const pelletGeometry = new THREE.SphereGeometry(PELLET_RADIUS, 8, 8);
                    const pelletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const pellet = new THREE.Mesh(pelletGeometry, pelletMaterial);
                    pellet.visible = false;
                    pellet.velocity = new THREE.Vector3();
                    pellet.lastPosition = new THREE.Vector3();
                    pellet.bounces = 0;
                    pellet.maxBounces = 3;
                    scene.add(pellet);
                    return pellet;
                }
                const pellet = this.pellets.pop();
                pellet.visible = true;
                scene.add(pellet);
                return pellet;
            },
            release: function(pellet) {
                pellet.visible = false;
                pellet.position.set(0, 0, 0);
                pellet.velocity.set(0, 0, 0);
                pellet.bounces = 0;
                scene.remove(pellet);
                this.active.delete(pellet);
                this.pellets.push(pellet);
            }
        };

        function animatePellets() {
            const currentTime = Date.now();
            const deltaTime = clock.getDelta();
            
            pelletPool.active.forEach(pellet => {
                if (currentTime - pellet.spawnTime > PELLET_LIFETIME) {
                    pelletPool.release(pellet);
                    return;
                }
                
                pellet.lastPosition.copy(pellet.position);
                pellet.velocity.y -= PELLET_GRAVITY * deltaTime;
                pellet.velocity.multiplyScalar(PELLET_FRICTION);
                pellet.position.add(pellet.velocity.clone().multiplyScalar(deltaTime));
                
                const pelletCollider = new THREE.Sphere(pellet.position, PELLET_RADIUS);
                let collision = false;
                let collisionNormal = new THREE.Vector3();
                
                // Check tower collisions
                for (const tower of towers) {
                    if (tower.collisionBoxes) {
                        for (const box of tower.collisionBoxes) {
                            if (box.containsSphere(pelletCollider)) {
                                const center = box.getCenter(new THREE.Vector3());
                                collisionNormal.copy(pellet.position).sub(center).normalize();
                                collision = true;
                                break;
                            }
                        }
                        if (collision) break;
                    }
                }
                
                if (collision) {
                    pellet.position.copy(pellet.lastPosition);
                    pellet.velocity.reflect(collisionNormal);
                    pellet.velocity.multiplyScalar(PELLET_BOUNCE * PELLET_FRICTION);
                    pellet.bounces++;
                    
                    if (pellet.bounces >= pellet.maxBounces) {
                        pelletPool.release(pellet);
                    }
                }
                
                // Check player collisions
                playerStates.forEach((playerState, username) => {
                    if (username !== playerUsername && playerState.mesh) {
                        const distance = pellet.position.distanceTo(playerState.mesh.position);
                        if (distance < playerRadius + PELLET_RADIUS) {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'player_damaged',
                                    username: username,
                                    damage: 20
                                }));
                            }
                            pelletPool.release(pellet);
                        }
                    }
                });
                
                if (pellet.position.y < -1000) {
                    pelletPool.release(pellet);
                }
            });
        }

        // Animation loop with collision detection, star rotation, and nebula animation
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const currentTime = performance.now();
            
            // Update pellets
            animatePellets();
            
            if (gameStarted) {
                // Update frustum for culling
                projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                frustum.setFromProjectionMatrix(projScreenMatrix);
                
                // Update other players' positions with throttling
                if (currentTime - lastCollisionCheck > COLLISION_CHECK_INTERVAL) {
                    playerStates.forEach((playerState, username) => {
                        if (username !== playerUsername) {
                            const timeSinceUpdate = Date.now() - playerState.lastUpdateTime;
                            if (timeSinceUpdate > 5000) {
                                removePlayer(username);
                            } else {
                                playerState.update(deltaTime);
                            }
                        }
                    });
                    lastCollisionCheck = currentTime;
                }
                
                // Update nebula animations with reduced frequency
                if (currentTime % 2 === 0) { // Update every other frame
                    const time = currentTime * 0.001;
                    nebulas.forEach((nebula, index) => {
                        if (nebula && nebula.material && nebula.material.uniforms) {
                            nebula.material.uniforms.time.value = time;
                            nebula.rotation.y += 0.0001;
                            nebula.rotation.x += 0.00005;
                            nebula.position.y += Math.sin(time * 0.1 + index) * 0.05;
                            nebula.position.x += Math.cos(time * 0.15 + index) * 0.05;
                        }
                    });
                }

                // Rotate star fields with reduced frequency
                if (currentTime % 2 === 0) { // Update every other frame
                    starField.rotation.y += 0.0001;
                    largeStarField.rotation.y += 0.00005;
                }

                // Update tower visibility based on frustum culling
                towers.forEach(tower => {
                    if (tower.mesh) {
                        const box = new THREE.Box3().setFromObject(tower.mesh);
                        tower.mesh.visible = frustum.intersectsBox(box);
                    }
                });

                // Only process movement and game logic if controls are locked and game is started
                if (controls.isLocked && gameStarted) {
                    // ... rest of the animation loop code ...
                }
            }

            // Always render the scene
            renderer.render(scene, camera);
        }

        function fireShotgun() {
            if (!gameStarted || !controls.isLocked) return;

            const now = Date.now();
            if (now - lastShotTime < SHOTGUN_COOLDOWN) {
                return; // Cooldown active
            }
            lastShotTime = now;

            const cameraObject = controls.getObject();
            const fireDirection = new THREE.Vector3();
            cameraObject.getWorldDirection(fireDirection);
            // Start pellets slightly in front of camera
            const fireOrigin = cameraObject.position.clone().addScaledVector(fireDirection, 1.5);

            // Create array to store pellet directions
            const pelletDirections = [];

            for (let i = 0; i < PELLET_COUNT; i++) {
                // Calculate spread using random angle offsets
                const spreadAngleX = (Math.random() - 0.5) * PELLET_SPREAD * 2;
                const spreadAngleY = (Math.random() - 0.5) * PELLET_SPREAD * 2;

                // Create quaternion for spread rotation
                const spreadQuat = new THREE.Quaternion();
                spreadQuat.setFromEuler(new THREE.Euler(spreadAngleX, spreadAngleY, 0, 'YXZ')); // Apply spread rotation

                // Apply spread to fire direction
                const pelletDirection = fireDirection.clone().applyQuaternion(spreadQuat).normalize();
                pelletDirections.push(pelletDirection.toArray());

                // Create visual pellet for the shooter
                const pellet = pelletPool.get();
                if (pellet) {
                    pellet.position.copy(fireOrigin);
                    pellet.velocity = pelletDirection.multiplyScalar(PELLET_SPEED);
                    pellet.spawnTime = performance.now();
                    pellet.visible = true;
                    pellet.bounces = 0;
                    pelletPool.active.add(pellet);
                }
            }

            // Notify server about the shot with all pellet directions
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'shotgun_shot',
                    username: playerUsername,
                    position: fireOrigin.toArray(),
                    directions: pelletDirections
                }));
            }

            playShotgunSound();
        }

        // Add mouse event listeners for firing
        document.addEventListener('mousedown', (event) => {
            if (event.button === 0) { // Left click
                fireShotgun();
            }
        });

        // Add mobile fire button event listener
        const mobileFireButton = document.getElementById('mobileFireButton');
        if (mobileFireButton) {
            mobileFireButton.addEventListener('touchstart', (event) => {
                event.preventDefault();
                fireShotgun();
            });
        }
    </script>
</body>
</html>
