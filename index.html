<!DOCTYPE html>
<html lang="en">
<head>
    <title>ResetRule</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/virtual-joystick/1.10.0/virtual-joystick.min.js"></script>
    <style>
        body { 
            margin: 0; 
            background-color: #000000;
        }
        canvas { 
            display: block; 
        }
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #333;
            z-index: 1000;
        }
        #instructions.hidden {
            display: none;
        }
        #username {
            margin: 10px 0;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            font-size: 16px;
            width: 200px;
            text-align: center;
        }
        #startButton {
            margin-top: 15px;
            padding: 8px 20px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #45a049;
        }
        #startButton:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        /* Mobile Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            height: 120px;
            width: 120px;
            pointer-events: auto;
            z-index: 1000;
            touch-action: none;
        }
        .joystick-zone {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 60px;
            pointer-events: auto;
            z-index: 1000;
            touch-action: none;
        }
        .joystick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 25px;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out;
            touch-action: none;
        }
        /* Add left joystick for movement */
        .mobile-controls.left {
            left: 20px;
            right: auto;
        }
        #flingButton {
            display: none;
            position: fixed;
            bottom: 160px;
            left: 40px;
            width: 80px;
            height: 80px;
            background: rgba(76, 175, 80, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 32px;
            line-height: 80px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            z-index: 1000;
            touch-action: none;
            transition: all 0.1s ease-out;
            user-select: none;
        }
        #flingButton.active {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(0.95);
        }
        /* Show mobile controls on touch devices */
        @media (pointer: coarse) {
            .mobile-controls {
                display: block !important;
            }
            #flingButton {
                display: block !important;
            }
        }
        #roomInfo {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;  /* Increased horizontal padding */
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
            min-width: 120px;  /* Added minimum width */
            text-align: center;  /* Center the text */
        }

        #playerList {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            font-size: 16px;
            display: none;
            min-width: 150px;
            max-height: 300px;
            overflow-y: auto;
        }

        #playerList.visible {
            display: block;
        }

        .playerListItem {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
            white-space: nowrap;
        }

        .playerListItem:hover {
            background-color: rgba(76, 175, 80, 0.2);
        }

        .popupButton {
            padding: 15px 30px;
            border: none;
            border-radius: 5px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            transition: transform 0.1s;
            animation: none;
        }

        .popupButton:hover {
            animation: shake 0.5s infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>Welcome to ResetRule</h2>
        <input type="text" id="username" placeholder="Enter your username" maxlength="15">
        <button id="startButton" disabled>Start Game</button>
        <p style="margin-top: 20px;">
            Desktop Controls:<br>
            WASD = Move<br>
            Mouse = Look around<br>
            ESC = Exit<br>
            Left Click = Aim & Release to Fling
        </p>
        <p id="mobileInstructions" style="display: none; margin-top: 20px;">
            Mobile Controls:<br>
            Right Stick = Look around<br>
            Fling Button = Aim & Release to Fling
        </p>
    </div>
    
    <div id="playerList"></div>
    <div id="orbCount" style="position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: #4CAF50; padding: 10px; border-radius: 5px; z-index: 1000; font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; text-shadow: 0 0 5px rgba(76, 175, 80, 0.5);">
        Orbs: 0
    </div>
    <div id="roomInfo"></div>
    
    <!-- Mobile Controls -->
    <div class="mobile-controls">
        <div id="rightJoystick" class="joystick-zone"></div>
    </div>
    <div id="flingButton">âš¡</div>

    <!-- Add after the roomInfo div -->
    <div id="orbPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 10px; z-index: 2000; text-align: center; border: 2px solid #4CAF50;">
        <h2 style="color: #4CAF50; margin-bottom: 20px;">You've collected 30 orbs!</h2>
        <div style="display: flex; gap: 20px; justify-content: center;">
            <button id="resetButton" class="popupButton" style="background-color: #ff4444;">Reset (C)</button>
            <button id="ruleButton" class="popupButton" style="background-color: #4CAF50;">Rule (V)</button>
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Global variables and constants
        const playerHeight = 10;
        const playerRadius = 1.5;
        const moveSpeed = 22.0; // Units per second
        const gravity = 0.015; // Reduced from 0.015 for longer air time
        const flingStrength = 3.0; // Increased from 2.75
        const flingDamping = 0.999; // Controls how quickly the fling velocity decreases (closer to 1 means less damping)
        const clock = new THREE.Clock();
        const lastSentPosition = new THREE.Vector3(); // Initialize last sent position
        const lastSentRotation = new THREE.Vector3(); // Initialize last sent rotation
        let ws = null; // Initialize WebSocket variable
        let wsConnectionAttempted = false; // Track if we've attempted to connect
        let worldDataRequested = false; // Track if we've requested world data

        // Shooting system constants - Adjusted for shotgun feel
        const SHOTGUN_COOLDOWN = 800; // milliseconds cooldown
        const PELLET_COUNT = 10;       // Number of pellets per shot
        const PELLET_SPREAD = 0.15;    // Cone spread factor (radians)
        const PELLET_SPEED = 200;      // Units per second - Slower
        const PELLET_LIFETIME = 250;  // Milliseconds - much shorter lifespan
        const PELLET_GRAVITY = 0.0;     // Gravity effect on pellets (0 for straight line)
        const PELLET_RADIUS = 0.4;     // Pellet collision radius - Larger
        const SHOTGUN_DAMAGE = 10;     // Damage per pellet hit
        const PELLET_FRICTION = 0.99;  // Damping factor for pellets (0=stop, 1=no friction)
        const PELLET_BOUNCE = 0.5;     // How much velocity is kept after bouncing (0-1)
        const PELLET_MAX_BOUNCES = 0;  // How many times a pellet can bounce before disappearing
        let lastShotTime = 0;
        let playerHealth = 100;
        let isDead = false;

        // Initialize WebSocket connection immediately
        if (!wsConnectionAttempted) {
            setupWebSocket();
            wsConnectionAttempted = true;
        }

        // Add object pooling system
        const objectPool = {
            vectors: [],
            spheres: [],
            boxes: [],
            getVector: function() {
                return this.vectors.pop() || new THREE.Vector3();
            },
            releaseVector: function(vector) {
                vector.set(0, 0, 0);
                this.vectors.push(vector);
            },
            getSphere: function() {
                return this.spheres.pop() || new THREE.Sphere();
            },
            releaseSphere: function(sphere) {
                sphere.center.set(0, 0, 0);
                sphere.radius = 0;
                this.spheres.push(sphere);
            },
            getBox: function() {
                return this.boxes.pop() || new THREE.Box3();
            },
            releaseBox: function(box) {
                box.makeEmpty();
                this.boxes.push(box);
            }
        };

        // Add movement smoothing constants
        const MOVEMENT_SMOOTHING = 0.85; // Reduced from 0.85 for smoother movement
        const COLLISION_PUSH_FORCE = 4.5; // Increased again for stronger collision response
        const COLLISION_BIAS = 0.01;      // Small bias to push player slightly past surface
        const CORNER_SLIDE_FORCE = 0.8; // Increased from 0.7 for better sliding
        const MIN_VELOCITY_THRESHOLD = 0.001; // Threshold for stopping movement
        const STUCK_THRESHOLD = 0.3; // New constant for detecting when player is stuck
        const STUCK_PUSH_FORCE = 5.0; // New constant for extra push force when stuck

        // Game state variables
        let gameStarted = false;
        let playerUsername = '';
        let isGrounded = true;
        let isFlinging = false;
        let showLine = false;
        let lineCollisionPoint = null;
        let verticalVelocity = 0.0;
        let pelletPool = null; // <-- Declare pelletPool here

        // Movement state variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        // Scene-related variables
        let scene, camera, renderer, controls;

        // Collections
        const towers = [];
        const nebulas = [];
        const bridges = []; // <-- Declare bridges array
        const playerStates = new Map();
        const orbs = new Map(); // Add orbs collection
        const playerOrbs = new Map(); // Track orbs collected by each player
        const collisionBoxes = []; // Add collision boxes collection

        // Vectors and other THREE.js objects
        const velocity = new THREE.Vector3();
        const flingVelocity = new THREE.Vector3();
        const direction = new THREE.Vector3();

        // Mobile detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Add interpolation settings
        const INTERPOLATION_SPEED = 0.15;

        // Store player states for interpolation
        class PlayerState {
            constructor(username, mesh) {
                this.username = username;
                this.mesh = mesh;
                this.position = new THREE.Vector3();
                this.rotation = new THREE.Euler();
                this.speed = 0;
                this.heading = 0;
                this.verticalSpeed = 0;
                this.lastUpdateTime = Date.now();
                this.isVisible = true;
            }

            update(deltaTime) {
                if (!this.mesh) {
                    console.warn(`No mesh found for player ${this.username}`);
                    return;
                }

                // Make sure mesh is visible if it should be
                this.mesh.visible = this.isVisible;
                if (!this.isVisible) return; // Don't update if not visible

                // Use exponential smoothing for interpolation towards the authoritative position
                // Reduced from -20 to -15 for smoother interpolation
                const lerpFactor = 1 - Math.exp(-15 * deltaTime); 

                // Smoothly interpolate position towards the last known server position
                this.mesh.position.lerp(this.position, lerpFactor);

                // Smoothly interpolate rotation using Euler angles
                const headingRad = (this.heading * Math.PI) / 180;
                // this.mesh.rotation.y = -headingRad; // Old direct setting

                // Lerp rotation 
                const targetRotation = objectPool.getVector(); // Use object pool
                targetRotation.set(0, -headingRad, 0); // Assuming Y-axis rotation based on heading

                // Interpolate Euler angles (ensure angles wrap correctly if needed, though lerp might handle it)
                this.mesh.rotation.x += (targetRotation.x - this.mesh.rotation.x) * lerpFactor;
                this.mesh.rotation.y += (targetRotation.y - this.mesh.rotation.y) * lerpFactor;
                this.mesh.rotation.z += (targetRotation.z - this.mesh.rotation.z) * lerpFactor;

                objectPool.releaseVector(targetRotation); // Release vector back to pool
            }
        }

        // Function to create player model
        function createPlayerModel(username) {
            console.log('Creating player model for:', username);
            
            // Check if player model already exists
            if (playerStates.has(username)) {
                console.log('Player model already exists for:', username);
                return;
            }

            const geometry = new THREE.CapsuleGeometry(2, 6, 2, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                wireframe: true 
            });
            const playerMesh = new THREE.Mesh(geometry, material);
            
            // Add username label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = '32px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(username, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 2.5, 1);
            sprite.position.y = 6;
            playerMesh.add(sprite);
            
            // Add to scene
            scene.add(playerMesh);
            console.log('Added player mesh to scene:', {
                username: username,
                mesh: playerMesh,
                position: playerMesh.position,
                visible: playerMesh.visible
            });
            
            // Create and store player state
            const playerState = new PlayerState(username, playerMesh);
            playerState.position.set(0, playerHeight, 0);
            playerState.rotation.set(0, 0, 0);
            playerStates.set(username, playerState);
            
            console.log('Player model created successfully for:', username);
            return playerMesh;
        }

        // Function to update player position
        function updatePlayerPosition(username, position, rotation) {
            const playerState = playerStates.get(username);
            if (playerState) {
                // Update position
                if (position) {
                    if (Array.isArray(position)) {
                        playerState.position.fromArray(position);
                    } else {
                        playerState.position.set(position.x, position.y, position.z);
                    }
                }
                
                // Update rotation
                if (rotation) {
                    if (Array.isArray(rotation)) {
                        playerState.rotation.fromArray(rotation);
                    } else {
                        playerState.rotation.set(rotation.x, rotation.y, rotation.z);
                    }
                }
                
                // Calculate speed and heading from position changes
                if (playerState.lastPosition) {
                    const dx = playerState.position.x - playerState.lastPosition.x;
                    const dz = playerState.position.z - playerState.lastPosition.z;
                    playerState.speed = Math.sqrt(dx * dx + dz * dz) / (0.016); // Assuming 60fps
                    playerState.heading = Math.atan2(-dx, -dz) * 180 / Math.PI;
                    playerState.verticalSpeed = (playerState.position.y - playerState.lastPosition.y) / 0.016;
                }
                
                playerState.lastPosition = playerState.position.clone();
                playerState.lastUpdateTime = Date.now();
            } else {
                console.warn('No player state found for username:', username);
            }
        }

        // Function to remove player
        function removePlayer(username) {
            console.log('Removing player:', username);
            const playerState = playerStates.get(username);
            if (playerState) {
                scene.remove(playerState.mesh);
                playerStates.delete(username);
                console.log('Player removed successfully:', username);
            }
        }

        // Add after the global variables section
        const geometryCache = new Map();
        const materialCache = new Map();
        const COLLISION_CHECK_INTERVAL = 100; // ms
        let lastCollisionCheck = 0;

        // Add frustum culling variables
        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();

        // Add clearTowers function
        function clearTowers() {
            towers.forEach(tower => {
                if (tower.mesh) {
                    tower.mesh.traverse(child => {
                        if (child.geometry) {
                            child.geometry.dispose();
                        }
                    });
                    scene.remove(tower.mesh);
                }
            });
            towers.length = 0;
        }

        const spatialGrid = {
            cellSize: 100,
            cells: new Map(),
            getKey: function(x, z) {
                return `${Math.floor(x / this.cellSize)},${Math.floor(z / this.cellSize)}`;
            },
            add: function(object) {
                const key = this.getKey(object.position.x, object.position.z);
                if (!this.cells.has(key)) {
                    this.cells.set(key, new Set());
                }
                this.cells.get(key).add(object);
            },
            remove: function(object) {
                const key = this.getKey(object.position.x, object.position.z);
                if (this.cells.has(key)) {
                    this.cells.get(key).delete(object);
                }
            },
            getNearbyObjects: function(position, radius) {
                const nearbyObjects = new Set();
                const minX = Math.floor((position.x - radius) / this.cellSize);
                const maxX = Math.floor((position.x + radius) / this.cellSize);
                const minZ = Math.floor((position.z - radius) / this.cellSize);
                const maxZ = Math.floor((position.z + radius) / this.cellSize);
                
                for (let x = minX; x <= maxX; x++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        const key = `${x},${z}`;
                        if (this.cells.has(key)) {
                            this.cells.get(key).forEach(obj => nearbyObjects.add(obj));
                        }
                    }
                }
                return nearbyObjects;
            }
        };

        // Add after the createTowerFromData function
        function getGeometryFromCache(type, params) {
            const key = `${type}-${JSON.stringify(params)}`;
            if (!geometryCache.has(key)) {
                let geometry;
                switch(type) {
                    case 'cylinder':
                        geometry = new THREE.CylinderGeometry(params.radius, params.radius, params.height, Math.min(params.segments, 8)); // Limit segments
                        break;
                    case 'box':
                        geometry = new THREE.BoxGeometry(params.width, params.height, params.depth);
                        break;
                    case 'cone':
                        geometry = new THREE.ConeGeometry(params.radius, params.height, Math.min(params.segments, 6)); // Limit segments
                        break;
                }
                geometryCache.set(key, geometry);
            }
            return geometryCache.get(key);
        }

        function getMaterialFromCache(type, params) {
            const key = `${type}-${JSON.stringify(params)}`;
            if (!materialCache.has(key)) {
                let material;
                switch(type) {
                    case 'basic':
                        material = new THREE.MeshBasicMaterial(params);
                        break;
                    case 'line':
                        material = new THREE.LineBasicMaterial(params);
                        break;
                    // Add more cases as needed
                }
                materialCache.set(key, material);
            }
            return materialCache.get(key);
        }

        // Add after the material cache
        const sharedMaterials = {
            tower: new THREE.MeshBasicMaterial({ color: 0x000000 }),
            towerEdges: new THREE.LineBasicMaterial({ color: 0xffffff })
        };

        // Modify createTowerFromData to use shared materials
        function createTowerFromData(towerData) {
            const height = towerData.height;
            const baseHeight = towerData.baseHeight;
            
            let geometry;
            let towerHeight = height;
            
            switch(towerData.type) {
                case 0: // Cylindrical tower
                    geometry = getGeometryFromCache('cylinder', { radius: 18, height, segments: 8 });
                    break;
                case 1: // Tapered tower
                    geometry = getGeometryFromCache('cylinder', { radius: 12, height, segments: 6 });
                    break;
                case 2: // Square tower
                    geometry = getGeometryFromCache('box', { width: 36, height, depth: 36 });
                    break;
                case 3: // Hexagonal tower
                    geometry = getGeometryFromCache('cylinder', { radius: 20, height, segments: 6 });
                    break;
                case 4: // Twisted tower
                    geometry = getGeometryFromCache('cylinder', { radius: 15, height, segments: 8 });
                    break;
                case 5: // Pyramid tower
                    geometry = getGeometryFromCache('cone', { radius: 24, height, segments: 4 });
                    break;
                case 6: // Octagonal tower
                    geometry = getGeometryFromCache('cylinder', { radius: 19, height, segments: 8 });
                    break;
                case 7: // Double width tower
                    geometry = getGeometryFromCache('box', { width: 42, height, depth: 42 });
                    break;
                case 8: // Inverse pyramid
                    geometry = getGeometryFromCache('cylinder', { radius: 12, height, segments: 4 });
                    break;
                case 9: // Star tower
                    geometry = getGeometryFromCache('cylinder', { radius: 24, height, segments: 5 });
                    break;
                case 10: // Thin spire
                    geometry = getGeometryFromCache('cylinder', { radius: 8, height, segments: 6 });
                    break;
            }

            // Create the main mesh with solid faces using shared material
            const mesh = new THREE.Mesh(geometry, sharedMaterials.tower);
            
            // Create the edges using shared material
            const edges = new THREE.LineSegments(
                new THREE.EdgesGeometry(geometry),
                sharedMaterials.towerEdges
            );
            
            // Group the mesh and edges together
            const group = new THREE.Group();
            group.add(mesh);
            group.add(edges);
            group.position.set(towerData.x, height/2 + baseHeight, towerData.z);
            scene.add(group);

            // Create a single box collider for the tower
            const collisionBox = new THREE.Box3();
            const collisionMesh = new THREE.Mesh(
                getGeometryFromCache('box', { width: 36, height, depth: 36 })
            );
            collisionMesh.position.copy(group.position);
            collisionBox.setFromObject(collisionMesh);
            
            towers.push({
                mesh: group,
                collisionBoxes: [collisionBox]
            });
        }

        // Function to create bridge from server data
        function createBridgeFromData(bridgeData) {
            // Calculate bridge dimensions
            const bridgeWidth = 16;
            const startPos = new THREE.Vector3(
                bridgeData.startX || bridgeData.start.x,
                bridgeData.height,
                bridgeData.startZ || bridgeData.start.z
            );
            const endPos = new THREE.Vector3(
                bridgeData.endX || bridgeData.end.x,
                bridgeData.height,
                bridgeData.endZ || bridgeData.end.z
            );
            const distance = startPos.distanceTo(endPos);
            const angle = Math.atan2(endPos.x - startPos.x, endPos.z - startPos.z);
            const midPoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
            const bridgeLength = distance;

            // Create bridge group
            const bridgeGroup = new THREE.Group();

            // Create bridge geometry
            const bridgeGeometry = new THREE.BoxGeometry(distance, bridgeWidth, bridgeWidth);
            
            // Create materials for the bridge (matching tower style)
            const bridgeMaterials = [
                new THREE.MeshBasicMaterial({ color: 0x000000 }),
                new THREE.LineBasicMaterial({ color: 0xffffff })
            ];
            
            // Create bridge mesh and edges
            const bridgeMesh = new THREE.Mesh(bridgeGeometry, bridgeMaterials[0]);
            bridgeMesh.name = 'bridge'; // Add name to identify bridges
            const bridgeEdges = new THREE.LineSegments(
                new THREE.EdgesGeometry(bridgeGeometry),
                bridgeMaterials[1]
            );

            // Calculate local bounding box (Axis-Aligned relative to the bridge geometry)
            const localCollisionBox = new THREE.Box3().setFromObject(bridgeMesh);

            // Position bridge
            bridgeGroup.add(bridgeMesh);
            bridgeGroup.add(bridgeEdges);
            bridgeGroup.position.copy(midPoint);
            bridgeGroup.rotation.y = angle;

            scene.add(bridgeGroup);

            // Add bridge to towers array for consistent handling
            const bridgeObject = {
                mesh: bridgeGroup, // Store the group which has world transform
                localCollisionBox: localCollisionBox, // Store the local box
                isBridge: true // Add flag to identify bridges
            };
            towers.push(bridgeObject);

            // Log bridge collision box details for debugging
            console.log('Bridge added to collision system:', {
                center: bridgeObject.localCollisionBox.getCenter(new THREE.Vector3()), // Log local center
                size: bridgeObject.localCollisionBox.getSize(new THREE.Vector3()),     // Log local size
                hasCollisionBox: !!bridgeObject.localCollisionBox, // Check if local box exists
                isBridge: bridgeObject.isBridge
            });
            return bridgeGroup;
        }

        // Update collision check function to handle bridges like towers
        function checkCollision(position, radius) {
            const playerCollider = new THREE.Sphere(position, radius);
            let closestCollision = null;
            let minDistance = Infinity;
            
            // Temporary vectors for calculations to avoid re-allocation in loop
            const worldToLocalMatrix = new THREE.Matrix4();
            const localPosition = new THREE.Vector3();
            const localClosestPoint = new THREE.Vector3();
            const worldClosestPoint = new THREE.Vector3();
            
            for (const tower of towers) {
                const isBridge = tower.isBridge;
                
                if (isBridge && tower.localCollisionBox && tower.mesh) {
                    // --- OBB Check for Bridges ---
                    const bridgeMesh = tower.mesh;
                    const localBox = tower.localCollisionBox;
                    
                    // Ensure world matrix is up-to-date
                    bridgeMesh.updateMatrixWorld(true);
                    
                    // Get matrix to transform world -> local
                    worldToLocalMatrix.copy(bridgeMesh.matrixWorld).invert();
                    
                    // Transform player position to bridge's local space
                    localPosition.copy(position).applyMatrix4(worldToLocalMatrix);
                    
                    // Find closest point on the local AABB
                    localBox.clampPoint(localPosition, localClosestPoint);
                    
                    // Calculate distance in local space
                    const distance = localPosition.distanceTo(localClosestPoint);
                    
                    // Check if the player sphere intersects the box
                    if (distance < radius) {
                        // Transform the local closest point back to world space for response
                        worldClosestPoint.copy(localClosestPoint).applyMatrix4(bridgeMesh.matrixWorld);
                        
                        // Check if this is the closest collision so far
                        const worldDistance = position.distanceTo(worldClosestPoint); // Use world distance for comparison
                        if (worldDistance < minDistance) {
                            minDistance = worldDistance;
                            closestCollision = {
                                collision: true,
                                tower: tower,
                                collisionBox: localBox, // Store local box for potential debug?
                                distance: worldDistance,      // Store world distance
                                closestPoint: worldClosestPoint.clone(), // Store world point
                                isBridge: true
                            };
                        }
                    }
                } else if (!isBridge && tower.collisionBoxes && tower.collisionBoxes.length > 0) {
                    // --- AABB Check for Towers (existing logic) ---
                    const collisionBox = tower.collisionBoxes[0]; // Assume first box is the main one
                    
                    // Get the closest point on the world AABB to the player
                    worldClosestPoint.copy(position); // Use worldClosestPoint vector
                    collisionBox.clampPoint(worldClosestPoint, worldClosestPoint);
                    
                    // Calculate distance to closest point
                    const distance = position.distanceTo(worldClosestPoint);
                    
                    // Check if sphere intersects AABB
                    if (distance < radius) {
                        // Check if this is the closest collision so far
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestCollision = {
                                collision: true,
                                tower: tower,
                                collisionBox: collisionBox, // Store world AABB
                                distance: distance,
                                closestPoint: worldClosestPoint.clone(), // Store world point
                                isBridge: false
                            };
                        }
                    }
                }
            }
            
            // Return the closest valid collision found
            return closestCollision || {
                collision: false,
                tower: null,
                collisionBox: null,
                distance: Infinity,
                closestPoint: null,
                isBridge: false
            };
        }

        // Add after the checkCollision function
        function checkOrbCollision(position, radius) {
            const playerCollider = new THREE.Sphere(position, radius * 10); // Increased from 5x to 10x
            let closestOrb = null;
            let minDistance = Infinity;
            
            orbs.forEach((orb, orbId) => {
                const orbPosition = orb.position;
                const distance = position.distanceTo(orbPosition);
                
                // --- DEBUG LOGGING START ---
                if (isMobile) {
                    // Log distance only for nearby orbs to avoid spamming the console
                    if (distance < (radius * 10) + orb.userData.originalScale + 50) { // Log if within potential collision range + buffer
                         console.log(`[Mobile Debug] Orb ${orbId} distance: ${distance.toFixed(2)} | Check: < ${(radius * 10 + orb.userData.originalScale).toFixed(2)}`);
                    }
                }
                // --- DEBUG LOGGING END ---

                // Collision condition: distance < combined radii
                // Player effective radius = radius * 10
                if (distance < (radius * 10) + orb.userData.originalScale) {
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestOrb = { orb, orbId };
                    }
                }
            });
            
            return closestOrb;
        }

        // WebSocket setup with Railway support
        const getWebSocketUrl = () => {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            if (window.location.hostname.includes('.railway.app')) {
                return `${protocol}//${window.location.host}`;
            }
            return 'ws://localhost:3000';
        };

        let wsReconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        function setupWebSocket() {
            // Don't set up if we already have a connection
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('WebSocket already connected');
                return;
            }

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}`;
            console.log('Attempting to connect to WebSocket at:', wsUrl);
            ws = new WebSocket(wsUrl);

            ws.addEventListener('open', () => {
                console.log('WebSocket connection established');
                // Request world data if we haven't already
                if (!worldDataRequested) {
                    console.log('Requesting world data...');
                    ws.send(JSON.stringify({
                        type: 'request_world_data'
                    }));
                    worldDataRequested = true;
                }
                // Only send join message if we have a username
                if (playerUsername) {
                    const joinMessage = {
                        type: 'join',
                        username: playerUsername
                    };
                    console.log('Sending join message:', joinMessage);
                    ws.send(JSON.stringify(joinMessage));
                }
            });

            ws.addEventListener('message', (event) => {
                const data = JSON.parse(event.data);
                console.log('Received WebSocket message:', {
                    type: data.type,
                    username: data.username,
                    position: data.position,
                    rotation: data.rotation,
                    timestamp: new Date().toISOString()
                });
                
                switch (data.type) {
                    case 'world_data':
                        console.log('Received world data with players:', data.players);
                        // Clear existing player states except current player
                        const currentPlayerState = playerStates.get(playerUsername);
                        playerStates.clear();
                        if (currentPlayerState) {
                            playerStates.set(playerUsername, currentPlayerState);
                        }
                        
                        // Clear existing towers and bridges using the new function
                        clearTowers();
                        
                        // Create towers from server data first
                        if (data.towers) {
                            console.log('Creating towers:', data.towers.length);
                            data.towers.forEach(towerData => {
                                createTowerFromData(towerData);
                            });
                        }
                        
                        // Create bridges from server data
                        if (data.bridges) {
                            data.bridges.forEach(bridgeData => {
                                createBridgeFromData(bridgeData);
                            });
                        }

                        // Debug logging for orbs
                        console.log('Processing orbs data:', data.orbs);
                        
                        // Clear existing orbs
                        orbs.forEach(orb => {
                            console.log('Removing existing orb:', orb);
                            scene.remove(orb);
                        });
                        orbs.clear();
                        
                        // Create new orbs
                        if (data.orbs && data.orbs.length > 0) {
                            console.log('Creating orbs:', data.orbs.length);
                            data.orbs.forEach((orbData, index) => {
                                console.log(`Creating orb ${index}:`, orbData);
                                try {
                                    const orb = createOrb(orbData);
                                    console.log(`Successfully created orb ${index}:`, orb);
                                    // Ensure orb is added to scene
                                    if (!scene.children.includes(orb)) {
                                        scene.add(orb);
                                    }
                                } catch (error) {
                                    console.error(`Error creating orb ${index}:`, error);
                                }
                            });
                        } else {
                            console.warn('No orbs data received from server');
                        }
                        break;

                    case 'room_info':
                        console.log(`Joined room ${data.name} with ${data.playerCount} players`);
                        // Only update room info if we have a valid player count
                        if (data.playerCount > 0) {
                            document.getElementById('roomInfo').textContent = `${data.name} - Players: ${data.playerCount}/20`;
                        }
                        break;

                    case 'player_joined':
                        console.log('Player joined:', {
                            username: data.username,
                            position: data.position,
                            rotation: data.rotation,
                            gameStarted: gameStarted,
                            isCurrentPlayer: data.username === playerUsername
                        });
                        // Only create player model if it's not the current player and game has started
                        if (data.username !== playerUsername && gameStarted) {
                            console.log('Creating player model for:', data.username);
                            if (!playerStates.has(data.username)) {
                                const playerMesh = createPlayerModel(data.username);
                                console.log('Player model created:', {
                                    username: data.username,
                                    mesh: playerMesh,
                                    position: playerMesh.position,
                                    visible: playerMesh.visible,
                                    inScene: scene.children.includes(playerMesh)
                                });
                            }
                            updatePlayerList();
                        }
                        break;

                    case 'position':
                        if (data.username !== playerUsername && gameStarted) {
                            console.log('Received position update for:', {
                                username: data.username,
                                position: data.position,
                                rotation: data.rotation,
                                hasPlayerState: playerStates.has(data.username)
                            });
                            
                            // Only create player model if we have valid position data
                            if (data.position && data.position.length === 3) {
                                // Ensure player model exists before updating position
                                if (!playerStates.has(data.username)) {
                                    console.log('Creating missing player model for:', data.username);
                                    const playerMesh = createPlayerModel(data.username);
                                    console.log('Created missing player model:', {
                                        username: data.username,
                                        mesh: playerMesh,
                                        position: playerMesh.position,
                                        visible: playerMesh.visible
                                    });
                                }
                                
                                // Update player state with new data
                                const playerState = playerStates.get(data.username);
                                if (playerState) {
                                    console.log('Updating player state for:', {
                                        username: data.username,
                                        oldPosition: playerState.position.clone(),
                                        newPosition: data.position,
                                        oldRotation: playerState.rotation.clone(),
                                        newRotation: data.rotation
                                    });
                                    
                                    // Update position
                                    if (data.position) {
                                        playerState.position.fromArray(data.position);
                                    }
                                    
                                    // Update rotation
                                    if (data.rotation) {
                                        playerState.rotation.fromArray(data.rotation);
                                    }
                                    
                                    // Update speed and heading if provided
                                    if (data.speed !== undefined) {
                                        playerState.speed = data.speed;
                                    }
                                    if (data.heading !== undefined) {
                                        playerState.heading = data.heading;
                                    }
                                    if (data.verticalSpeed !== undefined) {
                                        playerState.verticalSpeed = data.verticalSpeed;
                                    }
                                    
                                    playerState.lastUpdateTime = Date.now();
                                    
                                    // Verify mesh visibility
                                    if (playerState.mesh) {
                                        console.log('Player mesh state:', {
                                            username: data.username,
                                            position: playerState.mesh.position,
                                            visible: playerState.mesh.visible,
                                            inScene: scene.children.includes(playerState.mesh)
                                        });
                                    }
                                } else {
                                    console.warn('No player state found for username:', data.username);
                                }
                            }
                        }
                        break;

                    case 'player_left':
                        console.log('Player left:', data.username);
                        handlePlayerLeft(data.username);
                        break;

                    case 'shotgun_shot':
                        // Ensure this message is not from the current player and game has started
                        if (data.username !== playerUsername && gameStarted) {
                            const shooterPos = new THREE.Vector3().fromArray(data.position);
                            const now = performance.now(); // Use consistent timing

                            // Create visual representation of pellets fired by other players using the pool
                            data.directions.forEach(directionArray => {
                                const pellet = pelletPool.get(); // Get a pellet from the pool
                                if (pellet) {
                                    const direction = new THREE.Vector3().fromArray(directionArray);
                                    pellet.position.copy(shooterPos); // Start at shooter's reported position
                                    pellet.velocity.copy(direction).multiplyScalar(PELLET_SPEED);
                                    pellet.spawnTime = now;
                                    pellet.bounces = 0; // Reset bounces (though we won't use them)
                                    pellet.visible = true; // Make it visible
                                    // Note: pellet is already added to the scene during pool initialization
                                } else {
                                    console.warn("Pellet pool exhausted during network update for shotgun_shot");
                                }
                            });

                            // Play sound effect for other player's shot (consider adding positional audio later)
                            playShotgunSound();
                        }
                        break;

                    case 'player_damaged':
                        // Check if the damage message is intended for this player
                        if (data.victimUsername === playerUsername) {
                             console.log(`Received damage: ${data.damage} from ${data.attackerUsername}`); // Log received damage
                            takeDamage(data.damage); // Apply damage locally
                        }
                        break;

                    case 'item_collected':
                        handleItemCollection(data.itemId, data.username);
                        break;

                    case 'orb_collected':
                        // Remove the collected orb from the scene for all players
                        const orb = orbs.get(data.orbId);
                        if (orb) {
                            scene.remove(orb);
                            orbs.delete(data.orbId);
                            
                            // Only update the collector's orb count
                            if (data.username === playerUsername) {
                                const currentOrbs = playerOrbs.get(playerUsername) || 0;
                                playerOrbs.set(playerUsername, currentOrbs + 1);
                                updateOrbCount();
                                playOrbCollectionSound();
                            }
                        }
                        break;
                }
            });

            ws.addEventListener('error', (error) => {
                console.error('WebSocket error:', error);
            });

            ws.addEventListener('close', () => {
                console.log('Disconnected from server');
                // Attempt to reconnect after a delay
                setTimeout(setupWebSocket, 3000);
            });
        }

        // Function to update player list
        function updatePlayerList() {
            const playerList = document.getElementById('playerList');
            if (!playerList.classList.contains('visible')) return;
            
            playerList.innerHTML = '<div style="margin-bottom: 10px; font-weight: bold;">Players:</div>';
            
            // Add current player first
            const currentPlayerItem = document.createElement('div');
            currentPlayerItem.className = 'playerListItem';
            currentPlayerItem.textContent = `${playerUsername} (You)`;
            playerList.appendChild(currentPlayerItem);
            
            // Add other players
            playerStates.forEach((playerState, username) => {
                if (username !== playerUsername) {
                    const playerItem = document.createElement('div');
                    playerItem.className = 'playerListItem';
                    playerItem.textContent = username;
                    playerList.appendChild(playerItem);
                }
            });
        }

        // Update player list when players join/leave
        function handlePlayerJoined(username) {
            console.log('Handling player joined:', username);
            if (username !== playerUsername && gameStarted) {
                // Create player model if it doesn't exist
                if (!playerStates.has(username)) {
                    createPlayerModel(username);
                }
                updatePlayerList();
            }
        }

        function handlePlayerLeft(username) {
            console.log('Handling player left:', username);
            removePlayer(username);
            updatePlayerList();
        }

        // Function to handle item collection
        function handleItemCollection(itemId, playerUsername) {
            const item = collectibles.get(itemId);
            if (item) {
                // Check if item is already collected
                for (const [username, items] of playerItems.entries()) {
                    if (items.has(itemId)) {
                        console.log(`Item ${itemId} already collected by ${username}`);
                        return;
                    }
                }

                scene.remove(item.mesh);
                collectibles.delete(itemId);
                
                // Update player's collected items
                if (!playerItems.has(playerUsername)) {
                    playerItems.set(playerUsername, new Set());
                }
                playerItems.get(playerUsername).add(itemId);
                
                // Update UI
                updatePlayerList();
                
                // Play collection sound
                const audio = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU');
                audio.play().catch(() => {}); // Ignore errors if audio can't play
            }
        }

        // Function to handle player disconnection
        function handlePlayerDisconnection(username) {
            const items = playerItems.get(username);
            if (items) {
                // Drop all items at player's last position
                const playerState = playerStates.get(username);
                if (playerState) {
                    items.forEach(itemId => {
                        const color = ITEM_COLORS[itemId];
                        createCollectible(itemId, playerState.mesh.position.clone(), color);
                    });
                }
                playerItems.delete(username);
            }
        }

        // Scene setup with error handling
        try {
            // Scene initialization
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Dark background
            console.log('Scene created');

            // Create shotgun pellets with object pooling
            pelletPool = { // <-- Assign to existing variable
                pool: [],           // Array for available pellet objects
                active: new Set(),  // Set for active pellet objects (efficient add/delete)
                maxSize: PELLET_COUNT * 10, // Max pellets to pool (adjust as needed)
                isInitialized: false, // Flag to track initialization status

                // Initialize the pool - call this once after scene is created
                initialize(scene) {
                    if (this.isInitialized) return; // Prevent double initialization
                    try {
                        for (let i = 0; i < this.maxSize; i++) {
                            const pellet = this._createPelletMesh();
                            if (pellet) {
                                pellet.visible = false;
                                pellet.position.set(0, -10000, 0);
                                scene.add(pellet); // <-- Re-enable this line
                                this.pool.push(pellet);
                            }
                        }
                        this.isInitialized = true;
                    } catch (error) {
                        console.error("Error initializing pellet pool:", error);
                        this.isInitialized = false; // Ensure flag remains false on error
                    }
                },

                _createPelletMesh() {
                    const pelletGeometry = new THREE.SphereGeometry(PELLET_RADIUS, 6, 6); // Simpler geometry
                    const pelletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const pelletMesh = new THREE.Mesh(pelletGeometry, pelletMaterial);
                    pelletMesh.userData = {
                        velocity: new THREE.Vector3(),
                        birthTime: 0
                    };
                    return pelletMesh;
                },

                // Get a pellet from the pool
                get() {
                    let pellet = null;
                    if (this.pool.length > 0) {
                        pellet = this.pool.pop(); // Get from available pool
                    }
                    if (pellet) {
                        this.active.add(pellet); // Add to the active set
                        pellet.visible = true;   // Make it visible
                    }
                    return pellet;
                },

                // Release a pellet back to the pool
                release(pellet) {
                    if (this.active.delete(pellet)) { // Remove from active set (returns true if successful)
                        pellet.visible = false;         // Make invisible
                        if (pellet.userData && pellet.userData.velocity) {
                             pellet.userData.velocity.set(0, 0, 0); // Reset velocity if userData exists
                        } else {
                             console.warn("Pellet released without userData or velocity", pellet);
                        }
                        pellet.position.set(0, -10000, 0); // Move it far away
                        this.pool.push(pellet);        // Add back to the available pool
                    }
                }
            };

            // Initialize pellet pool
            pelletPool.initialize(scene); // This should now execute correctly

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 12000);
            camera.position.set(0, playerHeight, 0);
            scene.add(camera);
            console.log('Camera initialized at height:', playerHeight);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                alpha: false
            });
            
            if (!renderer.capabilities.isWebGL2) {
                throw new Error('WebGL 2 not supported');
            }
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 1);
            document.body.appendChild(renderer.domElement);
            console.log('Renderer initialized');

            // Controls setup
            controls = new PointerLockControls(camera, document.body);
            controls.minPolarAngle = 0.1; // Limit looking up (in radians)
            controls.maxPolarAngle = Math.PI - 0.1; // Limit looking down (in radians)
            controls.enableDamping = true; // Add smooth damping
            controls.dampingFactor = 0.05; // Adjust damping factor
            
            // Add camera rotation constraints
            camera.rotation.order = 'YXZ'; // Set rotation order to prevent gimbal lock
            camera.rotation.x = 0; // Reset initial rotation
            camera.rotation.z = 0; // Reset initial rotation
            
            // Add camera rotation update function
            function updateCameraRotation() {
                // Clamp vertical rotation (X axis)
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                
                // Force roll to 0 (Z axis)
                camera.rotation.z = 0;
                
                // Normalize Y rotation to prevent overflow
                camera.rotation.y = ((camera.rotation.y % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
            }
            
            // Add camera rotation update to animation loop
            const originalAnimate = animate;
            animate = function() {
                if (gameStarted && controls.isLocked) {
                    updateCameraRotation();
                }
                originalAnimate();
            };
            
            console.log('Controls initialized');

            // Collision setup
            const playerCollider = new THREE.Sphere(new THREE.Vector3(0, playerHeight, 0), playerRadius);
            const raycaster = new THREE.Raycaster();

            // Log scene state
            console.log('Initial scene state:', {
                cameraPosition: camera.position.toArray(),
                sceneChildren: scene.children.length,
                rendererSize: {
                    width: renderer.domElement.width,
                    height: renderer.domElement.height
                }
            });

            // Nebula shader
            const nebulaVertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const nebulaFragmentShader = `
                uniform float time;
                varying vec2 vUv;
                
                float rand(vec2 n) { 
                    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
                }

                float noise(vec2 p) {
                    vec2 ip = floor(p);
                    vec2 u = fract(p);
                    u = u*u*(3.0-2.0*u);
                    
                    float res = mix(
                        mix(rand(ip), rand(ip+vec2(1.0,0.0)), u.x),
                        mix(rand(ip+vec2(0.0,1.0)), rand(ip+vec2(1.0,1.0)), u.x), u.y);
                    return res*res;
                }

                vec3 getNebulaColor(float value) {
                    // Define multiple color gradients
                    vec3 deepPurple = vec3(0.3, 0.0, 0.4);
                    vec3 brightOrange = vec3(1.0, 0.4, 0.1);
                    vec3 cosmicRed = vec3(0.8, 0.1, 0.2);
                    vec3 spaceBlue = vec3(0.1, 0.3, 0.6);
                    vec3 stellarYellow = vec3(1.0, 0.8, 0.3);
                    
                    // Create dynamic color mixing based on noise value and time
                    float t1 = sin(time * 0.1) * 0.5 + 0.5;
                    float t2 = cos(time * 0.15) * 0.5 + 0.5;
                    
                    // Mix colors based on noise value
                    vec3 color;
                    if (value < 0.3) {
                        color = mix(deepPurple, spaceBlue, value * 3.33);
                    } else if (value < 0.6) {
                        color = mix(spaceBlue, cosmicRed, (value - 0.3) * 3.33);
                    } else if (value < 0.8) {
                        color = mix(cosmicRed, brightOrange, (value - 0.6) * 5.0);
                    } else {
                        color = mix(brightOrange, stellarYellow, (value - 0.8) * 5.0);
                    }
                    
                    // Add time-based color shifting
                    color = mix(color, color * vec3(t1, 1.0, t2), 0.2);
                    
                    return color;
                }

                void main() {
                    vec2 uv = vUv * 8.0;
                    
                    // Create multiple layers of noise
                    float n1 = noise(uv + time * 0.1);
                    float n2 = noise(uv * 2.0 + time * 0.05);
                    float n3 = noise(uv * 4.0 - time * 0.15);
                    
                    // Combine noise layers
                    float finalNoise = n1 * 0.5 + n2 * 0.3 + n3 * 0.2;
                    
                    // Add some swirl effect
                    float swirl = noise(uv + vec2(cos(time * 0.1), sin(time * 0.1)));
                    finalNoise = mix(finalNoise, swirl, 0.3);
                    
                    // Get complex color
                    vec3 color = getNebulaColor(finalNoise);
                    
                    // Add brightness variations
                    float brightness = 1.0 + 0.3 * sin(time * 0.2 + finalNoise * 6.28);
                    color *= brightness;
                    
                    // Calculate alpha for better cloud-like effect
                    float alpha = smoothstep(0.1, 0.9, finalNoise) * 0.6;
                    
                    // Add subtle edge glow
                    float edge = 1.0 - distance(vUv, vec2(0.5));
                    alpha *= edge * edge;
                    
                    gl_FragColor = vec4(color, alpha);
                }
            `;

            // Create nebulas
            function createNebula(position, scale, rotation) {
                const geometry = new THREE.PlaneGeometry(400, 400, 1, 1);
                const material = new THREE.ShaderMaterial({
                    vertexShader: nebulaVertexShader,
                    fragmentShader: nebulaFragmentShader,
                    uniforms: {
                        time: { value: 0 }
                    },
                    transparent: true,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });

                const nebula = new THREE.Mesh(geometry, material);
                nebula.position.copy(position);
                nebula.scale.set(scale, scale, scale);
                nebula.rotation.copy(rotation);
                scene.add(nebula);
                return nebula;
            }

            // Create multiple nebulas at different positions
            const nebulas = [];
            for (let i = 0; i < 12; i++) { // Increased number of nebulas
                const angle = (i / 12) * Math.PI * 2;
                const radius = 4500; // Tripled radius
                const position = new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.random() * 2400 - 600, // Tripled height range
                    Math.sin(angle) * radius
                );
                const scale = 4 + Math.random() * 6; // Doubled scale range for larger space
                const rotation = new THREE.Euler(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                nebulas.push(createNebula(position, scale, rotation));
            }

            // Create the floor
            const size = 6000;
            const divisions = 300; // Increased from 200 to 300 for much denser main grid
            const gridHelper = new THREE.GridHelper(size, divisions);
            gridHelper.material.opacity = 0.75; // Slightly increased opacity
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Add a second, larger grid with fewer divisions for distant floor effect
            const farSize = 12000;
            const farDivisions = 150; // Increased from 100 to 150 for denser far grid
            const farGridHelper = new THREE.GridHelper(farSize, farDivisions);
            farGridHelper.material.opacity = 0.3; // Slightly increased opacity
            farGridHelper.material.transparent = true;
            scene.add(farGridHelper);

            // Add a medium grid between the main and far grid for smoother transition
            const midSize = 9000;
            const midDivisions = 225; // Increased from 150 to 225 for denser middle grid
            const midGridHelper = new THREE.GridHelper(midSize, midDivisions);
            midGridHelper.material.opacity = 0.5; // Slightly increased opacity
            midGridHelper.material.transparent = true;
            scene.add(midGridHelper);

            // Create star field
            function createStars() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xff6600,
                    size: 2,
                    sizeAttenuation: false
                });

                const starsVertices = [];
                for (let i = 0; i < 30000; i++) { // Tripled number of stars
                    const radius = 5400; // Tripled radius
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    starsVertices.push(x, y, z);
                }

                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                const starField = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(starField);

                // Add some larger stars with different colors
                const largeStarsGeometry = new THREE.BufferGeometry();
                const largeStarsMaterial = new THREE.PointsMaterial({
                    color: 0xff8833,
                    size: 4,
                    sizeAttenuation: false
                });

                const largeStarsVertices = [];
                for (let i = 0; i < 1000; i++) {
                    const radius = 1800;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(Math.random() * 2 - 1);
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.sin(phi) * Math.sin(theta);
                    const z = radius * Math.cos(phi);
                    
                    largeStarsVertices.push(x, y, z);
                }

                largeStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(largeStarsVertices, 3));
                const largeStarField = new THREE.Points(largeStarsGeometry, largeStarsMaterial);
                scene.add(largeStarField);

                return [starField, largeStarField];
            }

            const [starField, largeStarField] = createStars();

            // Remove all client-side world generation code here
            // The world will be created when we receive world_data from the server

            // Add some ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Create the line trace
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, 0, 1)
            ]);
            const tubeGeometry = new THREE.TubeGeometry(curve, 1, 0.15, 8, false);
            const tubeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
            scene.add(tubeMesh);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            // Click to start with username
            const instructions = document.getElementById('instructions');
            const usernameInput = document.getElementById('username');
            const startButton = document.getElementById('startButton');

            // Enable/disable start button based on username input
            usernameInput.addEventListener('input', function() {
                startButton.disabled = this.value.trim().length === 0;
            });

            // Modified start button handler
            startButton.addEventListener('click', function(event) {
                event.preventDefault();
                if (usernameInput.value.trim()) {
                    playerUsername = usernameInput.value.trim();
                    gameStarted = true;
                    instructions.classList.add('hidden');
                    
                    // Send join message to server
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'join',
                            username: playerUsername
                        }));
                    }
                    
                    if (isMobile) {
                        document.querySelector('.mobile-controls').style.display = 'block';
                        document.getElementById('flingButton').style.display = 'block';
                        initializeMobileControls();
                    }
                    controls.lock();
                }
            });

            // Controls lock/unlock handlers
            controls.addEventListener('lock', function() {
                instructions.classList.add('hidden');
            });

            controls.addEventListener('unlock', function() {
                if (!isMobile) {
                    instructions.classList.remove('hidden');
                }
                
                // Notify server that player is leaving
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'player_left',
                        username: playerUsername
                    }));
                }
                
                // Remove our own player model if it exists
                removePlayer(playerUsername);
                
                // Clear all other player models
                playerStates.forEach((playerState, username) => {
                    removePlayer(username);
                });
                
                // Reset game state
                gameStarted = false;
                playerUsername = '';
                
                // Reset position
                camera.position.set(0, playerHeight, 0);
                camera.rotation.set(0, 0, 0);
                velocity.set(0, 0, 0);
                flingVelocity.set(0, 0, 0);
                verticalVelocity = 0;
                isFlinging = false;
                isGrounded = true;
                
                // Show instructions again
                instructions.classList.remove('hidden');
                usernameInput.value = '';
                startButton.disabled = true;
                
                // Clear any mobile controls if they exist
                if (isMobile) {
                    document.querySelector('.mobile-controls').style.display = 'none';
                    document.getElementById('flingButton').style.display = 'none';
                }
            });

            // Mobile controls initialization function
            function initializeMobileControls() {
                console.log('Initializing mobile controls');
                
                // Create right joystick for camera
                const rightJoystickZone = document.getElementById('rightJoystick');
                const rightJoystick = document.createElement('div');
                rightJoystick.className = 'joystick';
                rightJoystickZone.appendChild(rightJoystick);

                // Create left joystick for movement
                const leftJoystickZone = document.createElement('div');
                leftJoystickZone.className = 'joystick-zone';
                const leftJoystick = document.createElement('div');
                leftJoystick.className = 'joystick';
                leftJoystickZone.appendChild(leftJoystick);
                
                const leftControls = document.createElement('div');
                leftControls.className = 'mobile-controls left';
                leftControls.appendChild(leftJoystickZone);
                document.body.appendChild(leftControls);

                // --- Left Joystick (Movement) Logic using VirtualJoystick ---
                console.log('VirtualJoystick library type:', typeof VirtualJoystick); // Check if library is loaded
                if (typeof VirtualJoystick !== 'undefined') {
                    const moveJoystick = new VirtualJoystick({
                        container: leftJoystickZone,
                        mouseSupport: true, // Allow testing on desktop
                        limitStickTravel: true,
                        stickRadius: 50,
                    });

                    moveJoystick.addEventListener('touchStart', () => {
                         console.log('[Mobile Debug] Left Joystick Touch Start');
                         // Optional: Add visual feedback on touch start
                    });

                    moveJoystick.addEventListener('touchMove', (event) => {
                        console.log(`[Mobile Debug] Left Joystick Touch Move: dX=${moveJoystick.deltaX.toFixed(2)}, dY=${moveJoystick.deltaY.toFixed(2)}`); // Log delta values
                        const threshold = 0.2; // Adjust sensitivity
                        // Y-axis controls forward/backward
                        moveForward = moveJoystick.deltaY < -threshold;
                        moveBackward = moveJoystick.deltaY > threshold;
                        // X-axis controls left/right
                        moveLeft = moveJoystick.deltaX < -threshold;
                        moveRight = moveJoystick.deltaX > threshold;
                    });

                    moveJoystick.addEventListener('touchEnd', () => {
                        console.log('[Mobile Debug] Left Joystick Touch End'); // Log touch end
                        moveForward = false;
                        moveBackward = false;
                        moveLeft = false;
                        moveRight = false;
                    });
                } else {
                    console.error('VirtualJoystick library not loaded!');
                }
                // --- End Left Joystick Logic ---

                // Fling button setup
                const flingBtn = document.getElementById('flingButton');
                let flingStartTime = 0;
                const FLING_THRESHOLD = 200;

                // Ensure fling button is visible and properly positioned
                flingBtn.style.display = 'block';
                flingBtn.style.position = 'fixed';
                flingBtn.style.bottom = '160px';
                flingBtn.style.left = '40px';
                flingBtn.style.width = '80px';
                flingBtn.style.height = '80px';
                flingBtn.style.background = 'rgba(76, 175, 80, 0.6)';
                flingBtn.style.border = '2px solid rgba(255, 255, 255, 0.8)';
                flingBtn.style.borderRadius = '50%';
                flingBtn.style.color = 'white';
                flingBtn.style.fontSize = '32px';
                flingBtn.style.lineHeight = '80px';
                flingBtn.style.textAlign = 'center';
                flingBtn.style.pointerEvents = 'auto';
                flingBtn.style.cursor = 'pointer';
                flingBtn.style.zIndex = '1000';
                flingBtn.style.touchAction = 'none';
                flingBtn.style.transition = 'all 0.1s ease-out';
                flingBtn.style.userSelect = 'none';
                flingBtn.innerHTML = 'âš¡';

                // Add fling button event listeners
                flingBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    flingStartTime = performance.now();
                    console.log('Fling button touch started');
                    showLine = true;
                    this.classList.add('active');
                    
                    // Update line trace position
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    // Calculate start and end points
                    const startPoint = camera.position.clone().add(rightVector.multiplyScalar(2));
                    startPoint.y = camera.position.y;
                    
                    const endPoint = camera.position.clone().add(cameraDirection.multiplyScalar(50));
                    
                    // Update curve points
                    curve.points[0].copy(startPoint);
                    curve.points[1].copy(endPoint);
                    
                    // Update the tube geometry
                    const newTubeGeometry = new THREE.TubeGeometry(curve, 1, 0.08, 8, false);
                    tubeMesh.geometry.dispose();
                    tubeMesh.geometry = newTubeGeometry;
                    tubeMesh.visible = true;
                }, { passive: false });

                flingBtn.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                    if (!showLine) return;
                    
                    // Update line trace position
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    // Calculate start and end points
                    const startPoint = camera.position.clone().add(rightVector.multiplyScalar(2));
                    startPoint.y = camera.position.y;
                    
                    const endPoint = camera.position.clone().add(cameraDirection.multiplyScalar(50));
                    
                    // Update curve points
                    curve.points[0].copy(startPoint);
                    curve.points[1].copy(endPoint);
                    
                    // Update the tube geometry
                    const newTubeGeometry = new THREE.TubeGeometry(curve, 1, 0.08, 8, false);
                    tubeMesh.geometry.dispose();
                    tubeMesh.geometry = newTubeGeometry;

                    // Check for line collision with towers
                    raycaster.set(startPoint, cameraDirection);
                    const intersects = [];
                    towers.forEach(tower => {
                        const towerIntersects = raycaster.intersectObject(tower.mesh);
                        if (towerIntersects.length > 0 && towerIntersects[0].distance <= 500) { // Increased from 330 to 500
                            intersects.push(towerIntersects[0]);
                        }
                    });

                    // Sort intersections by distance and get the closest one
                    if (intersects.length > 0) {
                        intersects.sort((a, b) => a.distance - b.distance);
                        lineCollisionPoint = intersects[0].point;
                        
                        // Update line end point to collision point
                        curve.points[1].copy(lineCollisionPoint);
                        const collidedTubeGeometry = new THREE.TubeGeometry(curve, 1, 0.08, 8, false);
                        tubeMesh.geometry.dispose();
                        tubeMesh.geometry = collidedTubeGeometry;
                        
                        // Change line color to indicate valid target
                        tubeMaterial.color.setHex(0x00ff00);
                    } else {
                        lineCollisionPoint = null;
                        // Change line color to indicate no target
                        tubeMaterial.color.setHex(0xff0000);
                    }
                }, { passive: false });

                flingBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    const touchDuration = performance.now() - flingStartTime;
                    console.log('Fling button touch ended');
                    showLine = false;
                    tubeMesh.visible = false;
                    this.classList.remove('active');
                    
                    if (lineCollisionPoint) {
                        console.log('Initiating fling with collision point:', lineCollisionPoint);
                        const flingDirection = lineCollisionPoint.clone().sub(camera.position).normalize();
                        const distanceToTarget = camera.position.distanceTo(lineCollisionPoint);
                        
                        // Match desktop fling strength calculation exactly
                        const scaledStrength = Math.min(distanceToTarget * 0.09, flingStrength * 1.4);
                        
                        // Set fling velocity with proper strength
                        flingVelocity.x = flingDirection.x * scaledStrength;
                        flingVelocity.z = flingDirection.z * scaledStrength;
                        verticalVelocity = flingDirection.y * scaledStrength + 0.5;
                        
                        // Set fling state
                        isFlinging = true;
                        isGrounded = false;
                        
                        // Clear line collision point
                        lineCollisionPoint = null;
                        
                        // Apply initial fling velocity immediately
                        camera.position.x += flingVelocity.x;
                        camera.position.z += flingVelocity.z;
                        camera.position.y += verticalVelocity;
                        
                        // Apply damping to horizontal movement
                        flingVelocity.x *= flingDamping;
                        flingVelocity.z *= flingDamping;
                        
                        // Force camera position update
                        camera.position.y += verticalVelocity;
                        
                        // Apply gravity immediately
                        verticalVelocity -= gravity;
                        
                        console.log('Fling initiated with velocity:', flingVelocity);
                    }
                }, { passive: false });

                // Camera control variables
                let rightTouchStartX = 0;
                let rightTouchStartY = 0;
                let rightJoystickX = 0;
                let rightJoystickY = 0;
                let isRightTouching = false;
                const rightMaxDistance = 35;
                let lastUpdateTime = 0;
                const updateInterval = 1000 / 60;
                let cameraVelocity = new THREE.Vector2();
                const CAMERA_ACCELERATION = 0.15; // Halved sensitivity
                const CAMERA_DECELERATION = 0.8;
                const MAX_CAMERA_SPEED = 0.025; // Halved sensitivity

                // Movement control variables
                let leftTouchStartX = 0;
                let leftTouchStartY = 0;
                let leftJoystickX = 0;
                let leftJoystickY = 0;
                let isLeftTouching = false;
                const leftMaxDistance = 35;
                let movementVelocity = new THREE.Vector2();
                const MOVEMENT_ACCELERATION = 0.3;
                const MOVEMENT_DECELERATION = 0.85;
                const MAX_MOVEMENT_SPEED = 0.05;

                // Right joystick touch handlers
                rightJoystickZone.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    e.stopPropagation(); // Try stopping propagation
                    const touch = e.touches[0];
                    rightTouchStartX = touch.clientX;
                    rightTouchStartY = touch.clientY;
                    isRightTouching = true;
                    rightJoystick.style.transition = 'none';
                    console.log('Right touch started');
                }, { passive: false });

                rightJoystickZone.addEventListener('touchmove', function(e) {
                    if (!isRightTouching) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const currentTime = performance.now();
                    
                    if (currentTime - lastUpdateTime < updateInterval) return;
                    lastUpdateTime = currentTime;
                    
                    const deltaX = touch.clientX - rightTouchStartX;
                    const deltaY = touch.clientY - rightTouchStartY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Apply exponential smoothing to joystick movement
                    const smoothing = 0.5;
                    const targetX = distance > rightMaxDistance ? (deltaX / distance) * rightMaxDistance : deltaX;
                    const targetY = distance > rightMaxDistance ? (deltaY / distance) * rightMaxDistance : deltaY;
                    
                    rightJoystickX += (targetX - rightJoystickX) * smoothing;
                    rightJoystickY += (targetY - rightJoystickY) * smoothing;
                    
                    // Update joystick position
                    rightJoystick.style.left = `${rightJoystickX + 60}px`;
                    rightJoystick.style.top = `${rightJoystickY + 60}px`;
                    
                    // Calculate camera velocity with acceleration
                    const targetVelocityX = (rightJoystickX / rightMaxDistance) * MAX_CAMERA_SPEED;
                    const targetVelocityY = (rightJoystickY / rightMaxDistance) * MAX_CAMERA_SPEED;
                    
                    cameraVelocity.x += (targetVelocityX - cameraVelocity.x) * CAMERA_ACCELERATION;
                    cameraVelocity.y += (targetVelocityY - cameraVelocity.y) * CAMERA_ACCELERATION;
                    
                    // Apply camera rotation with constraints
                    const currentRotationX = camera.rotation.x;
                    const newRotationX = currentRotationX - cameraVelocity.y;
                    
                    // Clamp vertical rotation to prevent over-rotation
                    if (newRotationX > -Math.PI/2 && newRotationX < Math.PI/2) {
                        camera.rotation.x = newRotationX;
                    }
                    
                    // Apply horizontal rotation
                    camera.rotation.y -= cameraVelocity.x;
                    
                    // Force roll to 0
                    camera.rotation.z = 0;
                    
                    console.log('Right touch moved:', rightJoystickX, rightJoystickY);
                }, { passive: false });

                rightJoystickZone.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    isRightTouching = false;
                    rightJoystick.style.transition = 'transform 0.2s ease-out';
                    rightJoystickX = 0;
                    rightJoystickY = 0;
                    rightJoystick.style.left = '60px';
                    rightJoystick.style.top = '60px';
                    console.log('Right touch ended');
                }, { passive: false });

                // Left joystick touch handlers
                leftJoystickZone.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    leftTouchStartX = touch.clientX;
                    leftTouchStartY = touch.clientY;
                    isLeftTouching = true;
                    leftJoystick.style.transition = 'none';
                    console.log('Left touch started');
                }, { passive: false });

                leftJoystickZone.addEventListener('touchmove', function(e) {
                    if (!isLeftTouching) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    const currentTime = performance.now();
                    
                    if (currentTime - lastUpdateTime < updateInterval) return;
                    lastUpdateTime = currentTime;
                    
                    const deltaX = touch.clientX - leftTouchStartX;
                    const deltaY = touch.clientY - leftTouchStartY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    // Apply exponential smoothing to joystick movement
                    const smoothing = 0.5;
                    const targetX = distance > leftMaxDistance ? (deltaX / distance) * leftMaxDistance : deltaX;
                    const targetY = distance > leftMaxDistance ? (deltaY / distance) * leftMaxDistance : deltaY;
                    
                    leftJoystickX += (targetX - leftJoystickX) * smoothing;
                    leftJoystickY += (targetY - leftJoystickY) * smoothing;
                    
                    // Update joystick position
                    leftJoystick.style.left = `${leftJoystickX + 60}px`;
                    leftJoystick.style.top = `${leftJoystickY + 60}px`;
                    
                    // Calculate movement velocity with acceleration
                    const targetVelocityX = (leftJoystickX / leftMaxDistance) * MAX_MOVEMENT_SPEED;
                    const targetVelocityY = (leftJoystickY / leftMaxDistance) * MAX_MOVEMENT_SPEED;
                    
                    movementVelocity.x += (targetVelocityX - movementVelocity.x) * MOVEMENT_ACCELERATION;
                    movementVelocity.y += (targetVelocityY - movementVelocity.y) * MOVEMENT_ACCELERATION;
                    
                    // Get camera direction vectors
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    // Calculate movement relative to camera direction
                    // Forward/backward movement (Y axis of joystick)
                    const forwardMovement = movementVelocity.y * cameraDirection;
                    // Left/right movement (X axis of joystick)
                    const rightMovement = movementVelocity.x * rightVector;
                    
                    // Combine movements
                    velocity.x = forwardMovement.x + rightMovement.x;
                    velocity.z = forwardMovement.z + rightMovement.z;
                    
                    console.log('Left touch moved:', leftJoystickX, leftJoystickY);
                }, { passive: false });

                leftJoystickZone.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    isLeftTouching = false;
                    leftJoystick.style.transition = 'transform 0.2s ease-out';
                    leftJoystickX = 0;
                    leftJoystickY = 0;
                    leftJoystick.style.left = '60px';
                    leftJoystick.style.top = '60px';
                    console.log('Left touch ended');
                }, { passive: false });

                // Update camera and movement in animation loop
                function updateControls() {
                    // Apply camera deceleration
                    if (!isRightTouching) {
                        cameraVelocity.multiplyScalar(CAMERA_DECELERATION);
                        camera.rotation.y -= cameraVelocity.x;
                        camera.rotation.x -= cameraVelocity.y;
                    }
                    
                    // Apply movement deceleration
                    if (!isLeftTouching) {
                        movementVelocity.multiplyScalar(MOVEMENT_DECELERATION);
                        velocity.x *= MOVEMENT_SMOOTHING;
                        velocity.z *= MOVEMENT_SMOOTHING;
                    }
                    
                    requestAnimationFrame(updateControls);
                }
                updateControls();
            }

            // Desktop controls
            if (!isMobile) {
                // Movement controls
                const onKeyDown = function(event) {
                    switch (event.code) {
                        case 'ArrowUp':
                        case 'KeyW':
                            moveForward = true;
                            break;
                        case 'ArrowDown':
                        case 'KeyS':
                            moveBackward = true;
                            break;
                        case 'ArrowLeft':
                        case 'KeyA':
                            moveLeft = true;
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            moveRight = true;
                            break;
                        case 'KeyE':
                            showLine = true;
                            break;
                        case 'KeyZ':
                            document.getElementById('playerList').classList.add('visible');
                            updatePlayerList(); // Update immediately when showing
                            break;
                    }
                };

                const onKeyUp = function(event) {
                    switch (event.code) {
                        case 'ArrowUp':
                        case 'KeyW':
                            moveForward = false;
                            break;
                        case 'ArrowDown':
                        case 'KeyS':
                            moveBackward = false;
                            break;
                        case 'ArrowLeft':
                        case 'KeyA':
                            moveLeft = false;
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            moveRight = false;
                            break;
                        case 'KeyE':
                            showLine = false;
                            break;
                        case 'KeyZ':
                            document.getElementById('playerList').classList.remove('visible');
                            break;
                    }
                };

                // Mouse controls for line visibility
                document.addEventListener('mousedown', (event) => {
                    if (event.button === 0) { // Left mouse button
                        showLine = true;
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (event.button === 0) { // Left mouse button
                        showLine = false;
                    }
                });

                document.addEventListener('keydown', onKeyDown);
                document.addEventListener('keyup', onKeyUp);
            }

            // Initialize the pellet pool
            pelletPool.initialize(scene);

            // Define updatePellets function after pelletPool is initialized
            function updatePellets(deltaTime) { // Renamed and takes deltaTime
                // GUARD CLAUSE: Ensure pool is initialized and has active pellets
                if (!pelletPool.isInitialized || pelletPool.active.size === 0) {
                    return; 
                }

                const currentTime = performance.now(); // Use performance.now() for consistency

                // Iterate over a copy of the active set to avoid issues when removing items
                const activePellets = new Set(pelletPool.active); 

                activePellets.forEach(pellet => {
                    // Check if pellet still exists in the main active set (might have been removed)
                    if (!pelletPool.active.has(pellet)) {
                        return;
                    }

                    // Check if pellet has expired
                    if (currentTime - pellet.userData.spawnTime > PELLET_LIFETIME) { // <-- Corrected variable
                        pelletPool.release(pellet);
                        return; // Stop processing this pellet
                    }

                    // Store last position for collision detection
                    // Ensure lastPosition exists before copying
                    if (!pellet.lastPosition) {
                        pellet.lastPosition = new THREE.Vector3();
                    }
                    pellet.lastPosition.copy(pellet.position);

                    // Apply gravity (framerate independent)
                    // Ensure velocity exists in userData
                    if (!pellet.userData.velocity) {
                        pellet.userData.velocity = new THREE.Vector3(); // Initialize if missing
                    }
                    // Apply gravity to userData velocity
                    pellet.userData.velocity.y -= PELLET_GRAVITY * deltaTime;

                    // Apply friction (framerate independent) to userData velocity
                    const effectivePelletFriction = Math.pow(PELLET_FRICTION, deltaTime * 60);
                    pellet.userData.velocity.multiplyScalar(effectivePelletFriction);

                    // Calculate potential next position using userData velocity
                    const deltaPosition = pellet.userData.velocity.clone().multiplyScalar(deltaTime);
                    const nextPosition = pellet.position.clone().add(deltaPosition);


                    // --- Simple Raycast Collision Check ---
                    const rayDirection = deltaPosition.clone().normalize(); // Based on userData velocity
                    const rayLength = deltaPosition.length();
                    
                    // Only cast if moving significantly
                    if (rayLength > 0.001) { 
                        const pelletRaycaster = new THREE.Raycaster(pellet.position, rayDirection, 0, rayLength + PELLET_RADIUS);
                        
                        // Objects to check collisions against (towers and bridges)
                        const collisionObjects = towers.map(t => t.mesh).concat(bridges.map(b => b.mesh)); 
                        const intersects = pelletRaycaster.intersectObjects(collisionObjects, true); // Check recursively

                        let hit = false;
                        if (intersects.length > 0) {
                            const intersect = intersects[0]; // Closest intersection
                            if (intersect.distance <= rayLength + PELLET_RADIUS) {
                                 hit = true;
                                // Collision Response
                                if (pellet.userData.bounces >= PELLET_MAX_BOUNCES) { // Use userData bounces
                                    pelletPool.release(pellet);
                                    return; // Stop processing this pellet
                                } else {
                                    // Move pellet to collision point (approximately)
                                    pellet.position.copy(intersect.point).addScaledVector(intersect.face.normal, PELLET_RADIUS * 0.1); // Move slightly off surface

                                    // Reflect velocity in userData
                                    const normal = intersect.face.normal;
                                    pellet.userData.velocity.reflect(normal);

                                    // Apply bounce and friction to reflected velocity in userData
                                    pellet.userData.velocity.multiplyScalar(PELLET_BOUNCE * PELLET_FRICTION);

                                    pellet.userData.bounces++; // Increment userData bounces
                                }
                            }
                        }

                        // If no collision detected by raycast, update position normally
                        if (!hit) {
                             pellet.position.copy(nextPosition);
                        }

                    } else {
                         // If not moving much, just update position directly (handles settling)
                         pellet.position.copy(nextPosition);
                    }
                    // --- End Simple Raycast Collision Check ---


                    // Check for collisions with players
                    playerStates.forEach((playerState, username) => {
                        // Skip self-collision or if player mesh doesn't exist yet
                        if (username === playerUsername || !playerState.mesh) return; 

                        const distance = pellet.position.distanceTo(playerState.mesh.position);

                        if (distance < playerRadius + PELLET_RADIUS) {
                            // Player was hit
                            console.log(`Pellet hit player: ${username}`); // Add log
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'player_damaged',
                                    victimUsername: username, // Send victim's username
                                    attackerUsername: playerUsername, // Send attacker's username
                                    damage: SHOTGUN_DAMAGE 
                                }));
                                console.log(`Sent player_damaged message for ${username}`); // Confirm message sent
                            }
                            pelletPool.release(pellet);
                            return; // Stop processing this pellet after hit
                        }
                    });

                    // Remove pellet if it's fallen too far (check after potential collision response)
                    if (pelletPool.active.has(pellet) && pellet.position.y < -1000) {
                        pelletPool.release(pellet);
                    }
                });
            }

            // Animation loop with collision detection, star rotation, and nebula animation
            function animate() {
                requestAnimationFrame(animate);

                const deltaTime = clock.getDelta();
                const currentTime = performance.now();

                // Update pellets
                updatePellets(deltaTime); // Pass deltaTime

                if (gameStarted) {
                    // Update frustum for culling
                    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                    frustum.setFromProjectionMatrix(projScreenMatrix);
                    
                    // Update other players' positions with throttling
                    if (currentTime - lastCollisionCheck > COLLISION_CHECK_INTERVAL) {
                        playerStates.forEach((playerState, username) => {
                            if (username !== playerUsername) {
                                const timeSinceUpdate = Date.now() - playerState.lastUpdateTime;
                                if (timeSinceUpdate > 5000) {
                                    removePlayer(username);
                                } else {
                                    playerState.update(deltaTime);
                                }
                            }
                        });
                        lastCollisionCheck = currentTime;
                    }
                    
                    // Update nebula animations (framerate independent)
                    const time = currentTime * 0.001; // Keep time for shader effects if needed
                    nebulas.forEach((nebula, index) => {
                        if (nebula && nebula.material && nebula.material.uniforms) {
                            nebula.material.uniforms.time.value = time;
                            // Scale rotation and position changes by deltaTime
                            const nebulaRotSpeed = 0.01; // Adjust speed as needed
                            const nebulaDriftSpeed = 0.5; // Adjust speed as needed
                            nebula.rotation.y += nebulaRotSpeed * deltaTime;
                            nebula.rotation.x += (nebulaRotSpeed * 0.5) * deltaTime;
                            nebula.position.y += Math.sin(time * 0.1 + index) * nebulaDriftSpeed * deltaTime;
                            nebula.position.x += Math.cos(time * 0.15 + index) * nebulaDriftSpeed * deltaTime;
                        }
                    });

                    // Rotate star fields (framerate independent)
                    // Define base rotation speeds (radians per second)
                    const starFieldSpeed = 0.005;
                    const largeStarFieldSpeed = 0.003;
                    
                    if (starField) {
                        starField.rotation.y += starFieldSpeed * deltaTime; // Use deltaTime
                    }
                    if (largeStarField) {
                        largeStarField.rotation.y += largeStarFieldSpeed * deltaTime; // Use deltaTime
                    }

                    // Update nebula opacity (example - add your nebula logic here if needed)
                    // if (nebulaMaterial) { ... }

                    // Only process movement and game logic if controls are locked and game is started
                    if (controls.isLocked && gameStarted) {

                        // --- Store Position Before Movement for Collision Check ---
                        const positionBeforeFrame = camera.position.clone();

                        // --- Calculate Input Direction ---
                        const inputDirection = new THREE.Vector3();
                        inputDirection.z = Number(moveForward) - Number(moveBackward);
                        inputDirection.x = Number(moveRight) - Number(moveLeft);
                        inputDirection.normalize(); // Ensure consistent speed diagonally

                        // --- MOBILE DEBUG LOG START ---
                        if (isMobile && (moveForward || moveBackward || moveLeft || moveRight)) {
                           console.log(`[Mobile Debug Animate] Flags: F=${moveForward}, B=${moveBackward}, L=${moveLeft}, R=${moveRight}`);
                        }
                        // --- MOBILE DEBUG LOG END ---

                        // --- Calculate Movement Distance for this Frame ---
                        // Treat moveSpeed as units per second
                        const moveDistanceZ = inputDirection.z * moveSpeed * deltaTime;
                        const moveDistanceX = inputDirection.x * moveSpeed * deltaTime;

                        // --- Apply Movement using PointerLockControls ---
                        // This handles movement relative to camera orientation
                        controls.moveForward(moveDistanceZ); 
                        controls.moveRight(moveDistanceX);
                        // NOTE: We are no longer using the separate 'velocity' vector for WASD

                        // --- Collision Check Block (Uses positionBeforeFrame) ---
                        playerCollider.center.copy(positionBeforeFrame); // Check based on where we *were*
                        const movementCollision = checkCollision(positionBeforeFrame, playerRadius);
                        
                        if (movementCollision.collision) {
                            // --- Define pushDir early, it's needed for multiple conditions ---
                            const pushDir = new THREE.Vector3();
                            pushDir.copy(positionBeforeFrame).sub(movementCollision.closestPoint).normalize();
                            const distance = positionBeforeFrame.distanceTo(movementCollision.closestPoint);
                            const pushDistance = playerRadius - distance; // Penetration depth
                            
                            const isStuck = distance < playerRadius * STUCK_THRESHOLD;
                            
                            if (isStuck) {
                                // Player is stuck, apply stronger push-out force (immediate correction, no delta)
                                // pushDir is already calculated
                                camera.position.x += pushDir.x * (playerRadius * STUCK_PUSH_FORCE); // Apply specific stuck force
                                camera.position.z += pushDir.z * (playerRadius * STUCK_PUSH_FORCE);

                                // Add upward velocity impulse to help escape
                                verticalVelocity = 0.3; // Reduced from 1.0
                                isGrounded = false;

                                // Modify horizontal velocity for escape
                                if (isFlinging) {
                                    const flingSpeed = Math.sqrt(flingVelocity.x * flingVelocity.x + flingVelocity.z * flingVelocity.z);
                                    flingVelocity.x = pushDir.x * flingSpeed * 2.0;
                                    flingVelocity.z = pushDir.z * flingSpeed * 2.0;
                                } 
                                // No else needed for velocity here, as WASD velocity isn't used
                            } else {
                                // Normal collision response (not stuck)
                                // pushDir and pushDistance are already calculated
                                
                                // Store vertical velocity *before* potential gravity application
                                const verticalVelocityBeforeCheck = verticalVelocity;

                                // Check if hitting an underside while moving up
                                if (pushDir.y < -0.1 && verticalVelocityBeforeCheck > 0) {
                                    // Log hitting underside
                                    console.log('Collision: Hitting underside', { pushDirY: pushDir.y, verticalVelocityPreCheck: verticalVelocityBeforeCheck });

                                    // Stop upward movement immediately
                                    verticalVelocity = 0;
                                    isGrounded = false;

                                    // Apply full 3D push-out using pre-calculated pushDistance
                                    camera.position.addScaledVector(pushDir, pushDistance * COLLISION_PUSH_FORCE);

                                    // Dampen horizontal velocity after hitting ceiling
                                    if (isFlinging) {
                                        flingVelocity.x *= 0.5;
                                        flingVelocity.z *= 0.5;
                                    } 
                                    // No else needed for velocity here
                                } else {
                                    // Standard collision response (horizontal push/sliding)
                                    // Log standard collision
                                    console.log('Collision: Standard horizontal', { pushDirY: pushDir.y, verticalVelocityPreCheck: verticalVelocityBeforeCheck, isFlinging: isFlinging });

                                    // Apply horizontal push-out using pre-calculated pushDistance
                                    const horizontalPushForce = isFlinging ? COLLISION_PUSH_FORCE * 1.5 : COLLISION_PUSH_FORCE;
                                    camera.position.x += pushDir.x * pushDistance * horizontalPushForce;
                                    camera.position.z += pushDir.z * pushDistance * horizontalPushForce;

                                    // Adjust velocities based on collision (Sliding / Reflection)
                                    const horizontalPushNormal = new THREE.Vector3(pushDir.x, 0, pushDir.z).normalize();
                                    if (isFlinging) {
                                        // Fling reflection/dampening - OK
                                        const speed = Math.sqrt(flingVelocity.x * flingVelocity.x + flingVelocity.z * flingVelocity.z);
                                        const dot = flingVelocity.x * horizontalPushNormal.x + flingVelocity.z * horizontalPushNormal.z;
                                        if (dot < 0) { 
                                          flingVelocity.x -= 2 * dot * horizontalPushNormal.x * 0.8; 
                                          flingVelocity.z -= 2 * dot * horizontalPushNormal.z * 0.8;
                                        }
                                        flingVelocity.multiplyScalar(0.8); 
                                    } 
                                    // No else for normal velocity sliding needed anymore
                                }
                            }
                        } // End of movementCollision response block
                        // --- [End Collision Response Block] ---

                        // --- Movement Update --- 
                        // NO LONGER NEEDED for WASD - PointerLockControls handles it
                        // Remove calculation of moveVector, totalVelocityX/Z 
                        // Remove camera.position.x += totalVelocityX * deltaTime; etc.

                        // --- Vertical Movement & Gravity --- (Largely unchanged)
                        if (!isGrounded) {
                            // Apply gravity (framerate independent)
                            // ... (gravity logic - check if needs adjustment without velocity interaction in collision)
                            verticalVelocity -= gravity * deltaTime;
                        } else {
                            verticalVelocity = 0; 
                        }
                        // Apply vertical velocity (framerate independent)
                        // Fling velocity is handled separately
                        let verticalMove = verticalVelocity * deltaTime;
                        if(isFlinging) {
                             // Assuming flingVelocity includes Y component for initial jump
                             // Need to handle fling vertical movement
                             // This might need adjustment - let's keep simple verticalVelocity for now
                        }
                        camera.position.y += verticalMove;

                        // --- Fling Horizontal Movement --- (Apply separately if needed)
                        if (isFlinging) {
                           camera.position.x += flingVelocity.x * deltaTime;
                           camera.position.z += flingVelocity.z * deltaTime;
                           // Damping applied later
                        }

                        // --- Ground Check --- (Unchanged)
                        // ...

                        // --- Damping / Friction --- 
                        // Apply damping ONLY to fling velocity 
                        if (isFlinging) {
                            const effectiveFlingDamping = Math.pow(flingDamping, deltaTime * 60);
                            flingVelocity.x *= effectiveFlingDamping;
                            flingVelocity.z *= effectiveFlingDamping;
                            if (flingVelocity.lengthSq() < 0.001) {
                                isFlinging = false;
                                flingVelocity.set(0, 0, 0);
                            }
                        }
                        // Remove normal velocity damping (velocity no longer used for WASD)

                        // --- Final Updates for Frame --- (Unchanged)
                        playerCollider.center.copy(camera.position); // Update collider to final position
                        // ... (Orb check etc) ...

                    } // End of if (controls.isLocked && gameStarted)

                    // Update line trace position
                    const cameraDirection = new THREE.Vector3();
                    camera.getWorldDirection(cameraDirection);
                    const rightVector = new THREE.Vector3();
                    rightVector.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0)).normalize();
                    
                    // Update line visibility
                    tubeMesh.visible = showLine;
                    
                    if (showLine) {
                        // Calculate start and end points
                        const startPoint = camera.position.clone().add(rightVector.multiplyScalar(2));
                        startPoint.y = camera.position.y;
                        
                        const endPoint = camera.position.clone().add(cameraDirection.multiplyScalar(200)); // Increased from 50 to 200
                        
                        // Update curve points
                        curve.points[0].copy(startPoint);
                        curve.points[1].copy(endPoint);
                        
                        // Update the tube geometry
                        const newTubeGeometry = new THREE.TubeGeometry(curve, 1, 0.08, 8, false);
                        tubeMesh.geometry.dispose();
                        tubeMesh.geometry = newTubeGeometry;

                        // Check for line collision with towers
                        raycaster.set(startPoint, cameraDirection);
                        const intersects = [];
                        towers.forEach(tower => {
                            const towerIntersects = raycaster.intersectObject(tower.mesh);
                            if (towerIntersects.length > 0 && towerIntersects[0].distance <= 430) { // Increased from 330 to 500
                                intersects.push(towerIntersects[0]);
                            }
                        });

                        // Sort intersections by distance and get the closest one
                        if (intersects.length > 0) {
                            intersects.sort((a, b) => a.distance - b.distance);
                            lineCollisionPoint = intersects[0].point;
                            
                            // Update line end point to collision point
                            curve.points[1].copy(lineCollisionPoint);
                            const collidedTubeGeometry = new THREE.TubeGeometry(curve, 1, 0.08, 8, false);
                            tubeMesh.geometry.dispose();
                            tubeMesh.geometry = collidedTubeGeometry;
                            
                            // Change line color to indicate valid target
                            tubeMaterial.color.setHex(0x00ff00);
                        } else {
                            lineCollisionPoint = null;
                            // Change line color to indicate no target
                            tubeMaterial.color.setHex(0xff0000);
                        }
                    } else if (lineCollisionPoint) {
                        // Initiate fling when line is released and we had a collision point
                        const flingDirection = lineCollisionPoint.clone().sub(camera.position).normalize();
                        
                        // Increase fling strength based on distance to target, but more gently
                        const distanceToTarget = camera.position.distanceTo(lineCollisionPoint);
                        const scaledStrength = Math.min(distanceToTarget * 0.09, flingStrength * 1.4);
                        
                        // Set velocity components
                        flingVelocity.x = flingDirection.x * scaledStrength;
                        flingVelocity.z = flingDirection.z * scaledStrength;
                        verticalVelocity = flingDirection.y * scaledStrength + 0.5;
                        
                        isFlinging = true;
                        isGrounded = false;
                        lineCollisionPoint = null;
                    }

                    // Apply fling velocity if active
                    if (isFlinging) {
                        // Move in world space
                        camera.position.x += flingVelocity.x;
                        camera.position.z += flingVelocity.z;
                        camera.position.y += verticalVelocity;

                        // Apply gravity
                        verticalVelocity -= gravity;

                        // Update player collider position
                        playerCollider.center.copy(camera.position);

                        // Check collisions with all towers
                        const movementCollision = checkCollision(camera.position, playerRadius);
                        
                        // If there's a collision during fling, push out and continue
                        if (movementCollision.collision) {
                            if (isFlinging) {
                                // During fling, push out strongly and redirect velocity
                                const pushDir = new THREE.Vector3();
                                pushDir.copy(camera.position).sub(movementCollision.closestPoint).normalize();
                                
                                // Push out with a stronger force
                                const pushDistance = playerRadius - movementCollision.distance;
                                camera.position.x += pushDir.x * pushDistance * COLLISION_PUSH_FORCE;
                                camera.position.z += pushDir.z * pushDistance * COLLISION_PUSH_FORCE;
                                
                                // Normal collision response for all objects
                                const speed = Math.sqrt(flingVelocity.x * flingVelocity.x + flingVelocity.z * flingVelocity.z);
                                
                                // Add corner sliding effect
                                const dotProduct = pushDir.x * flingVelocity.x + pushDir.z * flingVelocity.z;
                                if (dotProduct < 0) {
                                    // We're moving towards the collision, apply stronger bounce
                                    flingVelocity.x = pushDir.x * speed * 0.8;
                                    flingVelocity.z = pushDir.z * speed * 0.8;
                                } else {
                                    // We're moving along the surface, apply sliding
                                    flingVelocity.x = pushDir.x * speed * CORNER_SLIDE_FORCE;
                                    flingVelocity.z = pushDir.z * speed * CORNER_SLIDE_FORCE;
                                }
                                
                                // Add upward velocity for bounce
                                verticalVelocity = Math.abs(verticalVelocity) * 0.8;
                            }
                        }

                        // Apply damping to horizontal movement
                        flingVelocity.x *= flingDamping;
                        flingVelocity.z *= flingDamping;

                        // Check for ground collision
                        if (camera.position.y <= playerHeight) {
                            camera.position.y = playerHeight;
                            verticalVelocity = 0;
                            isGrounded = true;
                            isFlinging = false;
                            flingVelocity.set(0, 0, 0);
                        }

                        // Stop flinging when velocity is very small
                        if (Math.abs(flingVelocity.x) < 0.001 && Math.abs(flingVelocity.z) < 0.001) {
                            isFlinging = false;
                            flingVelocity.set(0, 0, 0);
                        }
                    }

                    // Apply gravity and handle ground collision
                    if (!isGrounded) {
                        verticalVelocity -= gravity;
                        camera.position.y += verticalVelocity;

                        // Update player collider position
                        playerCollider.center.copy(camera.position);

                        // Check collisions after vertical movement
                        const verticalCollision = checkCollision(camera.position, playerRadius);
                        if (verticalCollision.collision) {
                            if (isFlinging) {
                                // During fling, push out strongly and redirect velocity
                                const pushDir = new THREE.Vector3();
                                pushDir.copy(camera.position).sub(verticalCollision.closestPoint).normalize();
                                
                                // Push out with a stronger force
                                const pushDistance = playerRadius - verticalCollision.distance;
                                camera.position.x += pushDir.x * pushDistance * COLLISION_PUSH_FORCE;
                                camera.position.z += pushDir.z * pushDistance * COLLISION_PUSH_FORCE;
                                
                                // Normal collision response for all objects
                                const speed = Math.sqrt(flingVelocity.x * flingVelocity.x + flingVelocity.z * flingVelocity.z);
                                
                                // Add corner sliding effect
                                const dotProduct = pushDir.x * flingVelocity.x + pushDir.z * flingVelocity.z;
                                if (dotProduct < 0) {
                                    // We're moving towards the collision, apply stronger bounce
                                    flingVelocity.x = pushDir.x * speed * 0.8;
                                    flingVelocity.z = pushDir.z * speed * 0.8;
                                } else {
                                    // We're moving along the surface, apply sliding
                                    flingVelocity.x = pushDir.x * speed * CORNER_SLIDE_FORCE;
                                    flingVelocity.z = pushDir.z * speed * CORNER_SLIDE_FORCE;
                                }
                                
                                // Add upward velocity for bounce
                                verticalVelocity = Math.abs(verticalVelocity) * 0.8;
                            } else {
                                // During normal movement, push out smoothly
                                const pushDir = new THREE.Vector3();
                                pushDir.copy(camera.position).sub(verticalCollision.closestPoint).normalize();
                                
                                // Push out with a smoother force
                                const pushDistance = playerRadius - verticalCollision.distance;
                                camera.position.x += pushDir.x * pushDistance * COLLISION_PUSH_FORCE;
                                camera.position.z += pushDir.z * pushDistance * COLLISION_PUSH_FORCE;
                                
                                // Add corner sliding for normal movement
                                const dotProduct = pushDir.x * velocity.x + pushDir.z * velocity.z;
                                if (dotProduct < 0) {
                                    // We're moving towards the collision, stop movement
                                    velocity.x = 0;
                                    velocity.z = 0;
                                } else {
                                    // We're moving along the surface, apply sliding
                                    velocity.x = pushDir.x * Math.abs(velocity.x) * CORNER_SLIDE_FORCE;
                                    velocity.z = pushDir.z * Math.abs(velocity.z) * CORNER_SLIDE_FORCE;
                                }
                                
                                // Remove special bridge handling - treat all collisions the same
                                const currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
                                if (currentSpeed > 0.1) { // Only apply bounce if we have significant speed
                                    const bounceStrength = 0.8; // Consistent bounce for all objects
                                    velocity.x = pushDir.x * currentSpeed * bounceStrength;
                                    velocity.z = pushDir.z * currentSpeed * bounceStrength;
                                    // Further reduced bounce factors
                                    verticalVelocity = Math.max(currentSpeed * 0.15, 0.1); // Was 0.25, 0.2
                                    isGrounded = false;
                                }
                            }
                        }

                        // Check for ground collision
                        if (camera.position.y <= playerHeight) {
                            camera.position.y = playerHeight;
                            verticalVelocity = 0;
                            isGrounded = true;
                        }
                    }

                    // Update player collider position for final position
                    playerCollider.center.copy(camera.position);

                    // Check for orb collisions
                    // --- DEBUG LOGGING START ---
                    if (isMobile) {
                        console.log(`[Mobile Debug] Checking orb collision. Orbs count: ${orbs.size}, Player Pos: ${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`);
                    }
                    // --- DEBUG LOGGING END ---
                    const orbCollision = checkOrbCollision(camera.position, playerRadius);
                    if (orbCollision) {
                        // Send collection message to server
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'collect_orb',
                                orbId: orbCollision.orbId
                            }));
                            
                            // Remove orb from scene and collection
                            scene.remove(orbCollision.orb);
                            orbs.delete(orbCollision.orbId);
                            
                            // Update local orb count
                            const currentOrbs = playerOrbs.get(playerUsername) || 0;
                            playerOrbs.set(playerUsername, currentOrbs + 1);
                            updateOrbCount();
                            
                            // Play collection sound
                            playOrbCollectionSound();
                        }
                    }

                    // Check collisions for normal movement
                    const normalCollision = checkCollision(camera.position, playerRadius);
                    
                    // Handle normal movement collisions with push-out
                    if (normalCollision.collision) {
                        const distance = camera.position.distanceTo(normalCollision.closestPoint);
                        const isStuck = distance < playerRadius * STUCK_THRESHOLD;
                        
                        if (isStuck) {
                            // Player is stuck, apply stronger push-out force
                            const pushDir = new THREE.Vector3();
                            pushDir.copy(camera.position).sub(normalCollision.closestPoint).normalize();
                            
                            // Apply extra push force when stuck
                            const pushDistance = playerRadius * STUCK_PUSH_FORCE;
                            camera.position.x += pushDir.x * pushDistance;
                            camera.position.z += pushDir.z * pushDistance;
                            
                            // Add upward velocity to help escape
                            verticalVelocity = 0.3; // Reduced from 1.0
                            isGrounded = false;
                            
                            if (isFlinging) {
                                // Add extra fling velocity in the push direction
                                const flingSpeed = Math.sqrt(flingVelocity.x * flingVelocity.x + flingVelocity.z * flingVelocity.z);
                                flingVelocity.x = pushDir.x * flingSpeed * 2.0;
                                flingVelocity.z = pushDir.z * flingSpeed * 2.0;
                            } else {
                                // Add some horizontal velocity to help escape
                                velocity.x = pushDir.x * 2.0;
                                velocity.z = pushDir.z * 2.0;
                            }
                        } else {
                            // Normal collision response
                            const pushDir = new THREE.Vector3();
                            pushDir.copy(camera.position).sub(normalCollision.closestPoint).normalize();
                            const pushDistance = (playerRadius - distance) + COLLISION_BIAS; // penetration depth + bias
                            
                            // Store vertical velocity *before* gravity might affect it later in the loop
                            const verticalVelocityBeforeCheck = verticalVelocity;

                            // Check if hitting an underside while moving up (using pre-check velocity)
                            if (pushDir.y < -0.1 && verticalVelocityBeforeCheck > 0) { 
                                // Log hitting underside
                                console.log('Collision: Hitting underside', { pushDirY: pushDir.y, verticalVelocityPreCheck: verticalVelocityBeforeCheck });
                                
                                // Stop upward movement immediately
                                verticalVelocity = 0; 
                                isGrounded = false; // No longer moving up, but not grounded yet

                                // Apply full push-out (including Y) to resolve interpenetration
                                camera.position.addScaledVector(pushDir, pushDistance * COLLISION_PUSH_FORCE);
                                
                                // Optional: Dampen or redirect horizontal velocity after hitting ceiling
                                if (isFlinging) {
                                    flingVelocity.x *= 0.5; // Dampen fling
                                    flingVelocity.z *= 0.5;
                                } else {
                                    velocity.x = 0; // Stop horizontal movement
                                    velocity.z = 0;
                                }
                            } else {
                                // Standard collision response (horizontal push, sliding, etc.)
                                // If not hitting underside while moving up, apply horizontal push/slide
                                // Log standard collision
                                console.log('Collision: Standard horizontal', { pushDirY: pushDir.y, verticalVelocityPreCheck: verticalVelocityBeforeCheck, isFlinging: isFlinging });

                                if (isFlinging) {
                                    // Push out horizontally
                                    camera.position.x += pushDir.x * pushDistance * COLLISION_PUSH_FORCE * 1.5;
                                    camera.position.z += pushDir.z * pushDistance * COLLISION_PUSH_FORCE * 1.5;
                                    
                                    // Redirect fling velocity based on horizontal component of collision
                                    const speed = Math.sqrt(flingVelocity.x * flingVelocity.x + flingVelocity.z * flingVelocity.z);
                                    const horizontalPushNormal = new THREE.Vector3(pushDir.x, 0, pushDir.z).normalize();
                                    // Reflect velocity (simple version)
                                    const dot = flingVelocity.x * horizontalPushNormal.x + flingVelocity.z * horizontalPushNormal.z;
                                    flingVelocity.x -= 2 * dot * horizontalPushNormal.x * 0.9;
                                    flingVelocity.z -= 2 * dot * horizontalPushNormal.z * 0.9;
                                    // Apply some dampening
                                    flingVelocity.multiplyScalar(0.8);

                                } else {
                                    // Push out horizontally during normal movement
                                    camera.position.x += pushDir.x * pushDistance * COLLISION_PUSH_FORCE;
                                    camera.position.z += pushDir.z * pushDistance * COLLISION_PUSH_FORCE;
                                    
                                    // Add corner sliding for normal movement
                                    const horizontalPushNormal = new THREE.Vector3(pushDir.x, 0, pushDir.z).normalize();
                                    const dotProduct = horizontalPushNormal.x * velocity.x + horizontalPushNormal.z * velocity.z;
                                    if (dotProduct < 0) { // Moving into the wall
                                        // Project velocity onto the collision plane (slide)
                                        const slideVelX = velocity.x - dotProduct * horizontalPushNormal.x;
                                        const slideVelZ = velocity.z - dotProduct * horizontalPushNormal.z;
                                        velocity.x = slideVelX * CORNER_SLIDE_FORCE; // Apply sliding with force factor
                                        velocity.z = slideVelZ * CORNER_SLIDE_FORCE;
                                    } // else: moving away or parallel, let friction handle it
                                }
                            }
                        }

                        // Apply friction to normal movement
                        velocity.x *= MOVEMENT_SMOOTHING;
                        velocity.z *= MOVEMENT_SMOOTHING;

                        // Stop movement when velocity is very small
                        if (Math.abs(velocity.x) < MIN_VELOCITY_THRESHOLD) velocity.x = 0;
                        if (Math.abs(velocity.z) < MIN_VELOCITY_THRESHOLD) velocity.z = 0;
                    }
                }

                // Always render the scene
                renderer.render(scene, camera);
            }
            animate();

            // Send position updates
            function sendPositionUpdate() {
                if (ws.readyState === WebSocket.OPEN && gameStarted) {
                    // Calculate speed and heading
                    const dx = camera.position.x - lastSentPosition.x;
                    const dz = camera.position.z - lastSentPosition.z;
                    const speed = Math.sqrt(dx * dx + dz * dz) / (0.016); // Assuming 60fps
                    const heading = Math.atan2(-dx, -dz) * 180 / Math.PI;
                    const verticalSpeed = (camera.position.y - lastSentPosition.y) / 0.016;

                    // Round position data to 2 decimal places
                    const positionData = {
                        position: [
                            Math.round(camera.position.x * 100) / 100,
                            Math.round(camera.position.y * 100) / 100,
                            Math.round(camera.position.z * 100) / 100
                        ],
                        rotation: [
                            Math.round(camera.rotation.x * 100) / 100,
                            Math.round(camera.rotation.y * 100) / 100,
                            Math.round(camera.rotation.z * 100) / 100
                        ],
                        speed: Math.round(speed),
                        heading: Math.round(heading),
                        verticalSpeed: Math.round(verticalSpeed * 100) / 100
                    };

                    ws.send(JSON.stringify({
                        type: 'position',
                        ...positionData
                    }));

                    lastSentPosition.copy(camera.position);
                    lastSentRotation.copy(camera.rotation);
                }
            }

            // Update position more frequently (16ms = ~60fps)
            setInterval(sendPositionUpdate, 16);

            // Add periodic player list updates
            setInterval(() => {
                if (document.getElementById('playerList').classList.contains('visible')) {
                    updatePlayerList();
                }
            }, 100); // Update every 100ms when visible
        } catch (error) {
            console.error('Error during initialization:', error);
            document.body.innerHTML = `
                <div style="color: white; background: rgba(0,0,0,0.8); padding: 20px; text-align: center;">
                    An error occurred while initializing the game.<br>
                    Please try refreshing the page or use a different browser.
                </div>
            `;
            throw error;
        }

        // Initialize WebSocket connection AFTER scene is set up
        setupWebSocket();

        // Function to create an orb
        function createOrb(orbData) {
            console.log('Creating orb with data:', orbData);
            
            // Make orbs larger (10x instead of 5x)
            const baseSize = orbData.size * 10;
            
            // Use dodecahedron geometry instead of sphere
            const geometry = new THREE.DodecahedronGeometry(baseSize, 0);
            
            // Create a glowing material with enhanced emissive properties
            const material = new THREE.MeshPhongMaterial({
                color: orbData.color,
                emissive: orbData.color,
                emissiveIntensity: 2.0, // Increased from 1.0 for stronger glow
                transparent: true,
                opacity: 0.9,
                shininess: 200, // Increased from 100 for more shine
                specular: 0xffffff // Add white specular highlight
            });
            
            const orb = new THREE.Mesh(geometry, material);
            orb.position.set(
                orbData.position.x,
                orbData.position.y,
                orbData.position.z
            );
            
            // Store original scale but no animation needed
            orb.userData.originalScale = baseSize;
            
            // Add to scene and store in orbs collection
            scene.add(orb);
            orbs.set(orbData.id, orb);
            
            // Debug logging for position and visibility
            console.log('Orb created successfully:', {
                id: orbData.id,
                position: orb.position,
                size: baseSize,
                color: orbData.color,
                visible: orb.visible,
                parent: orb.parent,
                inScene: scene.children.includes(orb)
            });
            
            return orb;
        }

        // Add after the playerOrbs Map declaration
        function updateOrbCount() {
            const orbCountElement = document.getElementById('orbCount');
            const currentOrbs = playerOrbs.get(playerUsername) || 0;
            orbCountElement.textContent = `Orbs: ${currentOrbs}`;
            
            // Show popup when reaching 30 orbs
            if (currentOrbs >= 30) {
                const popup = document.getElementById('orbPopup');
                popup.style.display = 'block';
                
                // Function to handle reset
                const handleReset = () => {
                    playerOrbs.set(playerUsername, 0);
                    updateOrbCount();
                    popup.style.display = 'none';
                };
                
                // Function to handle rule
                const handleRule = () => {
                    console.log('Rule button clicked');
                    popup.style.display = 'none';
                };
                
                // Add button event listeners
                document.getElementById('resetButton').onclick = handleReset;
                document.getElementById('ruleButton').onclick = handleRule;
                
                // Add keyboard event listeners
                const handleKeyPress = (event) => {
                    if (event.key.toLowerCase() === 'c') {
                        handleReset();
                    } else if (event.key.toLowerCase() === 'v') {
                        handleRule();
                    }
                };
                
                // Add keyboard listener when popup is shown
                document.addEventListener('keydown', handleKeyPress);
                
                // Remove keyboard listener when popup is closed
                const removeKeyListener = () => {
                    document.removeEventListener('keydown', handleKeyPress);
                };
                
                // Update button click handlers to also remove keyboard listener
                document.getElementById('resetButton').onclick = () => {
                    handleReset();
                    removeKeyListener();
                };
                
                document.getElementById('ruleButton').onclick = () => {
                    handleRule();
                    removeKeyListener();
                };
            }
        }

        // Create shotgun muzzle flash effect
        const muzzleFlashGeometry = new THREE.SphereGeometry(8, 16, 16);
        const muzzleFlashMaterial = new THREE.MeshBasicMaterial({
            color: 0xffff00,
            transparent: true,
            opacity: 1.0
        });
        const muzzleFlash = new THREE.Mesh(muzzleFlashGeometry, muzzleFlashMaterial);
        muzzleFlash.visible = false;
        scene.add(muzzleFlash);

        // Add a second, larger flash for better visibility
        const outerFlashGeometry = new THREE.SphereGeometry(12, 16, 16);
        const outerFlashMaterial = new THREE.MeshBasicMaterial({
            color: 0xff6600,
            transparent: true,
            opacity: 0.9
        });
        const outerFlash = new THREE.Mesh(outerFlashGeometry, outerFlashMaterial);
        outerFlash.visible = false;
        scene.add(outerFlash);

        // Handle shotgun firing - Rewritten
        function fireShotgun() {
            if (!camera || !controls.isLocked) { // Ensure camera exists and controls are locked
                return;
            }

            const now = performance.now();
            if (now - lastShotTime < SHOTGUN_COOLDOWN) {
                return; // Cooldown active
            }
            lastShotTime = now;

            // Get camera position and direction accurately
            const cameraPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraPosition);
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);

            // Calculate muzzle position slightly in front of the camera
            const muzzleOffset = -1.5; // How far in front of camera view
            const muzzlePosition = cameraPosition.clone().addScaledVector(cameraDirection, muzzleOffset);

            // Array to store pellet directions for network message
            const pelletDirections = [];

            // Create and fire pellets
            for (let i = 0; i < PELLET_COUNT; i++) {
                const pellet = pelletPool.get(); // Get a pellet from the pool
                if (!pellet) continue; // Skip if pool is empty

                // Set initial position
                pellet.position.copy(muzzlePosition);

                // Calculate spread direction
                // Start with camera direction
                const spreadDirection = cameraDirection.clone();
                // Create a random offset vector perpendicular to the view direction
                const randomAngle = Math.random() * Math.PI * 2;
                const randomSpread = Math.random() * PELLET_SPREAD;
                const spreadOffset = new THREE.Vector3(
                    Math.cos(randomAngle) * randomSpread,
                    Math.sin(randomAngle) * randomSpread,
                    0 // Z offset is handled by applying quaternion
                );
                // Apply camera rotation to the offset and add it to the direction
                spreadOffset.applyQuaternion(camera.quaternion);
                spreadDirection.add(spreadOffset).normalize(); // Add offset and normalize

                // Set pellet velocity
                pellet.userData.velocity.copy(spreadDirection).multiplyScalar(PELLET_SPEED);
                pellet.userData.spawnTime = now;
                pellet.userData.bounces = 0; // <-- Add this line to reset bounces

                // Store direction for network
                pelletDirections.push(spreadDirection.toArray());
            }

            // Send network message for other players
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'shotgun_shot',
                    position: cameraPosition.toArray(),
                    directions: pelletDirections
                }));
            }

            // Play sound effect
            playShotgunSound();
        }

        // Sound effects
        function playShotgunSound() {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Configure oscillator
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            
            // Configure gain
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Play sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }

        // Add these new functions
        function takeDamage(damage) {
            if (isDead) return;
            
            playerHealth -= damage;
            console.log(`Took ${damage} damage. Health: ${playerHealth}`);
            
            // Visual feedback for damage
            document.body.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            setTimeout(() => {
                document.body.style.backgroundColor = 'transparent';
            }, 200);
            
            if (playerHealth <= 0) {
                die();
            }
        }

        function die() {
            isDead = true;
            playerHealth = 0;
            
            // Visual feedback for death
            document.body.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            
            // Show death message
            const deathMessage = document.createElement('div');
            deathMessage.style.position = 'fixed';
            deathMessage.style.top = '50%';
            deathMessage.style.left = '50%';
            deathMessage.style.transform = 'translate(-50%, -50%)';
            deathMessage.style.color = 'white';
            deathMessage.style.fontSize = '24px';
            deathMessage.style.textAlign = 'center';
            deathMessage.textContent = 'You died! Press SPACE to respawn';
            document.body.appendChild(deathMessage);
            
            // Handle respawn
            const handleRespawn = (event) => {
                if (event.code === 'Space') {
                    respawn();
                }
            };
            document.addEventListener('keydown', handleRespawn);
            
            // Store the event listener for cleanup
            deathMessage.dataset.listener = handleRespawn;
        }

        function respawn() {
            isDead = false;
            playerHealth = 100;
            
            // Reset visual effects
            document.body.style.backgroundColor = 'transparent';
            
            // Remove death message and its event listener
            const deathMessage = document.querySelector('div[data-listener]');
            if (deathMessage) {
                document.removeEventListener('keydown', deathMessage.dataset.listener);
                deathMessage.remove();
            }
            
            // Reset position
            camera.position.set(0, playerHeight, 0);
            camera.rotation.set(0, 0, 0);
            velocity.set(0, 0, 0);
            flingVelocity.set(0, 0, 0);
            verticalVelocity = 0;
            isFlinging = false;
            isGrounded = true;
            
            // Notify server of respawn
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'player_respawned',
                    position: camera.position.toArray()
                }));
            }
        }

        // Add to the desktop controls section
        if (!isMobile) {
            // Add shotgun firing to mouse controls
            document.addEventListener('mousedown', (event) => {
                if (event.button === 2) { // Right mouse button (changed from 1 to 2)
                    console.log('DESKTOP Right Mouse Down -> Firing shotgun'); // <-- ADD LOG
                    fireShotgun();
                }
            });
        }

        // Add to the mobile controls section
        if (isMobile) {
            // Add shotgun button
            const shotgunButton = document.createElement('div');
            shotgunButton.id = 'shotgunButton';
            shotgunButton.style.cssText = `
                position: fixed;
                bottom: 250px; /* Positioned above fling button */
                left: 40px;    /* Aligned with fling button */
                width: 80px;
                height: 80px;
                background: rgba(255, 165, 0, 0.6);
                border: 2px solid rgba(255, 255, 255, 0.8);
                border-radius: 50%;
                color: white;
                font-size: 32px;
                line-height: 80px;
                text-align: center;
                pointer-events: auto;
                cursor: pointer;
                z-index: 1000;
                touch-action: none;
                transition: all 0.1s ease-out;
                user-select: none;
            `;
            shotgunButton.innerHTML = 'ðŸ”«';
            document.body.appendChild(shotgunButton);
            
            // Add shotgun button event listeners
            shotgunButton.addEventListener('touchstart', function(e) {
                e.preventDefault();
                console.log('Firing shotgun (mobile button)');
                fireShotgun();
            }, { passive: false });
        }

        // Add health display
        const healthDisplay = document.createElement('div');
        healthDisplay.id = 'healthDisplay';
        healthDisplay.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 5px;
            z-index: 1000;
        `;

        // Create 5 health segments
        for (let i = 0; i < 5; i++) {
            const segment = document.createElement('div');
            segment.style.cssText = `
                width: 20px;
                height: 30px;
                background-color: #00ff00;
                border: 2px solid rgba(255, 255, 255, 0.5);
                transition: background-color 0.2s ease;
                box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            `;
            healthDisplay.appendChild(segment);
        }

        document.body.appendChild(healthDisplay);

        // Update health display
        function updateHealthDisplay() {
            const segments = healthDisplay.children;
            const healthPerSegment = 20; // 100 health / 5 segments
            
            for (let i = 0; i < segments.length; i++) {
                const segmentHealth = Math.max(0, playerHealth - (i * healthPerSegment));
                const segmentPercentage = Math.min(100, (segmentHealth / healthPerSegment) * 100);
                
                if (segmentPercentage <= 0) {
                    segments[i].style.backgroundColor = '#ff0000'; // Brighter red when empty
                    segments[i].style.boxShadow = '0 0 10px rgba(255, 0, 0, 0.5)';
                } else {
                    segments[i].style.backgroundColor = '#00ff00'; // Brighter green when full
                    segments[i].style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
                }
            }
        }

        // Add health display update to animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update health display
            updateHealthDisplay();
            
            // Update pellet animations
            animatePellets();
            
            // ... rest of animate function ...
        }

        // Add pellet animation to the main animation loop
        function animatePellets() {
            const currentTime = Date.now();
            const deltaTime = clock.getDelta();
            
            pelletPool.active.forEach(pellet => {
                // Check if pellet has expired
                if (currentTime - pellet.spawnTime > PELLET_LIFETIME) {
                    pelletPool.release(pellet);
                    return;
                }
                
                // Store last position for collision detection
                pellet.lastPosition.copy(pellet.position);
                
                // Apply gravity (framerate independent)
                // Ensure velocity exists
                if (!pellet.userData.velocity) {
                    pellet.userData.velocity = new THREE.Vector3(); // Initialize if missing
                }
                pellet.velocity.y -= PELLET_GRAVITY * deltaTime;
                
                // Apply friction (framerate independent)
                // Assume PELLET_FRICTION (e.g., 0.99) was tuned for 60fps
                const effectivePelletFriction = Math.pow(PELLET_FRICTION, deltaTime * 60);
                pellet.velocity.multiplyScalar(effectivePelletFriction); 
                
                // Update position (already framerate independent)
                pellet.position.addScaledVector(pellet.velocity, deltaTime); // Use addScaledVector for clarity
                
                // Check for collisions with towers
                const pelletCollider = new THREE.Sphere(pellet.position, PELLET_RADIUS);
                let collision = false;
                let collisionNormal = new THREE.Vector3();
                
                // Check tower collisions
                for (const tower of towers) {
                    const towerBox = new THREE.Box3().setFromObject(tower.mesh);
                    if (towerBox.containsSphere(pelletCollider)) {
                        // Calculate collision normal
                        const center = towerBox.getCenter(new THREE.Vector3());
                        collisionNormal.copy(pellet.position).sub(center).normalize();
                        collision = true;
                        break;
                    }
                }
                
                // Check bridge collisions
                for (const bridge of bridges) {
                    // Get the bridge's collision box from the towers array
                    const bridgeObject = towers.find(t => t.mesh === bridge.mesh);
                    if (bridgeObject && bridgeObject.collisionBoxes) {
                        const bridgeBox = bridgeObject.collisionBoxes[0];
                        if (bridgeBox.containsSphere(pelletCollider)) {
                            // Calculate collision normal from bridge center
                            const center = bridgeBox.getCenter(new THREE.Vector3());
                            collisionNormal.copy(pellet.position).sub(center).normalize();
                            collision = true;
                            break;
                        }
                    }
                }
                
                // Handle collision response
                if (collision) {
                    // Move pellet back to last position
                    pellet.position.copy(pellet.lastPosition);
                    
                    // Reflect velocity based on collision normal
                    pellet.velocity.reflect(collisionNormal);
                    
                    // Apply bounce and friction
                    pellet.velocity.multiplyScalar(PELLET_BOUNCE * PELLET_FRICTION);
                    
                    // Increment bounce counter
                    pellet.bounces++;
                    
                    // Remove pellet if too many bounces
                    if (pellet.bounces >= pellet.maxBounces) {
                        pelletPool.release(pellet);
                    }
                }
                
                // Check for collisions with players
                playerStates.forEach((playerState, username) => {
                    if (username !== playerUsername) {
                        const playerCollider = new THREE.Sphere(playerState.mesh.position, playerRadius);
                        const distance = pellet.position.distanceTo(playerState.mesh.position);
                        
                        if (distance < playerRadius + PELLET_RADIUS) {
                            // Player was hit
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'player_damaged',
                                    username: username,
                                    damage: SHOTGUN_DAMAGE 
                                }));
                            }
                            pelletPool.release(pellet);
                        }
                    }
                });
                
                // Remove pellet if it's fallen too far
                if (pellet.position.y < -1000) {
                    pelletPool.release(pellet);
                }
            });
        }

        // Update the collision handling in the animation loop
        function handleCollision(collisionResult, isFlinging) {
            if (!collisionResult.collision) return;
            
            const pushDir = new THREE.Vector3();
            pushDir.copy(camera.position).sub(collisionResult.closestPoint).normalize();
            
            // Apply the same collision response for all objects (towers and bridges)
            const pushDistance = playerRadius - collisionResult.distance;
            camera.position.x += pushDir.x * pushDistance * COLLISION_PUSH_FORCE;
            camera.position.z += pushDir.z * pushDistance * COLLISION_PUSH_FORCE;
            
            // Handle velocity changes based on movement type
            if (isFlinging) {
                const speed = Math.sqrt(flingVelocity.x * flingVelocity.x + flingVelocity.z * flingVelocity.z);
                flingVelocity.x = pushDir.x * speed * 0.8;
                flingVelocity.z = pushDir.z * speed * 0.8;
            } else {
                velocity.x = pushDir.x * Math.abs(velocity.x) * CORNER_SLIDE_FORCE;
                velocity.z = pushDir.z * Math.abs(velocity.z) * CORNER_SLIDE_FORCE;
            }
        }

        // Initialize event listeners
        // setupEventListeners(); // <-- Remove this call

       
        // Handle player health updates
        ws.addEventListener('message', (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'playerHealthUpdate') {
                if (data.id === ws.id) {
                    // Handle health update
                }
            }
        });

        // Handle orb drops
        ws.addEventListener('message', (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'orbDrop') {
                // Handle orb drop
            }
        });

        // Initialize game audio
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Play background music on startup
        const backgroundMusic = new Audio('leader-ultra-essence-lossy-64.mp3');
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.5; // Set to 50% volume by default
        
        // Handle audio context suspension (needed for some browsers)
        const resumeAudio = () => {
            audioContext.resume().then(() => {
                backgroundMusic.play().catch(error => console.log('Error playing background music:', error));
            });
        };
        
        // Try to play on any user interaction
        document.addEventListener('click', resumeAudio, { once: true });
        document.addEventListener('touchstart', resumeAudio, { once: true });
        document.addEventListener('keydown', resumeAudio, { once: true });
        
        // Also try to play immediately
        resumeAudio();
    </script>
</body>
</html>
