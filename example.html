
<!DOCTYPE html>
<html lang="en">
<head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Primary Meta Tags -->
    <meta name="title" content="fly.pieter.com">
    <meta name="description" content="A fun free-to-play MMO flight sim, made with AI. Fly and dogfight with your friends online.">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://fly.pieter.com/">
    <meta property="og:title" content="fly.pieter.com">
    <meta property="og:description" content="A fun free-to-play MMO flight sim, made with AI. Fly and dogfight with your friends online.">
    <meta property="og:image" content="http://fly.pieter.com/assets/fly_social_image.png?1234">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://fly.pieter.com/">
    <meta property="twitter:title" content="fly.pieter.com">
    <meta property="twitter:description" content="A fun free-to-play MMO flight sim, made with AI. Fly and dogfight with your friends online.">
    <meta property="twitter:image" content="http://fly.pieter.com/assets/fly_social_image.png?1234">

    <link rel="icon" type="image/png" href="https://fly.pieter.com/assets/fly_emoji.png">
    <!-- Hide iOS Share popup -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <!-- 100% privacy-first analytics -->
    <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
    <meta charset="UTF-8">
    <title>fly.pieter.com</title>
    <style>
        body { 
            font-family: "system-ui", sans-serif;
            margin: 0; 
            overflow: hidden; 
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        canvas { 
            display: block;
            touch-action: none;
        }
        #metrics {
            display:none;
            cursor:pointer;
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: monospace;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            user-select: none;
            -webkit-user-select: none;
            z-index:100;
        }
        .button,
        #selectVehicleButton,
        #startButton {
            padding: 10px 55px;
            font-size: 24px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
        }
        #leftJoystick, #rightJoystick {
            position: fixed;
            bottom: 100px;
            width: 120px;
            height: 120px;
            z-index: 1000;
            opacity: 0.7;
            display: block;
        }
        #leftJoystick {
            left: 50px;
        }
        #rightJoystick {
            right: 50px;
        }
        @media (max-width: 768px) {
            #leftJoystick, #rightJoystick {
                display: block;
            }
            #metrics {
                font-size: 12px; /* Smaller metrics on mobile */
                max-width: 150px;
            }
        }
        #minimap {
            pointer-events: none;
            position: fixed;
            bottom: 40px;
            right: 20px;
            width: 150px;
            height: 150px;
            /* background: rgba(0, 0, 0, 0.5); */
            /* border: 2px solid rgba(255, 255, 255, 0.3); */
            border-radius: 50%;
            z-index: 1000;
        }
        @media (max-width: 768px) {
            #minimap {
                bottom:auto;
                top:20px;
                right:20px;
            }
        }
        #minimapCanvas {
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }
        @media (max-width: 768px) {
            #minimap {
                width: 100px;
                height: 100px;
                bottom: 10px;
                right: 10px;
            }
        }

    /* <plane selection modal> */
        #startScreen,
        .vehicle-selection-modal {
            color:#fff;
            text-align:center;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            z-index: 1000;
            display: none;
            border: 2px solid #444;
            width:600px;
            max-width:100vw;
        }

        .vehicle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .vehicle-option {
            width: 150px;
            height: 150px;
            border: 2px solid #444;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(30, 30, 30, 0.8);
            padding: 10px;
            padding-top:20px;
            padding-bottom:20px;
        }

        .vehicle-option:hover {
            border-color: #4CAF50;
            transform: scale(1.05);
            background: rgba(40, 40, 40, 0.9);
        }

        .vehicle-option.selected {
            border-color: #4CAF50;
            background: rgba(0, 255, 0, 0.1);
        }

        .vehicle-option img {
            width: 100px;
            height: 100px;
            object-fit: contain;
            margin-bottom: 10px;
            border-radius:4px;
        }

        .vehicle-option .vehicle-name {
            color: white;
            text-align: center;
            font-size: 14px;
            font-weight: bold;
        }

        .vehicle-option .vehicle-specs {
            color: #aaa;
            text-align: center;
            font-size: 12px;
            margin-top: 5px;
            line-height: 1.2;
        }

        @media (max-width: 700px) {
            .vehicle-grid {
                grid-template-columns: repeat(2, 1fr);
                }

                .vehicle-option {
                    width: 120px;
                    height: 120px;
                }

                .vehicle-option img {
                    width: 80px;
                    height: 80px;
                }

                .vehicle-option .vehicle-name {
                    font-size: 12px;
                }
            }

        /* </plane selection modal> */

        #rearViewMirror {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #444;
            border-radius: 5px;
            display: block;
            background-color: #000;
        }
        #leaderboard {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 16px;
            min-width: 400px;
            z-index: 1010;
        }
        #scoreDisplay {
            position: fixed;
            bottom: 100px;
            display:none;
            left: 20px;
            color: white;
            font-family: "system-ui", sans-serif;
            font-size: 24px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            user-select: none;
            -webkit-user-select: none;
            transition: transform 0.2s;
        }
        @media (max-width:800px) {
            #scoreDisplay {
                bottom:auto;
                left:auto;
                top:20px;
                right:20px;
            }
        }
        a {
            color:#fff;
            text-decoration:underline;
            font-weight:bold
        }
        .button:hover,
        #startButton:hover,
        a:hover {
            opacity:0.75;
        }
        .button:active,
        #startButton:active,
        a:active {
            opacity:0.5;
        }

        #chatMessages {
            position: fixed;
            right: 20px;
            top: 150px;
            width:204px;
            color: white;
            font-family: system-ui, sans-serif;
            z-index: 999;
            pointer-events: none;
        }

        .chatMessage {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .chatMessage.fading {
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        #hud {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 50vw;
            height: 50vh;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
            opacity:0.25;
            min-width:300px;
        }

        #roundTimeCountdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            font-weight:bold;
            color: white;
            display: none;
            text-align:center;
        }
    </style>
</head>
<body>
    <div id="metrics"></div>
    <div id="rearViewMirror"></div>
    <div id="leaderboard"></div>
    <div id="scoreDisplay"></div>
    <div id="chatMessages"></div>
    <div id="roundTimeCountdown"></div>
    <canvas id="hud"></canvas>

    <div id="startScreen" style="display:block">
        <h1 style="margin-top:7px;font-size: 36px; margin-bottom: 0;margin-top:0;padding:14px;padding-top:0;text-align: center;">‚úàÔ∏è fly.pieter.com</h1>
        <p style="margin-top:-3px;">
            <a target="_blank" href="https://x.com/levelsio/highlights" style="text-decoration:none;">by @levelsio + Cursor + ThreeJS</a>
        </p>
        <div style="max-width: 600px; margin: 0 auto;">
            <h2 style="margin-top:0;padding-left:14px;padding-right:14px;">
                A fun free-to-play MMO flight sim, 100% made with AI, without loading screens and GBs of updates every time you wanna play üòä
            </h2>
        </div>
        <input type="text" id="usernameInput" placeholder="Type your name..." style="padding: 10px; font-size: 18px; width: 250px; margin-bottom: 10px; border-radius: 5px; border: none;outline:none;" autocomplete="off">
        <br/>
                    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js"></script>
            <script>
                var cloudflareCaptchaResponse;
                window.onloadTurnstileCallback = function () {
                    turnstile.render('#cloudflare-captcha', {
                        sitekey: "0x4AAAAAAA_Et20He4UMsyH5",
                        callback: function(response) {
                            document.getElementById('cloudflare-captcha').remove();
                            cloudflareCaptchaResponse=response;
                            document.getElementById('startButton').classList.remove('disabled');
                        },
                    });
                };
                // if using synchronous loading, will be called once the DOM is ready
                turnstile.ready(onloadTurnstileCallback);
            </script>
            <div id="cloudflare-captcha"></div>
                <button class="disabled" id="startButton" style="font-weight:bold;padding: 10px 55px; font-size: 24px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 5px;">Join the game</button>
        <style>
            button.disabled {
                opacity: 0.5;
                cursor: not-allowed;
                pointer-events: none;
                filter:saturate(0);
            }
        </style>
        <div style="max-width: 600px; margin: 0 auto;">
            <p style="font-size: 14px; margin-top: 40px;opacity:1;line-height:1.5;">
                                <a target="_blank" href="https://buy.stripe.com/00g5lueHfbdifBudR8">Promote your startup</a> with its own in-game ad and <a target="_blank" href="https://dashboard.simpleanalytics.com/fly.pieter.com">reach 100,000+ people</a>
            </p>
            <p style="font-size: 14px; margin-top: 20px;opacity:1;line-height:1.5;">
                <a target="_blank" href="https://levelsio.com/collections/fly-pieter-com">Merch now available</a>
            </p>

            
        </div>
    </div>
    <div id="minimap">
        <canvas id="minimapCanvas"></canvas>
    </div>
    <div class="vehicle-selection-modal">
        <div class="vehicle-grid">
            <div class="vehicle-option selected" data-vehicle="cessna">
                <img src="assets/fly_vehicle_cessna.png">
                <div class="vehicle-name">Cessna 172<br/>Free</div>
                <div class="vehicle-specs">
                    Max speed: 140 knots<br>
                    Max altitude: 14,000 ft<br>
                    Fire power: Low
                </div>
            </div>
            <div class="vehicle-option disabled premium" data-vehicle="f16" data-buy-url="https://buy.stripe.com/dR64hq6aJgxC2OI14g">
                <img src="assets/fly_vehicle_f16.png">
                <div class="vehicle-name">F-16</br>$29.99</div>
                <div class="vehicle-specs">
                    Max speed: 1,500 knots<br>
                    Max altitude: 50,000 ft<br>
                    Fire power: Very high
                </div>
            </div>
            <div class="vehicle-option premium" data-vehicle="a10" data-buy-todo-url="https://buy.stripe.com/dR64hq6aJgxC2OI14g">
                <img src="assets/fly_vehicle_a10.png">
                <div class="vehicle-name">A-10 Warthog<br/>Free</div>
                <div class="vehicle-specs">
                    Max speed: 450 knots<br>
                    Max altitude: 45,000 ft<br>
                    Fire power: Extreme
                </div>
            </div>
            <div class="vehicle-option" data-vehicle="tank">
                <img src="assets/fly_vehicle_tank.png">
                <div class="vehicle-name">SAM Tank<br/>Free</div>
                <div class="vehicle-specs">
                    Max speed: 45 mph<br>
                    Max altitude: Ground<br>
                    Fire power: Extreme
                </div>
            </div>
            <div class="vehicle-option" data-vehicle="triangle">
                <img src="assets/fly_vehicle_triangle.png">
                <div class="vehicle-name">‚ñ≤ Alien Triangle<br/>Free</div>
                <div class="vehicle-specs">
                    Max speed: ???<br>
                    Max altitude: Space<br>
                    Fire power: Unknown
                </div>
            </div>
            <div class="vehicle-option" data-vehicle="ski">
                <img src="assets/fly_vehicle_ski.png">
                <div class="vehicle-name">Ski Guy with Bazooka<br/>Free (alpha)</div>
                <div class="vehicle-specs">
                    Max speed: 60 mph<br>
                    Max altitude: Mountain<br>
                    Fire power: Extreme
                </div>
            </div>
                    </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="button" id="selectVehicleButton" style="">Select</button>
        </div>
    </div>
    <script>

        

        let startTime;

        let isAirborne = false;
        let isMuted = false;

        let selfUsername;
        let selfCountryFlagEmoji;
        let verifyToken;

        
        let currentHealth=100;
        let maxHealth = 100;
        let currentDeaths=0;
        let currentKills=0;
        let timeAccumulator=0;

        let mainRotor = null;
        let mainRotor2 = null;
        let tailRotor = null;
        let rotorSpeed = 0;

                    const INITIAL_CAMERA_X = -600;
            const INITIAL_CAMERA_Y = 100;
            const INITIAL_CAMERA_Z = 100;
        
        // Crash message verbs
        const CRASH_MESSAGES = {
            "ground": "crashed into the ground",
            "building": "crashed into a building", 
            "balloon": "crashed into a balloon",
            "castle": "crashed into the castle",
            "atc": "crashed into the control tower",
            "house": "crashed into a house",
            "mountain": "crashed into the mountain",
            "mars": "crashed into Mars",
            "moon": "crashed into the Moon",
            "jupiter": "crashed into Jupiter"
        };

        // Check if user is on a mobile device
        isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        
        let balloonsHit = 0;
        const totalBalloons = 100;
        let lastPositionUpdate = 0;
        const BROADCAST_INTERVAL = 0.05;
        let socket = null;

        let skipControls=false;

        let isA10Shooting=false;
        let brrtAudio = null;
        let brrtGainNode = null;

        // Constants for vehicle properties
        let minSpeed;
        let maxSpeed;
        let takeoffSpeed;
        let speedIncrement;
        let rollSpeed;
        let maxRoll;
        let yawRate;
        let pitchSpeed;
        
        // this PROBABLY decreases FPS so let's disable
        let isRaining = false;

        // rain config
        const RAIN_COUNT = 3000;
        const RAIN_AREA = 1000;
        const RAIN_HEIGHT = 200;
        const RAIN_SPEED = 20;
        let raindrops;
        
        let marsMaterial;
        let jupiterMaterial;

        
        let roundTimeElapsed;
        let roundTimeRemaining;
        
        // Add after other global variables
        const PLAYER_TIMEOUT = 10000; // Remove players after 10 seconds of no updates

        // Initialize minimap
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const MINIMAP_SCALE = 0.02; // Adjust this value to change the map zoom level
        const MINIMAP_PLAYER_DOT_SIZE = 4;
        const MINIMAP_OTHER_DOT_SIZE = 3;


        
        // Set canvas size
        function initMinimap() {

            const minimapSize = window.innerWidth <= 768 ? 100 : 150;
            minimapCanvas.width = minimapSize;
            minimapCanvas.height = minimapSize;
        }
        initMinimap();
        
        // Track radar sweep angle
        let radarAngle = -Math.PI/2;


        // <get geoip on load>
        function getGeoIP() {
                // Make an AJAX request to get user's geolocation information
                fetch('https://geoip.pieter.com')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Network response was not ok');
                        }
                        return response.json();
                    })
                    .then(data => {
                        // Extract country code and flag emoji from the response
                        const countryCode = data.country_code || '';
                        const countryFlagEmoji = data.flag_emoji || '';
                        
                        selfCountryFlagEmoji = countryFlagEmoji;
                        
                        console.log('GeoIP data loaded:', window.geoData);
                    })
                    .catch(error => {
                        console.error('Error fetching GeoIP data:', error);
                    });
            }
            getGeoIP();
        // </get geoip on load>

        // <update rear view mirror>
            function updateRearViewMirror() {
                if(isMobileDevice) return;
                
                // Position rear view camera inside the plane looking backwards
                const rearOffset = new THREE.Vector3(0, 2, -2); // Slightly above and behind cockpit
                rearOffset.applyQuaternion(player.quaternion);
                rearViewCamera.position.copy(player.position).add(rearOffset);

                // Look forwards from the plane
                const lookBehindOffset = new THREE.Vector3(0, 2, 20);
                lookBehindOffset.applyQuaternion(player.quaternion);
                const lookAtPoint = player.position.clone().add(lookBehindOffset);
                rearViewCamera.lookAt(lookAtPoint);

                rearViewCamera.rotateZ(-currentRoll);
                
                // Render rear view
                rearViewRenderer.render(scene, rearViewCamera);
            }
        // </update rear view mirror>
        
        // <update minimap>
            function updateMinimap() {

                const centerX = minimapCanvas.width / 2;
                const centerY = minimapCanvas.height / 2;
                
                // Clear the canvas
                minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
                
                // Save the current context state
                minimapCtx.save();
                
                // Create clipping mask for circular minimap
                minimapCtx.beginPath();
                minimapCtx.arc(centerX, centerY, minimapCanvas.width / 2, 0, Math.PI * 2);
                minimapCtx.clip();
                
                // Rotate entire context around center point
                minimapCtx.translate(centerX, centerY);
                minimapCtx.rotate(yawAngle); // Negative angle to match player rotation
                minimapCtx.translate(-centerX, -centerY);
                
                // Draw circular mask
                minimapCtx.beginPath();
                minimapCtx.arc(centerX, centerY, minimapCanvas.width / 2, 0, Math.PI * 2);
                minimapCtx.clip();
                
                // Draw background
                minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
                
                // Draw player (always in center)
                minimapCtx.fillStyle = '#ffffff';
                minimapCtx.beginPath();
                minimapCtx.arc(centerX, centerY, MINIMAP_PLAYER_DOT_SIZE, 0, Math.PI * 2);
                minimapCtx.fill();
                
                // Draw other players
                otherPlayers.forEach((otherPlane, planeId) => {
                    // Calculate relative position
                    const relX = otherPlane.position.x - player.position.x;
                    const relZ = otherPlane.position.z - player.position.z;
                    
                    // Convert to minimap coordinates with increased scale (zoomed in)
                    const mapX = centerX + relX * 0.1; // Increased from 0.02 to 0.1
                    const mapY = centerY + relZ * 0.1; // Increased from 0.02 to 0.1
                    
                    // Get health value (default to 100 if not set)
                    const health = otherPlane.userData.health !== undefined ? otherPlane.userData.health : 100;

                    // Calculate color based on health percentage
                    let color;
                    if (health <= 0) {
                        // Black if dead
                        color = '#000000';
                    } else if (health <= 30) {
                        // Very dark grey for critical health (0-30%)
                        color = '#222222';
                    } else if (health <= 99) {
                        // Yellow for medium health (31-60%)
                        color = '#ffff00';
                    } else {
                        // Red for good health (61-100%)
                        color = '#ff0000';
                    }
                    
                    // Check if point is within minimap bounds
                    const distance = Math.sqrt(Math.pow(mapX - centerX, 2) + Math.pow(mapY - centerY, 2));
                    if (distance < minimapCanvas.width / 2) {
                        // Draw other player dot
                        minimapCtx.fillStyle = color;
                        minimapCtx.beginPath();
                        minimapCtx.arc(mapX, mapY, MINIMAP_OTHER_DOT_SIZE, 0, Math.PI * 2);
                        minimapCtx.fill();
                    }
                });

                // Draw radar sweep with gradient
                minimapCtx.save();
                minimapCtx.translate(centerX, centerY);
                minimapCtx.rotate(radarAngle);

                // Create gradient for radar sweep
                const gradient = minimapCtx.createRadialGradient(0, 0, 0, 0, 0, minimapCanvas.width/2);
                gradient.addColorStop(0, 'rgba(0, 255, 0, 0.3)');
                gradient.addColorStop(0.5, 'rgba(0, 255, 0, 0.1)');
                gradient.addColorStop(1, 'rgba(0, 255, 0, 0)');

                // Save context state
                minimapCtx.save();

                // Create clipping region for sweep effect
                minimapCtx.beginPath();
                minimapCtx.moveTo(0, 0);
                minimapCtx.arc(0, 0, minimapCanvas.width/2, -Math.PI/2, radarAngle, false);
                minimapCtx.lineTo(0, 0);
                minimapCtx.clip();

                // Draw gradient sweep
                minimapCtx.beginPath();
                minimapCtx.arc(0, 0, minimapCanvas.width/2, 0, Math.PI * 2, false);
                minimapCtx.fillStyle = gradient;
                minimapCtx.fill();

                // Restore context state
                minimapCtx.restore();
                minimapCtx.restore();

                // Update radar angle
                radarAngle += 0.03; // Adjust speed as needed
                if (radarAngle >= Math.PI * 1.5) {
                    radarAngle = -Math.PI/2;
                }

                // Restore the context state
                minimapCtx.restore();

            }
        // </update minimap>

        // Get username from localStorage if it exists
        const storedUsername = localStorage.getItem('username');
        if(storedUsername) {
            document.getElementById('usernameInput').value = localStorage.getItem('username');
        }

        // Set focus on the username input field when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                usernameInput.focus();
            }
        });


        // Add event listener for the start button
        document.getElementById('startButton').addEventListener('click', function() {
            selectPlane();
        });


        // Add event listener for Enter key on username input
        document.getElementById('usernameInput').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                selectPlane();
            }
        });

        function selectPlane() {
            
            // <check username>
                // Get the username from the input field
                const usernameInput = document.getElementById('usernameInput');

                let username = usernameInput.value.trim().toLowerCase();

                // Check if username is empty
                if (!username) {
                    // Focus on the input field
                    usernameInput.focus();
                    // Add a subtle shake animation to indicate error
                    usernameInput.style.border = "2px solid red";
                    
                    // Create shake animation with vanilla JS
                    let startTime = null;
                    const duration = 300; // Total animation duration in ms
                    
                    function shakeAnimation(timestamp) {
                        if (!startTime) startTime = timestamp;
                        const elapsed = timestamp - startTime;
                        
                        if (elapsed < duration) {
                            // Calculate position based on time
                            if (elapsed < 100) {
                                usernameInput.style.marginLeft = "-5px";
                            } else if (elapsed < 200) {
                                usernameInput.style.marginLeft = "5px";
                            } else {
                                usernameInput.style.marginLeft = "0px";
                            }
                            
                            requestAnimationFrame(shakeAnimation);
                        }
                    }
                    
                    requestAnimationFrame(shakeAnimation);
                    
                    // Exit the function early
                    return;
                }
                
                // Check if username contains any bad words
                const usernameLower = username.toLowerCase();
                // Check username length
                if (username.length > 15) {
                    // Alert the user
                    alert("Username must be 15 characters or less.");
                    
                    // Focus on the input field and highlight in red
                    usernameInput.focus();
                    usernameInput.style.border = "2px solid red";
                    
                    // Exit the function early
                    return;
                }

                
                const containsBadWord = BAD_WORDS.some(word => 
                    usernameLower.includes(word.toLowerCase())
                );

                if (containsBadWord) {
                    // Alert the user
                    alert("Please choose an appropriate username without bad words.");
                    
                    // Focus on the input field and highlight in red
                    usernameInput.focus();
                    usernameInput.style.border = "2px solid red";
                    
                    // Exit the function early
                    return;
                }

                // Check if username contains only allowed characters (letters, numbers, and underscores)
                const isValidUsername = /^[a-zA-Z0-9_\[\]]+$/.test(username);
                
                if (!isValidUsername && username.length > 0) {
                    // Alert the user
                    alert("Username can only contain letters, numbers, and underscores.");
                    
                    // Focus on the input field and highlight in red
                    usernameInput.focus();
                    usernameInput.style.border = "2px solid red";
                    
                    // Exit the function early
                    return;
                }
                
                                    // Check if the captcha has been completed
                    if (!cloudflareCaptchaResponse) {
                        // Alert the user
                        alert("Please complete the captcha verification before continuing.");
                        
                        // Exit the function early
                        return;
                    }
                
                if(!username) {
                    alert("Please enter a username.");
                    return;
                }
                if(!selfPlaneId) {
                    alert("No planeId found, please report this error to @levelsio");
                    return;
                }
            // </check username>


            // if selfCountryFlagEmoji exists prepend that in username
            if (selfCountryFlagEmoji) {
                username = selfCountryFlagEmoji + ' ' + username;
            }
            

            // disable the start button by adding class disabled
            document.getElementById('startButton').classList.add('disabled');
        
            // Send AJAX request to verify captcha and get token
            fetch('/fly_captcha.php', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'username': username,
                    'planeId': selfPlaneId,
                                            'cloudflareCaptchaResponse': cloudflareCaptchaResponse
                                    })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert(data.message);
                    return;
                }
                // Store the token if needed
                localStorage.setItem('verifyToken', data.verifyToken);
                verifyToken=data.verifyToken;

                // Save username to localStorage
                try {
                    localStorage.setItem('username', usernameInput.value);
                    console.log('Username saved to localStorage');
                } catch (e) {
                    console.warn('Could not save username to localStorage:', e);
                }
                
                // Set the username if it passed all checks
                selfUsername = username;

                // Remove the input field from the DOM
                if (usernameInput.parentNode) {
                    usernameInput.parentNode.removeChild(usernameInput);
                }

                // Alternatively, hide it if we might need it later
                // usernameInput.style.display = 'none';
                // Log the username
                console.log('‚úàÔ∏è My username:', selfUsername);

                // all good now show plane selector

                // Hide start screen elements
                document.querySelector('#startScreen').style.display = 'none';

                // Show plane selection modal
                document.querySelector('.vehicle-selection-modal').style.display = 'block';
                


            })
            .catch(error => {
                console.error('Error:', error);

                // enable the start button by removing class disabled
                document.getElementById('startButton').classList.remove('disabled');
            
                alert('An error occurred. Please try again.');
                return;
            });

            
        }

        // Add event listener for confirm plane selection button
        document.getElementById('selectVehicleButton').addEventListener('click', function() {
            // Only hide modal and start game if a vehicle is selected
            const selectedVehicle = document.querySelector('.vehicle-option.selected');
            if (!selectedVehicle) {
                return; // Exit if no vehicle selected
            }
            // Hide plane selection modal
            document.querySelector('.vehicle-selection-modal').style.display = 'none';
            vehicleName=document.querySelector('.vehicle-option.selected').getAttribute('data-vehicle');

            // Start game with selected plane
            startGame();
        });

        // Add event listeners for vehicle selection
        document.querySelectorAll('.vehicle-option').forEach(option => {
            option.addEventListener('click', function() {
                // Remove selected class from all options
                document.querySelectorAll('.vehicle-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                // Add selected class to clicked option if not disabled
                if (!this.classList.contains('disabled')) {
                    this.classList.add('selected');
                }
                // Save selected vehicle type if not disabled
                if (!this.classList.contains('disabled')) {
                    vehicleName = this.getAttribute('data-vehicle');
                }
                // If option is disabled but has buy URL, open it in new window
                if (this.classList.contains('disabled') && this.hasAttribute('data-buy-url')) {
                    window.open(this.getAttribute('data-buy-url'), '_blank');
                }
            });
        });



        // <gamepad>
            // Add Bluetooth Gamepad Support
            let gamepad = null;

            window.addEventListener("gamepadconnected", (e) => {
                console.log("Gamepad connected:", e.gamepad);
                gamepad = e.gamepad;
                // Show a notification that controller is connected
                if (!document.getElementById('controllerStatus')) {
                    const status = document.createElement('div');
                    status.id = 'controllerStatus';
                    status.style.position = 'fixed';
                    status.style.top = '10px';
                    status.style.left = '50%';
                    status.style.transform = 'translateX(-50%)';
                    status.style.background = 'rgba(0,0,0,0.7)';
                    status.style.color = '#fff';
                    status.style.padding = '10px';
                    status.style.borderRadius = '5px';
                    status.style.zIndex = '1000';
                    status.style.fontFamily = '"system-ui",serif';
                    status.textContent = 'üéÆ Controller Connected';
                    document.body.appendChild(status);
                    setTimeout(() => status.remove(), 3000);
                }
            });

            window.addEventListener("gamepaddisconnected", (e) => {
                console.log("Gamepad disconnected");
                gamepad = null;
            });


            // Add this to your animation loop to handle controller input
            function handleGamepadInput() {
                if (!gamepad) return;
                
                // Get the latest gamepad state
                const gp = navigator.getGamepads()[gamepad.index];
                if (!gp) return;

                // Left stick X axis (turning) - typically axis 0
                if (Math.abs(gp.axes[0]) > 0.1) { // Dead zone of 0.1
                    keys['ArrowLeft'] = gp.axes[0] < -0.1;
                    keys['ArrowRight'] = gp.axes[0] > 0.1;
                } else {
                    keys['ArrowLeft'] = false;
                    keys['ArrowRight'] = false;
                }

                // Left stick Y axis (pitch) - typically axis 1
                if (Math.abs(gp.axes[1]) > 0.1) {
                    keys['ArrowUp'] = gp.axes[1] < -0.1;
                    keys['ArrowDown'] = gp.axes[1] > 0.1;
                } else {
                    keys['ArrowUp'] = false;
                    keys['ArrowDown'] = false;
                }

                // Buttons
                keys['Space'] = gp.buttons[0].pressed;     // A button for shooting
                keys['KeyW'] = gp.buttons[7].pressed;      // RT for throttle up
                keys['KeyS'] = gp.buttons[6].pressed;      // LT for throttle down
                keys['KeyV'] = gp.buttons[8].pressed;      // SELECT button for camera toggle
                keys['ShiftRight'] = gp.buttons[1].pressed || gp.buttons[5].pressed; // B button or RB/R1 for turbo
                keys['Enter'] = gp.buttons[9].pressed;     // START button for ENTER
            }
        // </gamepad>



    </script>
    <div id="leftJoystick"></div>
    <div id="rightJoystick"></div>
    <script src="/assets/three.min.js"></script>
    <script src="/assets/nipplejs.min.js"></script>
    <script>

        // Bad username word list
        const BAD_WORDS = [
            "nigger", "nigga", "n1gger", "n1gga", "negro", "n3gro", "n!gger", "n!gga",
            "faggot", "fag", "f4ggot", "f4g", "f@ggot", "f@g", "fagg0t", "f@gg0t",
            "chink", "gook", "spic", "kike", "kyke", "ch1nk", "g00k", "sp1c", "k1ke",
            "retard", "r3tard", "tard", "cunt", "r3t@rd", "ret@rd", "c*nt", "c@nt",
            "hitler", "nazi", "h1tler", "n4zi", "h!tler", "naz1", "n@zi", "h1tl3r",
            "rape", "r4pe", "rapist", "r4pist", "r@pe", "r@pist", "r@p1st", "r4p1st",
            "kill yourself", "kys", "suicide", "su1c1de", "k1ll yourself", "k!ll yourself",
            "whore", "slut", "bitch", "b1tch", "wh0re", "sl*t", "b!tch", "b*tch", "h0e", "hoe",
            "penis", "vagina", "pussy", "dick", "cock", "p3nis", "v@gina", "p*ssy", "d!ck", "c0ck",
            "cum", "jizz", "porn", "anal", "c*m", "j!zz", "p0rn", "@nal", "@nus",
            "blowjob", "bl0wjob", "handjob", "h@ndjob", "rimjob", "r1mjob",
            "dildo", "d1ldo", "vibrator", "v1brator", "buttplug", "buttp1ug",
            "orgasm", "0rgasm", "orgy", "0rgy", "gangbang", "g@ngbang",
            "masturbate", "m@sturbate", "jackoff", "j@ckoff", "wank", "w@nk",
            "asshole", "@sshole", "a$$hole", "a$$h0le", "a**hole", "a**h0le",
            "shit", "sh1t", "sh!t", "bullshit", "bullsh1t", "f*ck", "fuck", "fuk", "fucker", "f*cker",
            "motherfucker", "motherf*cker", "m0therf*cker", "m0therfucker",
            "tits", "t1ts", "boobs", "b00bs", "titties", "t1tties"
        ];
        
        // keep this in sync with the server value if you change it here
        const HIT_DAMAGE = 10;
        
        // Define spawn point constants
        const RUNWAY_SPAWN_Y = 36; // Center of runway X position horizontally
        const RUNWAY_SPAWN_X = 0; // Center of runway X position horizontally
        const RUNWAY_SPAWN_Z = 90; // Start of runway Z position longitudinally
        const CARRIER_SPAWN_X = -600; // Aircraft carrier X position
        const CARRIER_SPAWN_Y = 36; // Aircraft carrier Z position
        const CARRIER_SPAWN_Z = 70; // Aircraft carrier Z position
        const MOUNTAIN_SPAWN_X = 300; // Mountain top X position
        const MOUNTAIN_SPAWN_Y = 235; // Mountain top Y position (elevation)
        const MOUNTAIN_SPAWN_Z = -200; // Mountain top Z position
        
        
                    let vehicleName = 'cessna';
        
                    // Randomly choose between runway and carrier spawn points
            if(Math.random() < 0.5 || vehicleName == 'tank') {
                SPAWN_POINT_X = RUNWAY_SPAWN_X;
                SPAWN_POINT_Y = RUNWAY_SPAWN_Y;
                SPAWN_POINT_Z = RUNWAY_SPAWN_Z;
            } else {
                SPAWN_POINT_X = CARRIER_SPAWN_X;
                SPAWN_POINT_Y = CARRIER_SPAWN_Y;
                SPAWN_POINT_Z = CARRIER_SPAWN_Z;
            }
        
        const RUNWAY_FADE_START = 50;    // Distance from runway where fading begins
        const RUNWAY_FADE_DISTANCE = 100; // Distance from runway where players start to appear
        const RUNWAY_SHOOT_DISTANCE = 100; // Distance from runway where players can start to shoot

        // Add after other constants
        const TURBO_SPEED_MULTIPLIER = 5;  // 50% speed boost
        const TURBO_FOV_INCREASE = 15;  // Increase FOV by 15 degrees during turbo
        const normalFOV = 75;  // Store normal FOV value

        // Add after other constants
        const MIN_FOV = normalFOV;  // Base FOV when stationary
        const MAX_FOV_INCREASE = 30;  // Increased from 20 to 30 for more dramatic effect
        const TURBO_EXTRA_FOV = 25;  // Increased from 10 to 15 for more dramatic effect


        // Scene, Camera, Renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x7FAFFF); // Minecraft-style sky blue

        // Add fog with closer distances
        // const fogColor = new THREE.Color(0x7FAFFF); // Match sky color
        const fogColor = new THREE.Color(0xE6E6FA); // Light grayish-purple misty color
        scene.fog = new THREE.Fog(fogColor, 100, 500); // Start fading at 100 units, completely fog out at 500 units (reduced from 1000)
        // scene.fog = new THREE.Fog(fogColor, 100, 1000); // Start fading at 100 units, completely fog out at 500 units (reduced from 1000)

        const camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: 'high-performance'
        });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setSize(window.innerWidth, window.innerHeight);


        // Initial camera setup - position it behind the plane
        camera.position.set(0,100,200);
        camera.lookAt(0,0,-200);

        
        document.body.appendChild(renderer.domElement);

        const WS_SERVER = 'wss://fly.pieter.com:8080';

        const isLocalGame = window.location.protocol === 'file:';
        
        // Add these constants near the top with other constants
        const SPACE_ALTITUDE = 2000; // Height where space darkness begins (80,000 ft)
        const SPACE_TRANSITION_RANGE = 2000; // Range over which the transition occurs



        // <add change view button on mobile>
            if (isMobileDevice) {
                const viewButton = document.createElement('button');
                viewButton.innerText = 'View';
                viewButton.style.position = 'fixed';
                viewButton.style.bottom = '20px';
                viewButton.style.right = '20px';
                viewButton.style.padding = '5px 10px';
                viewButton.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                viewButton.style.border = 'none';
                viewButton.style.borderRadius = '5px';
                viewButton.style.fontSize = '16px';
                viewButton.style.zIndex = '1000';
                viewButton.style.color = 'white';
                
                viewButton.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent event bubbling
                    // Trigger keydown event for V key
                    const keyEvent = new KeyboardEvent('keydown', {
                        code: 'KeyV',
                        key: 'v',
                        bubbles: false
                    });
                    window.dispatchEvent(keyEvent);
                });
                document.body.appendChild(viewButton);

                


                const leaderboardButton = document.createElement('button');
                leaderboardButton.innerText = 'Leaderboard';
                leaderboardButton.style.position = 'fixed';
                leaderboardButton.style.bottom = '20px';
                leaderboardButton.style.left = '20px';
                leaderboardButton.style.padding = '5px 10px';
                leaderboardButton.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                leaderboardButton.style.border = 'none';
                leaderboardButton.style.borderRadius = '5px';
                leaderboardButton.style.fontSize = '16px';
                leaderboardButton.style.zIndex = '1000';
                leaderboardButton.style.color = 'white';
                
                leaderboardButton.addEventListener('click', function(e) {
                    e.stopPropagation(); // Prevent event bubbling
                    const leaderboard = document.getElementById('leaderboard');
                    if (leaderboard) {
                        leaderboard.style.display = leaderboard.style.display === 'none' ? 'block' : 'none';
                    }
                });
                document.body.appendChild(leaderboardButton);

            }
        // </add change view button on mobile>


        // <create player plane>
            // Player
            let player;
            let crosshairGroup;
            let tankTurret;

            let leftSkid;
            let rightSkid;
            let skidSupportGeometry;
            let bazookaBody;
            let playerGroup;
            
            let vehicleRudder;
            let vehicleAileronLeft;
            let vehicleAileronRight;
            let vehicleElevator;
            let vehiclePropeller;


            function createPlayerVehicle() {
                if(vehicleName == 'triangle') {
                    // Create the player as a triangle-shaped craft
                    const playerGroup = new THREE.Group(); // Create a group for player parts

                    // Player materials
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 }); // White body
                    const wingMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 }); // White wings
                    const trimMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 }); // Blue trim

                    // Main body (triangle shape from createTriangleBeing)
                    const triangleShape = new THREE.Shape();
                    triangleShape.moveTo(0, 5);   // Top vertex
                    triangleShape.lineTo(-5, -5); // Bottom-left vertex
                    triangleShape.lineTo(5, -5);  // Bottom-right vertex
                    triangleShape.lineTo(0, 5);   // Back to top

                    const extrudeSettings = {
                        depth: 2, // Depth of the extrusion (thinner than Cessna fuselage)
                        bevelEnabled: false
                    };
                    const bodyGeometry = new THREE.ExtrudeGeometry(triangleShape, extrudeSettings);
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.rotation.x = 0; // Keep triangle standing upright
                    body.position.y = 0;           // Center vertically
                    playerGroup.add(body);

                    // Add the player group to the scene and set as the player
                    scene.add(playerGroup);
                    player = playerGroup;

                    minSpeed = 0;
                    maxSpeed = 5; // 2164 km/h
                    takeoffSpeed = 0.1; // Keep this the same for takeoff physics
                    speedIncrement = 0.05;  // Increased from 0.036 to reach max speed faster
                    rollSpeed = 1.44;        // 1.5x from 0.96
                    maxRoll = Math.PI / 2; // Limit bank angle to 60 degrees
                    yawRate = 10;         // 1.5x from 0.96
                    pitchSpeed = 0.9;        // 1.5x from 0.6


                }
                else if(vehicleName == 'ski') {
                    playerGroup = new THREE.Group(); // Create a group for skier parts
                    
                    // Skier materials
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x2C3E50 }); // Dark blue for jacket
                    const pantsMaterial = new THREE.MeshPhongMaterial({ color: 0x34495E }); // Darker blue for pants
                    const skiMaterial = new THREE.MeshPhongMaterial({ color: 0xE74C3C }); // Red skis
                    const bazookaMaterial = new THREE.MeshPhongMaterial({ color: 0x7F8C8D }); // Gray bazooka
                    
                    // Create a group for the skier that will be rotated
                    playerGroup = new THREE.Group();
                    
                    // Create an inner group for all the skier parts
                    const skierPartsGroup = new THREE.Group();
                    
                    // Skier body (torso)
                    const torsoGeometry = new THREE.BoxGeometry(1, 1.5, 0.7);
                    const torso = new THREE.Mesh(torsoGeometry, bodyMaterial);
                    torso.position.y = 1.5;
                    skierPartsGroup.add(torso);
                    
                    // Skier head
                    const headGeometry = new THREE.SphereGeometry(0.4, 8, 8);
                    const head = new THREE.Mesh(headGeometry, new THREE.MeshPhongMaterial({ color: 0xE0AC69 })); // Skin tone
                    head.position.set(0, 2.4, 0);
                    skierPartsGroup.add(head);
                    
                    // Skier legs
                    const legGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.4);
                    
                    // Left leg
                    const leftLeg = new THREE.Mesh(legGeometry, pantsMaterial);
                    leftLeg.position.set(-0.3, 0.6, 0);
                    skierPartsGroup.add(leftLeg);
                    
                    // Right leg
                    const rightLeg = new THREE.Mesh(legGeometry, pantsMaterial);
                    rightLeg.position.set(0.3, 0.6, 0);
                    skierPartsGroup.add(rightLeg);
                    
                    // Skis
                    const skiGeometry = new THREE.BoxGeometry(0.3, 0.1, 3);
                    
                    // Left ski
                    leftSkid = new THREE.Mesh(skiGeometry, skiMaterial);
                    leftSkid.position.set(-0.3, 0, 0.5);
                    skierPartsGroup.add(leftSkid);
                    
                    // Right ski
                    rightSkid = new THREE.Mesh(skiGeometry, skiMaterial);
                    rightSkid.position.set(0.3, 0, 0.5);
                    skierPartsGroup.add(rightSkid);
                    
                    // left pole
                    skidSupportGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.5, 8);
                    const leftPole = new THREE.Mesh(skidSupportGeometry, new THREE.MeshPhongMaterial({ color: 0xBDC3C7 }));
                    leftPole.position.set(-0.7, 1.2, -0.3);
                    leftPole.rotation.x = -Math.PI / 12;
                    skierPartsGroup.add(leftPole);
                    
                    // right pole
                    const rightPole = new THREE.Mesh(skidSupportGeometry, new THREE.MeshPhongMaterial({ color: 0xBDC3C7 }));
                    rightPole.position.set(0.7, 1.2, -0.3);
                    rightPole.rotation.x = -Math.PI / 12;
                    skierPartsGroup.add(rightPole);
                    
                    // Bazooka
                    const bazookaBodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 3, 8);
                    bazookaBody = new THREE.Mesh(bazookaBodyGeometry, bazookaMaterial);
                    bazookaBody.rotation.z=1.5;
                    bazookaBody.rotation.y=1.5;
                    bazookaBody.rotation.x=0;
                    bazookaBody.position.y=2.4;
                    bazookaBody.position.x=-0.5;
                    skierPartsGroup.add(bazookaBody);
                    
                    // Rotate the inner group 180 degrees around the Y axis
                    skierPartsGroup.rotation.y = Math.PI;
                    
                    // Add the rotated inner group to the main player group
                    playerGroup.add(skierPartsGroup);

                    scene.add(playerGroup);
                    player = playerGroup;
                    
                    // always spawn skier on top 
                    SPAWN_POINT_X=MOUNTAIN_SPAWN_X;
                    SPAWN_POINT_Y=MOUNTAIN_SPAWN_Y;
                    SPAWN_POINT_Z=MOUNTAIN_SPAWN_Z;

                    // config
                    minSpeed = 0;
                    maxSpeed = 0.3; // Faster than tank but slower than planes
                    takeoffSpeed = 0.1; // Low takeoff speed for skiing
                    speedIncrement = 0.03;  // Moderate acceleration
                    rollSpeed = 1.2;        // Good turning ability
                    maxRoll = Math.PI / 3; // Limit bank angle for skiing
                    yawRate = 1.5;         // Good turning
                    pitchSpeed = 0.7;      // Moderate pitch control for jumps
                }
                else if(vehicleName == 'tank') {
                    const playerGroup = new THREE.Group(); // Create a group for tank parts
                    
                    // Tank materials
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4B5320 }); // Olive drab
                    const trackMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a }); // Dark gray
                    const turretMaterial = new THREE.MeshPhongMaterial({ color: 0x3B4210 }); // Darker olive
                    
                    // Main tank body
                    const bodyGeometry = new THREE.BoxGeometry(3, 1.2, 4);
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.6;
                    playerGroup.add(body);

                    // Tank tracks
                    const trackGeometry = new THREE.BoxGeometry(0.8, 0.6, 4.5);
                    
                    // Left track
                    const leftTrack = new THREE.Mesh(trackGeometry, trackMaterial);
                    leftTrack.position.set(-1.5, 0.3, 0);
                    playerGroup.add(leftTrack);
                    
                    // Right track
                    const rightTrack = new THREE.Mesh(trackGeometry, trackMaterial);
                    rightTrack.position.set(1.5, 0.3, 0);
                    playerGroup.add(rightTrack);

                    // Turret base (rotating part)
                    const turretBaseGeometry = new THREE.CylinderGeometry(1, 1.2, 0.8, 8);
                    const turretBase = new THREE.Mesh(turretBaseGeometry, turretMaterial);
                    turretBase.position.set(0, 1.5, 0);
                    playerGroup.add(turretBase);

                    // Main turret body
                    const turretGeometry = new THREE.BoxGeometry(1.8, 1, 2);
                    tankTurret = new THREE.Mesh(turretGeometry, turretMaterial);
                    tankTurret.position.set(0, 1.8, 0);
                    playerGroup.add(tankTurret);

                    // Anti-aircraft gun barrel
                    const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
                    const barrel = new THREE.Mesh(barrelGeometry, turretMaterial);
                    barrel.position.set(0, 2.2, 1); // Changed from -1 to 1 to point up
                    barrel.rotation.x = -Math.PI / 4; // Changed from Math.PI/4 to -Math.PI/4 to point up
                    playerGroup.add(barrel);

                    // Secondary anti-aircraft gun
                    const secondaryBarrelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
                    const secondaryBarrel = new THREE.Mesh(secondaryBarrelGeometry, turretMaterial);
                    secondaryBarrel.position.set(0.4, 2.2, 1); // Changed from -1 to 1 to point up
                    secondaryBarrel.rotation.x = -Math.PI / 4; // Changed from Math.PI/4 to -Math.PI/4 to point up
                    playerGroup.add(secondaryBarrel);

                    // Add some armor plates/details
                    const armorGeometry = new THREE.BoxGeometry(3.2, 0.3, 0.8);
                    const frontArmor = new THREE.Mesh(armorGeometry, bodyMaterial);
                    frontArmor.position.set(0, 0.8, 1.8); // Changed from -1.8 to 1.8 to move to back
                    frontArmor.rotation.x = -Math.PI / 6; // Changed from Math.PI/6 to -Math.PI/6 to angle the other way
                    playerGroup.add(frontArmor);

                    // Lower the entire tank to ground level
                    playerGroup.position.y = 0.3; // Position tracks just above ground

                    scene.add(playerGroup);
                    player = playerGroup;

                    // always spawn tank on runway
                    SPAWN_POINT_X=RUNWAY_SPAWN_X;
                    SPAWN_POINT_Y=RUNWAY_SPAWN_Y;
                    SPAWN_POINT_Z=RUNWAY_SPAWN_Z;

                    // config
                    minSpeed = 0;
                    maxSpeed = 0.2; // 100km/h
                    takeoffSpeed = 0.28; // Keep this the same for takeoff physics
                    speedIncrement = 0.02;  // Increased from 0.036 to reach max speed faster
                    rollSpeed = 1.44;        // 1.5x from 0.96
                    maxRoll = Math.PI / 2; // Limit bank angle to 60 degrees
                    yawRate = 1;         // 1.5x from 0.96
                    pitchSpeed = 0.9;        // 1.5x from 0.6

                }
                else if(vehicleName == 'apache') {
                    // apache model
                    const playerGroup = new THREE.Group();

                    // Materials
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4B5320 }); // Olive drab
                    const rotorMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a }); // Dark gray
                    const detailMaterial = new THREE.MeshPhongMaterial({ color: 0x3B4210 }); // Darker olive
                    const glassMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, transparent: true, opacity: 0.7 }); // Tinted glass

                    // Main helicopter body
                    const bodyGeometry = new THREE.BoxGeometry(2, 1.8, 6);
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.5;
                    playerGroup.add(body);

                    // Cockpit - tandem seating configuration
                    const cockpitGeometry = new THREE.BoxGeometry(1.8, 0.8, 2.5);
                    const cockpit = new THREE.Mesh(cockpitGeometry, glassMaterial);
                    cockpit.position.set(0, 1.3, -1.5);
                    playerGroup.add(cockpit);

                    // Main rotor hub
                    const hubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 8);
                    const hub = new THREE.Mesh(hubGeometry, rotorMaterial);
                    hub.position.set(0, 2.5, 0);
                    playerGroup.add(hub);

                    // Main rotor blades (4 blades for Apache)
                    const mainRotorGeometry = new THREE.BoxGeometry(10, 0.1, 0.4);
                    mainRotor = new THREE.Mesh(mainRotorGeometry, rotorMaterial);
                    mainRotor.position.set(0, 2.7, 0);
                    playerGroup.add(mainRotor);

                    // Second set of rotor blades (perpendicular)
                    mainRotor2 = new THREE.Mesh(mainRotorGeometry, rotorMaterial);
                    mainRotor2.position.set(0, 2.7, 0);
                    mainRotor2.rotation.y = Math.PI / 2;
                    playerGroup.add(mainRotor2);

                    // Tail boom
                    const tailBoomGeometry = new THREE.BoxGeometry(0.5, 0.5, 4);
                    const tailBoom = new THREE.Mesh(tailBoomGeometry, bodyMaterial);
                    tailBoom.position.set(0, 0.5, 4);
                    playerGroup.add(tailBoom);

                    // Tail rotor
                    const tailRotorGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.2);
                    tailRotor = new THREE.Mesh(tailRotorGeometry, rotorMaterial);
                    tailRotor.position.set(0.4, 0.5, 5.8);
                    playerGroup.add(tailRotor);

                    // Wing stubs for weapons mounting
                    const wingGeometry = new THREE.BoxGeometry(5, 0.2, 1);
                    const wings = new THREE.Mesh(wingGeometry, bodyMaterial);
                    wings.position.set(0, 0.2, 0);
                    playerGroup.add(wings);

                    // Weapons - Hellfire missiles
                    const missileGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8);
                    const missileMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    
                    // Add missiles to wing hardpoints
                    for (let i = -2; i <= 2; i += 1) {
                        if (i !== 0) {
                            const missile = new THREE.Mesh(missileGeometry, missileMaterial);
                            missile.rotation.x = Math.PI / 2;
                            missile.position.set(i, 0.1, 0);
                            playerGroup.add(missile);
                        }
                    }

                    // Chain gun under the nose
                    const gunGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
                    const gun = new THREE.Mesh(gunGeometry, rotorMaterial);
                    gun.rotation.x = Math.PI / 2;
                    gun.position.set(0, 0, -3);
                    playerGroup.add(gun);

                    // Skids
                    const skidGeometry = new THREE.BoxGeometry(0.2, 0.2, 4);
                    leftSkid = new THREE.Mesh(skidGeometry, detailMaterial);
                    leftSkid.position.set(-1, -0.8, 0);
                    playerGroup.add(leftSkid);

                    rightSkid = new THREE.Mesh(skidGeometry, detailMaterial);
                    rightSkid.position.set(1, -0.8, 0);
                    playerGroup.add(rightSkid);

                    // Skid supports
                    skidSupportGeometry = new THREE.BoxGeometry(0.1, -0.5, 0.1);
                    for (let i = -1; i <= 1; i += 2) {
                        for (let j = -1; j <= 1; j += 2) {
                            const support = new THREE.Mesh(skidSupportGeometry, detailMaterial);
                            support.position.set(i, -0.6, j);
                            playerGroup.add(support);
                        }
                    }


                    scene.add(playerGroup);
                    player = playerGroup;

                    // Spawn point
                    SPAWN_POINT_X = RUNWAY_SPAWN_X;
                    SPAWN_POINT_Y = RUNWAY_SPAWN_Y + 2; // Lift helicopter off ground
                    SPAWN_POINT_Z = RUNWAY_SPAWN_Z;

                    minSpeed = 0;
                    maxSpeed = 5; // 2164 km/h
                    takeoffSpeed = 0.28; // Keep this the same for takeoff physics
                    speedIncrement=0.15;
                    rollSpeed = 1.44;
                    maxRoll = Math.PI / 2; // Limit bank angle to 60 degrees
                    yawRate = 2;         // 1.5x from 0.96
                    pitchSpeed = 0.9;     

                } else if(vehicleName == 'f16') {

                                    } else if(vehicleName == 'a10') {
                    const playerGroup = new THREE.Group();

                    // A-10 materials
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 }); // Gray body
                    const wingMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 }); // Gray wings
                    const engineMaterial = new THREE.MeshPhongMaterial({ color: 0x505050 }); // Darker gray engines

                    // Main body (fuselage) - wider and more angular
                    const bodyGeometry = new THREE.BoxGeometry(1.2, 1.0, 5);
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    playerGroup.add(body);

                    // Twin engines
                    const engineGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.2, 8);
                    const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
                    leftEngine.rotation.x = Math.PI/2;
                    leftEngine.position.set(-0.8, 0.2, 0.5);
                    playerGroup.add(leftEngine);

                    const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
                    rightEngine.rotation.x = Math.PI/2;
                    rightEngine.position.set(0.8, 0.2, 0.5);
                    playerGroup.add(rightEngine);

                    // Straight wings
                    const wingGeometry = new THREE.BoxGeometry(8, 0.1, 2);
                    const wings = new THREE.Mesh(wingGeometry, wingMaterial);
                    wings.position.y = 0;
                    playerGroup.add(wings);

                    // Twin vertical stabilizers
                    const stabilizerGeometry = new THREE.BoxGeometry(0.1, 1.2, 1.5);
                    const leftStabilizer = new THREE.Mesh(stabilizerGeometry, wingMaterial);
                    leftStabilizer.position.set(-0.8, 0.6, 2);
                    playerGroup.add(leftStabilizer);

                    const rightStabilizer = new THREE.Mesh(stabilizerGeometry, wingMaterial);
                    rightStabilizer.position.set(0.8, 0.6, 2);
                    playerGroup.add(rightStabilizer);

                    // Horizontal stabilizer
                    const hStabGeometry = new THREE.BoxGeometry(3, 0.1, 1);
                    const hStab = new THREE.Mesh(hStabGeometry, wingMaterial);
                    hStab.position.set(0, 0.3, 2);
                    playerGroup.add(hStab);

                    // Iconic GAU-8 Avenger cannon
                    const cannonGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
                    const cannon = new THREE.Mesh(cannonGeometry, engineMaterial);
                    cannon.rotation.x = Math.PI/2;
                    cannon.position.set(0, -0.3, -2.5);
                    playerGroup.add(cannon);

                    // Cockpit
                    const cockpitGeometry = new THREE.BoxGeometry(0.8, 0.4, 1.2);
                    const cockpitMaterial = new THREE.MeshPhongMaterial({
                        color: 0x87CEEB,
                        transparent: true,
                        opacity: 0.7
                    });
                    const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
                    cockpit.position.set(0, 0.5, -1);
                    playerGroup.add(cockpit);

                    scene.add(playerGroup);
                    player = playerGroup;

                    // A-10 flight characteristics
                    minSpeed = 0;
                    maxSpeed = 2.5; // Lower top speed than F-16
                    takeoffSpeed = 0.3;
                    speedIncrement=0.15; // 0 to 100kts in 5 seconds
                    rollSpeed = 1.44;
                    maxRoll = Math.PI / 2;
                    yawRate = 8;
                    pitchSpeed = 0.7;

                } else {
                    // default to cessna plane
                    const playerGroup = new THREE.Group(); // Create a group for player parts
                    
                    // Player materials
                    const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF }); // White body
                    const wingMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF }); // White wings
                    const trimMaterial = new THREE.MeshPhongMaterial({ color: 0x2244CC }); // Blue trim

                    // Main body (fuselage)
                    const bodyGeometry = new THREE.BoxGeometry(0.8, 0.8, 4);
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    playerGroup.add(body);

                    // Nose - tapered front
                    const noseGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.8);
                    const nose = new THREE.Mesh(noseGeometry, bodyMaterial);
                    nose.position.z = -2.2;
                    nose.position.y = -0.1;
                    playerGroup.add(nose);

                    // Propeller
                    const propellerGeometry = new THREE.BoxGeometry(2, 0.1, 0.1);
                    const propellerMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    vehiclePropeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                    vehiclePropeller.position.z = -2.6;
                    playerGroup.add(vehiclePropeller);

                    // Propeller hub
                    const hubGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 8);
                    const hub = new THREE.Mesh(hubGeometry, propellerMaterial);
                    hub.rotation.x = Math.PI/2;
                    hub.position.z = -2.6;
                    playerGroup.add(hub);

                    // High-mounted wings (Cessna characteristic)
                    const wingGeometry = new THREE.BoxGeometry(7, 0.1, 1.2);
                    const wings = new THREE.Mesh(wingGeometry, wingMaterial);
                    wings.position.y = 0.3;
                    playerGroup.add(wings);

                    // Left aileron
                    const leftAileronGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.6);
                    vehicleAileronLeft = new THREE.Mesh(leftAileronGeometry, wingMaterial);
                    vehicleAileronLeft.position.set(-2.5, 0.3, 0.3);
                    playerGroup.add(vehicleAileronLeft);

                    // Right aileron  
                    const rightAileronGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.6);
                    vehicleAileronRight = new THREE.Mesh(rightAileronGeometry, wingMaterial);
                    vehicleAileronRight.position.set(2.5, 0.3, 0.3);
                    playerGroup.add(vehicleAileronRight);

                    // Tail wings
                    const tailWingGeometry = new THREE.BoxGeometry(2.2, 0.1, 0.8);
                    vehicleElevator = new THREE.Mesh(tailWingGeometry, wingMaterial);
                    vehicleElevator.position.z = 1.8;
                    vehicleElevator.position.y = 0.2;
                    playerGroup.add(vehicleElevator);

                    // Vertical stabilizer
                    const vehicleRudderGeometry = new THREE.BoxGeometry(0.1, 0.8, 1.2);
                    vehicleRudder = new THREE.Mesh(vehicleRudderGeometry, wingMaterial);
                    vehicleRudder.position.z = 1.8;
                    vehicleRudder.position.y = 0.5;
                    playerGroup.add(vehicleRudder);

                    // Windows (cockpit)
                    const windowGeometry = new THREE.BoxGeometry(0.82, 0.82, 1.2);
                    const windowMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x87CEEB,
                        transparent: true,
                        opacity: 0.5
                    });
                    const windows = new THREE.Mesh(windowGeometry, windowMaterial);
                    windows.position.z = -0.8;
                    windows.position.y = 0.1;
                    playerGroup.add(windows);

                    // Landing gear
                    const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 8);
                    const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    
                    // Main landing gear (under wings)
                    const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    leftWheel.rotation.z = Math.PI / 2;
                    leftWheel.position.set(-1, -0.6, 0); // Adjusted Y position
                    playerGroup.add(leftWheel);
                    
                    const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    rightWheel.rotation.z = Math.PI / 2;
                    rightWheel.position.set(1, -0.6, 0); // Adjusted Y position
                    playerGroup.add(rightWheel);
                    
                    // Nose wheel
                    const noseWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    noseWheel.rotation.z = Math.PI / 2;
                    noseWheel.position.set(0, -0.6, -1.5); // Adjusted Y position
                    playerGroup.add(noseWheel);

                    scene.add(playerGroup);
                    player = playerGroup;

                    // regular plane
                    minSpeed = 0;
                    maxSpeed = 2.5; // 1,260 km/h when multiplied by 525
                    takeoffSpeed = 0.28; // Keep this the same for takeoff physics
                    speedIncrement = 0.10;  // Increased from 0.036 to reach max speed faster
                    rollSpeed = 1.44;        // 1.5x from 0.96
                    maxRoll = Math.PI / 2; // Limit bank angle to 60 degrees
                    yawRate = 5;         // 1.5x from 0.96
                    pitchSpeed = 0.9;        // 1.5x from 0.6


                }


                // Keep initial position
                player.position.set(SPAWN_POINT_X, SPAWN_POINT_Y, SPAWN_POINT_Z);
                
                // cast shadow
                player.castShadow = true;
                
                // Initial camera setup - position it behind the plane
                camera.position.set(SPAWN_POINT_X, SPAWN_POINT_Y+2, SPAWN_POINT_Z + 10); // Use spawn point constants + offset for Z
                camera.lookAt(player.position);

                // <crosshair>
                    // Create and add crosshair to player
                    crosshairGroup = new THREE.Group();

                    // Create material for crosshair lines
                    const crosshairMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8,
                        fog: false // Make sure fog doesn't affect visibility
                    });

                    // Vertical line
                    const verticalGeometry = new THREE.BoxGeometry(0.02, 0.3, 0.02);
                    const verticalLine = new THREE.Mesh(verticalGeometry, crosshairMaterial);
                    crosshairGroup.add(verticalLine);

                    // Horizontal line
                    const horizontalGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.02);
                    const horizontalLine = new THREE.Mesh(horizontalGeometry, crosshairMaterial);
                    crosshairGroup.add(horizontalLine);

                    // Position the crosshair in front of the plane
                    // Position the crosshair slightly higher
                    crosshairGroup.position.y = 1; // Offset upward
                    crosshairGroup.position.z = -10; // 3 units in front of the plane's center

                    // Add crosshair to player
                    player.add(crosshairGroup);
                // <crosshair>

            }
        // </create player plane>

        // <grass>
            // Ground at 35 units tall (unchanged)
            const groundGeometry = new THREE.BoxGeometry(1000, 35, 4000);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2D5A27,  // Darker forest green
                shininess: 0,     // Remove shininess
                flatShading: true // Add some texture
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.position.y = 17.5; // Half height of 35
            ground.position.x = 150;
            ground.receiveShadow = true;
            scene.add(ground);
        // </grass>

        // <runway>
            // Runway at exact same level as ground, but only 1px thick
            const runwayGeometry = new THREE.BoxGeometry(10, 0.001, 200);
            const runwayMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 });
            const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
            runway.position.x = 0;
            runway.position.y = 35.01; // Increased from 35.001 to 35.01
            runway.position.z = 0;
            runway.receiveShadow = true;
            scene.add(runway);

            // <runway stripes>
                // Runway markings just barely above runway
                const stripeGeometry = new THREE.BoxGeometry(1, 0.001, 5);
                const stripeMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
                
                // Regular center stripes down the runway
                for(let i = -90; i <= 85; i += 10) {
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.set(0, 35.02, i); // Increased from 35.002 to 35.02
                    stripe.receiveShadow = true;
                    scene.add(stripe);
                }

                // Parallel stripes at the start of runway
                const startStripeGeometry = new THREE.BoxGeometry(0.5, 0.001, 7);
                for(let x = -4; x <= 4; x += 1) {
                    if(x !== 0) { // Skip the middle stripe at x=0
                        const startStripe = new THREE.Mesh(startStripeGeometry, stripeMaterial);
                        startStripe.position.set(x, 35.02, 95); // At start of runway
                        startStripe.receiveShadow = true;
                        scene.add(startStripe);
                    }
                }
            // </runway stripes>

            // ATC Tower
            const towerGroup = new THREE.Group();

            // Main tower structure (concrete base) - halved size
            const towerBaseGeometry = new THREE.BoxGeometry(4, 12.5, 4);
            const towerBaseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xcccccc,  // Light grey concrete
                roughness: 0.8
            });
            const towerBase = new THREE.Mesh(towerBaseGeometry, towerBaseMaterial);
            towerBase.position.y = 6.25; // Half of height
            towerGroup.add(towerBase);

            // Control room (glass enclosure) - halved size
            const controlRoomGeometry = new THREE.BoxGeometry(6, 3, 6);
            const controlRoomMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x87CEEB,  // Sky blue
                transparent: true,
                opacity: 0.6,
                shininess: 90
            });
            const controlRoom = new THREE.Mesh(controlRoomGeometry, controlRoomMaterial);
            controlRoom.position.y = 14; // Base height (12.5) + half control room height (1.5)
            towerGroup.add(controlRoom);

            // Roof - halved size
            const roofGeometry = new THREE.ConeGeometry(4.25, 2, 4);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 }); // Dark grey
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 16.5; // Control room top (15.5) + half roof height (1)
            roof.rotation.y = Math.PI / 4; // Rotate 45 degrees to align with base
            towerGroup.add(roof);

            // Antenna - halved size
            const antennaGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
            const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.y = 19; // Roof top (17.5) + half antenna height (1.5)
            towerGroup.add(antenna);

            // Position entire tower group next to runway - moved to halfway point
            towerGroup.position.set(15, 35, 0); // 15 units right of runway, at ground level, centered at z=0

            scene.add(towerGroup);

            // Add some ground details around the tower - halved size
            const towerBaseDetailGeometry = new THREE.BoxGeometry(8, 0.25, 8);
            const towerBaseDetailMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 }); // Concrete pad
            const towerBaseDetail = new THREE.Mesh(towerBaseDetailGeometry, towerBaseDetailMaterial);
            towerBaseDetail.position.set(15, 35.1, 0); // Slightly above ground, matching tower position
            scene.add(towerBaseDetail);

            // Windsock
            const windsockGroup = new THREE.Group();

            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 3; // Half height
            windsockGroup.add(pole);

            // Windsock segments (create multiple segments for better animation)
            const segments = 6;
            const sockSegments = [];
            const segmentGeometry = new THREE.CylinderGeometry(0.4, 0.3, 0.6, 8);
            const sockMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                side: THREE.DoubleSide,
                flatShading: true
            });

            for (let i = 0; i < segments; i++) {
                const segment = new THREE.Mesh(segmentGeometry, sockMaterial);
                segment.position.set(0, 5.5, i * 0.3); // Position at top of pole
                segment.rotation.x = Math.PI / 2; // Rotate to horizontal
                segment.rotation.y = Math.PI / 4; // Add 45-degree rotation (œÄ/4 radians = 45 degrees)
                sockSegments.push(segment);
                windsockGroup.add(segment);
            }

            // Position windsock near runway but rotated differently
            windsockGroup.position.set(8, 35, -30); // Keep same position
            windsockGroup.rotation.y = Math.PI / 4; // Rotate entire group 45 degrees

            scene.add(windsockGroup);

            // Add wind physics variables
            let windSpeed = Math.random() * 0.4 + 0.1; // Random speed between 0.1 and 0.5
            let windDirection = Math.random() * Math.PI * 2; // Random direction between 0 and 2œÄ radians
            let windChangeTimer = Math.random() * 100; // Random initial timer value
            const WIND_CHANGE_INTERVAL = 500; // Change wind every 500 frames

            // Enhanced windsock animation
            function animateWindsock() {
                // Update wind conditions with deltaTime
                windChangeTimer += deltaTime * 60;
                if (windChangeTimer > WIND_CHANGE_INTERVAL) {
                    // Gradually change wind speed and direction
                    windSpeed = Math.max(0.1, Math.min(0.8, windSpeed + (Math.random() - 0.5) * 0.1));
                    windDirection += (Math.random() - 0.5) * 0.1;
                    windChangeTimer = 0;
                }
                
                const time = Date.now() * 0.001;
                
                // Calculate apparent wind based on player speed and direction
                const playerWindEffect = currentSpeed * 2;
                const playerDirection = -yawAngle; // Negative because yaw is reversed
                
                // Combine natural wind and player movement
                const totalWindSpeed = Math.sqrt(
                    Math.pow(windSpeed * Math.cos(windDirection) + playerWindEffect * Math.cos(playerDirection), 2) +
                    Math.pow(windSpeed * Math.sin(windDirection) + playerWindEffect * Math.sin(playerDirection), 2)
                );
                
                const totalWindDirection = Math.atan2(
                    windSpeed * Math.sin(windDirection) + playerWindEffect * Math.sin(playerDirection),
                    windSpeed * Math.cos(windDirection) + playerWindEffect * Math.cos(playerDirection)
                );

                sockSegments.forEach((segment, index) => {
                    const offset = index * 0.1;
                    const windEffect = totalWindSpeed * (1 + index * 0.1); // Stronger effect on later segments
                    
                    // Base position affected by wind strength
                    segment.position.y = 5.5 + Math.sin(time * 2 + offset) * 0.1;
                    segment.position.x = Math.sin(totalWindDirection) * windEffect;
                    segment.position.z = index * 0.3 + Math.cos(totalWindDirection) * windEffect;
                    
                    // Rotation based on wind direction and strength
                    segment.rotation.x = Math.PI / 2 + Math.sin(time * 3 + offset) * 0.1;
                    segment.rotation.y = totalWindDirection;
                    
                    // Add some waviness
                    segment.rotation.z = Math.sin(time * 4 + offset * 2) * 0.1 * totalWindSpeed;
                });
            }
        // </runway>

    
        // Force initial render
        renderer.render(scene, camera);

        // Add this right after creating the renderer
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Force a render on resize
            renderer.render(scene, camera);
        });

        // Create audio context and engine sound
        let audioContext;
        let engineOscillator;
        let gainNode;

        // Add after audio context creation in startGame()
        let missileSound;
        

        function createMissileSound() {

            
            const duration = 0.15;
            const audioCtx = window.audioContext;
            
            // Create buffer for the shoot sound
            const missileSoundBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
            const channelData = missileSoundBuffer.getChannelData(0);
            
            // if (isMobileDevice) {
                // diff bassy "doof" sound for mobile
                for (let i = 0; i < missileSoundBuffer.length; i++) {
                    const t = i / audioCtx.sampleRate;
                    // Lower frequency for boom (30Hz)
                    const baseFreq = 30;
                    // Faster decay for punchier explosion
                    const amplitude = Math.exp(-1 * t);
                    // Add noise for crackle
                    const noise = (Math.random() * 2 - 1) * Math.exp(-5 * t);
                    
                    channelData[i] = amplitude * (
                        Math.sin(2 * Math.PI * baseFreq * t) + // Base boom
                        1.5 * Math.sin(4 * Math.PI * baseFreq * t) + // First harmonic
                        1.25 * Math.sin(8 * Math.PI * baseFreq * t) + // Second harmonic
                        1.5 * noise // Noise component
                    );
                }
            // } else {
            //     // Original bassy "doof" sound for desktop
            //     for (let i = 0; i < missileSoundBuffer.length; i++) {
            //         const t = i / audioCtx.sampleRate;
            //         const baseFreq = 50;
            //         const amplitude = Math.exp(-10 * t);
            //         channelData[i] = amplitude * (
            //             Math.sin(2 * Math.PI * baseFreq * t) +
            //             0.7 * Math.sin(4 * Math.PI * baseFreq * t) +
            //             0.5 * Math.sin(6 * Math.PI * baseFreq * t) +
            //             0.3 * Math.sin(8 * Math.PI * baseFreq * t)
            //         );
            //     }
            // }
            
            missileSound = missileSoundBuffer;
        }
        // Add this function to stop A-10 sound
        let brrtFadeOutInterval = null; // Track the fade out interval

        function stopA10GunSound() {
            if (isA10Shooting) {
                isA10Shooting = false;
                // Play the end sound
                const endSound = new Audio('/assets/fly_vehicle_a10_brrrt_end.mp3');
                endSound.volume = 1;
                endSound.play();
            }
        }



        // Modify playMissileSound function to adjust volume for mobile only
        function playMissileSound() {
            if (!window.audioContext) return;
            if(isMuted) return;
            
            // Original missile sound for other vehicles
            const source = window.audioContext.createBufferSource();
            source.buffer = missileSound;
            
            const gainNode = window.audioContext.createGain();
            gainNode.gain.value = isMobileDevice ? 0.4 : 2.0;
            
            const filter = window.audioContext.createBiquadFilter();
            filter.type = 'lowshelf';
            filter.frequency.value = 100;
            filter.gain.value = 20;
            
            const compressor = window.audioContext.createDynamicsCompressor();
            compressor.threshold.value = -24;
            compressor.knee.value = 30;
            compressor.ratio.value = 12;
            compressor.attack.value = 0.003;
            compressor.release.value = 0.25;
            
            source.connect(filter);
            filter.connect(compressor);
            compressor.connect(gainNode);
            gainNode.connect(window.audioContext.destination);
            
            source.start();
        }



        // Add this function to create the rear view mirror
        function createRearViewMirror() {
            if(isMobileDevice) {
                return;
            }
            // Create rear view camera
            rearViewCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            
            // Create renderer for rear view
            rearViewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            rearViewRenderer.setSize(200, 120); // Mirror size
            
            // Add renderer to existing rearview mirror div
            rearViewRenderer.domElement.style.width = '100%';
            rearViewRenderer.domElement.style.height = '100%';
            document.getElementById('rearViewMirror').appendChild(rearViewRenderer.domElement);
        }
        
        
       

        
        // Add function to update leaderboard
        function updateLeaderboard() {
            const leaderboard = document.getElementById('leaderboard');
            if (!leaderboard) return;

            // Collect all players including self
            let allPlayers = [];
            
            // Add self
            allPlayers.push({
                username: selfUsername || 'Anonymous',
                kills: typeof currentKills !== 'undefined' ? currentKills : 0,
                deaths: typeof currentDeaths !== 'undefined' ? currentDeaths : 0,
                health: typeof currentHealth !== 'undefined' ? currentHealth : 100,
                isLocal: true,
                lastUpdate: Date.now()
            });
            
            // Add other players
            otherPlayers.forEach((plane, planeId) => {
                // Include all players, not just those with kills
                allPlayers.push({
                    username: plane.userData.username || 'Anonymous',
                    kills: plane.userData.kills || 0,
                    deaths: plane.userData.deaths || 0,
                    health: plane.userData.health || 100,
                    isLocal: false,
                    lastUpdate: plane.userData.lastUpdate || 0
                });
            });
            
            // Remove inactive players (no updates in last 10 seconds)
            const currentTime = Date.now();
            allPlayers = allPlayers.filter(player => 
                currentTime - player.lastUpdate < 10000
            );
            
            // Sort by kills (descending), then by deaths (ascending)
            allPlayers.sort((a, b) => {
                if (b.kills !== a.kills) return b.kills - a.kills;
                return a.deaths - b.deaths;
            });

            // Limit to top 10 players
            allPlayers = allPlayers.slice(0, 10);
            
            // Format time remaining as MM:SS if available
            let timeString = '';
            if (typeof roundTimeRemaining !== 'undefined') {
                const minutes = Math.floor(roundTimeRemaining / 60);
                const seconds = Math.floor(roundTimeRemaining % 60);
                timeString = `Until next round: ${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            }
            // Create table header
            let html = `
                <div style="text-align: center; margin-bottom: 10px; font-size: 20px; font-weight: bold;">
                    Leaderboard 
                    <span style="float: right; font-size: 16px;">
                        ${timeString}
                    </span>
                </div>
                <table style="width: 100%; border-collapse: collapse;">
                    <tr style="border-bottom: 1px solid #666;">
                        <th style="text-align: left; padding: 5px;">Player</th>
                        <th style="text-align: center; padding: 5px;">Kills</th>
                        <th style="text-align: center; padding: 5px;">Deaths</th>
                        <th style="text-align: right; padding: 5px;">Health</th>
                    </tr>
            `;
            // Add player rows
            allPlayers.forEach((player, index) => {
                const rowStyle = player.isLocal ? 'background-color: rgba(255, 255, 0, 0.2);' : '';
                const healthColor = player.health > 50 ? '#00ff00' : 
                                  player.health > 30 ? '#ffff00' : '#ff0000';
                
                html += `
                    <tr style="${rowStyle}">
                        <td style="padding: 5px;">${index + 1}. ${player.username}</td>
                        <td style="text-align: center; padding: 5px;">${player.kills}</td>
                        <td style="text-align: center; padding: 5px;">${player.deaths}</td>
                        <td style="text-align: right; padding: 5px; color: ${healthColor};">${player.health}%</td>
                    </tr>
                `;
            });
            
            html += '</table>';
            // Add instructions at the bottom
            html += `
                <div style="text-align: center; margin-top: 10px; font-size: 12px; color: #999;">
                    Press TAB to toggle leaderboard
                </div>
            `;
            leaderboard.innerHTML = html;
        }


        // Update the leaderboard periodically when visible
        setInterval(() => {
            const leaderboard = document.getElementById('leaderboard');
            if (leaderboard && leaderboard.style.display === 'block') {
                updateLeaderboard();
            }
        }, 1000); // Update every second when visible



        let mouseX = 0;
        let mouseY = 0;
        let targetCameraOffset = new THREE.Vector3(0, 2, 10);
        let mouseSensitivity = 0.002;
        let isPointerLocked = false;
        let lastMouseMoveTime = Date.now();
        const MOUSE_TIMEOUT = 3000; // Time in ms before camera starts returning to center
        let isThirdPerson = true; // Track camera mode
        const COCKPIT_OFFSET = new THREE.Vector3(0, 1.0, -0.6); // Changed from (0, 0.8, -0.8)



        // Add after audio context creation in startGame()
        let explosionSound;

        function createExplosionSound() {
            const duration = 0.5;
            const audioCtx = window.audioContext;
            
            // Create buffer for explosion sound
            const explosionBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
            const channelData = explosionBuffer.getChannelData(0);
            
            // Generate a deep boom with some noise
            for (let i = 0; i < explosionBuffer.length; i++) {
                const t = i / audioCtx.sampleRate;
                // Lower frequency for boom (30Hz)
                const baseFreq = 30;
                // Faster decay for punchier explosion
                const amplitude = Math.exp(-15 * t);
                // Add noise for crackle
                const noise = (Math.random() * 2 - 1) * Math.exp(-5 * t);
                
                channelData[i] = amplitude * (
                    Math.sin(2 * Math.PI * baseFreq * t) + // Base boom
                    0.5 * Math.sin(4 * Math.PI * baseFreq * t) + // First harmonic
                    0.25 * Math.sin(8 * Math.PI * baseFreq * t) + // Second harmonic
                    0.5 * noise // Noise component
                );
            }
            
            explosionSound = explosionBuffer;
        }
        // Track if explosion sound is currently playing
        let explosionSoundPlaying = false;

        function playExplosionSound() {
            if (!window.audioContext) return;
            if (isMuted) return;
            if (explosionSoundPlaying) return; // Don't play if already playing
            
            explosionSoundPlaying = true;
            
            const source = window.audioContext.createBufferSource();
            source.buffer = explosionSound;
            
            // Create a gain node for volume control
            const gainNode = window.audioContext.createGain();
            gainNode.gain.value = 1.5; // Loud!
            
            // Create a filter for more bass
            const filter = window.audioContext.createBiquadFilter();
            filter.type = 'lowshelf';
            filter.frequency.value = 150;
            filter.gain.value = 15; // More bass
            
            // Add a compressor for more punch
            const compressor = window.audioContext.createDynamicsCompressor();
            compressor.threshold.value = -20;
            compressor.knee.value = 25;
            compressor.ratio.value = 12;
            compressor.attack.value = 0.005;
            compressor.release.value = 0.25;
            
            // Connect everything
            source.connect(filter);
            filter.connect(compressor);
            compressor.connect(gainNode);
            gainNode.connect(window.audioContext.destination);
            
            // Reset the flag when sound ends
            source.onended = () => {
                explosionSoundPlaying = false;
            };
            
            source.start();
        }


        // Allow refuel at spawn points
        function checkForRefuel() {

            // Only check if we're at ground level and health isn't full
            if (player.position.y <= 36.5 && currentHealth < 100) {

                // Check if player is moving slowly enough to refuel
                const isStationary = currentSpeed < 0.1; // Very slow speed threshold

                // Check if on runway (within runway boundaries)
                const onRunway = player.position.x >= -5 && player.position.x <= 5 && 
                                Math.abs(player.position.z) <= 100;

                // Check if on carrier (using carrier deck dimensions)
                const onCarrier = Math.abs(player.position.x - carrierGroup.position.x) <= 20 && 
                                Math.abs(player.position.z - carrierGroup.position.z) <= 75;


                if (isStationary && (onRunway || onCarrier)) {
                    // Regenerate health
                    currentHealth = 100;
                    // console.log('refueling')
                    console.log('onRunway or onCarrier',currentHealth);
                    
                    // Optional: Show refuel message
                    showMessage("Refueled at airport! Health restored to 100%", true);

                    // Create visual feedback for health restore
                    const healthIndicator = document.createElement('div');
                    healthIndicator.style.position = 'fixed';
                    healthIndicator.style.top = '0';
                    healthIndicator.style.left = '0';
                    healthIndicator.style.width = '100%';
                    healthIndicator.style.height = '100%';
                    healthIndicator.style.border = '10px solid #00ff00';
                    healthIndicator.style.boxSizing = 'border-box';
                    healthIndicator.style.pointerEvents = 'none';
                    healthIndicator.style.zIndex = '1000';
                    healthIndicator.style.opacity = '0.5';
                    document.body.appendChild(healthIndicator);

                    // Fade out and remove the health indicator
                    setTimeout(() => {
                        healthIndicator.style.transition = 'opacity 0.5s';
                        healthIndicator.style.opacity = '0';
                        setTimeout(() => {
                            document.body.removeChild(healthIndicator);
                        }, 5000);
                    }, 3000);
                }
                else {
                    // console.log('not on runway or carrier');
                }
                
            }
        }


        // Add after other audio functions (createMissileSound, createExplosionSound)
        function setupEngineSound() {
            const audioCtx = window.audioContext;
            if (!audioCtx) return;

            engineOscillator = window.audioContext.createOscillator();
            const engineOscillator2 = window.audioContext.createOscillator();
            const engineOscillator3 = window.audioContext.createOscillator();
            
            // Create noise generator for jet sound
            const noiseBuffer = window.audioContext.createBuffer(1, window.audioContext.sampleRate * 2, window.audioContext.sampleRate);
            const noise = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                noise[i] = Math.random() * 2 - 1;
            }
            const noiseSource = window.audioContext.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            noiseSource.loop = true;
            
            // Create gain nodes for mixing
            gainNode = window.audioContext.createGain();
            const gainNode2 = window.audioContext.createGain();
            const gainNode3 = window.audioContext.createGain();
            const noiseGain = window.audioContext.createGain();
            
            // Set up filters for shaping the sound
            const filter = window.audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            
            // Configure oscillators with slight detuning
            engineOscillator.type = 'sawtooth';
            engineOscillator2.type = 'sine';
            engineOscillator3.type = 'square';
            
            // Connect everything
            engineOscillator.connect(gainNode);
            engineOscillator2.connect(gainNode2);
            engineOscillator3.connect(gainNode3);
            noiseSource.connect(noiseGain);
            
            gainNode.connect(filter);
            gainNode2.connect(filter);
            gainNode3.connect(filter);
            noiseGain.connect(filter);
            
            filter.connect(window.audioContext.destination);
            
            // Set initial values with lower gains to account for more oscillators
            gainNode.gain.setValueAtTime(0, window.audioContext.currentTime);
            gainNode2.gain.setValueAtTime(0, window.audioContext.currentTime);
            gainNode3.gain.setValueAtTime(0, window.audioContext.currentTime);
            noiseGain.gain.setValueAtTime(0, window.audioContext.currentTime);
            
            // Start all sound sources
            engineOscillator.start();
            engineOscillator2.start();
            engineOscillator3.start();
            noiseSource.start();

            // Store references for updating
            window.engineSound = {
                osc1: engineOscillator,
                osc2: engineOscillator2,
                osc3: engineOscillator3,
                gain1: gainNode,
                gain2: gainNode2,
                gain3: gainNode3,
                noise: noiseGain,
                filter: filter,
            };
        }


        // Add with other global variables at the top
        let gameStarted = false;

        // start ticker game on page load
        createTickerTape();

        // Modify startGame function to include ATC audio
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;

            startTime = performance.now();

            // based on vehicleName create the correct vehicle
            createPlayerVehicle();
            
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
                alert("Firefox is not supported because it runs too slow, please try another browser");
                return;
            }

            if (isMobileDevice) {
                console.log("Mobile device detected. Game experience may be limited.");
            }

            // Create audio context
            window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Setup all audio
            createMissileSound();
            createExplosionSound();
            setupEngineSound();
            createRearViewMirror();

            // Hide start screen immediately
            document.getElementById('startScreen').remove();
            
            // Start animation
            animate();


            // Only create joysticks on mobile devices
            if (isMobileDevice) {
                // Create joysticks for mobile
                leftJoystick = nipplejs.create({
                    zone: document.getElementById('leftJoystick'),
                    mode: 'static',
                    position: { left: '50px', bottom: '50px' },
                    color: 'white',
                    size: 120
                });

                rightJoystick = nipplejs.create({
                    zone: document.getElementById('rightJoystick'),
                    mode: 'static',
                    position: { right: '50px', bottom: '50px' },
                    color: 'white',
                    size: 120
                });

                // Left joystick handlers
                leftJoystick.on('move', (evt, data) => {
                    const forward = data.vector.y;
                    const side = data.vector.x;
                    
                    // Normalize the values
                    leftJoystickData.x = side;
                    leftJoystickData.y = forward;
                    
                    console.log('Left Joystick:', leftJoystickData); // Debug output
                });

                leftJoystick.on('end', () => {
                    leftJoystickData = { x: 0, y: 0 };
                    console.log('Left Joystick Reset'); // Debug output
                });


                // Right joystick handlers
                rightJoystick.on('start', (evt, data) => {
                    isRightJoystickDragged = false;
                });

                // Right joystick handlers
                rightJoystick.on('move', (evt, data) => {
                    const forward = data.vector.y;
                    
                    isRightJoystickDragged = true;

                    // Only use Y axis for throttle
                    rightJoystickData.y = forward;
                    rightJoystickData.x = 0;
                    
                    console.log('Right Joystick:', rightJoystickData); // Debug output
                });

                rightJoystick.on('end', () => {
                    rightJoystickData = { x: 0, y: 0 };
                    console.log('Right Joystick Reset'); // Debug output

                    // Only shoot if the joystick wasn't dragged
                    if (!isRightJoystickDragged) {
                        shootMissile();
                    }
                        
                });

            }


        }

        // Player movement constants
        let currentSpeed = 0; // Changed from minSpeed to 0
        let currentHeading = 0; // Direction in degrees (0-360) where the plane is heading
        let currentVerticalSpeed = 0;

       

        let yawAngle = 0;
        let currentRoll = 0;
        let currentPitch = 0;
        const rollRecoverySpeed = 0.9; // 1.5x from 0.6

        // Modify these constants for more dramatic effects
        // let liftFactor = 0.015; // Increased from 0.001 (1.5x)
        let liftFactor=0.35;
        // let gravityFactor = 0.036; // Increased from 0.016 (2.25x for more dramatic effect)
        let gravityFactor = 0.2;
        let minLiftSpeed = 0.2115; // Increased from 0.141 (1.5x to match takeoffSpeed)

        // Create ocean (on the left side)
        const oceanGeometry = new THREE.PlaneGeometry(2000, 2000);
        const oceanMaterial = new THREE.MeshPhongMaterial({
            color: 0x006994,
            shininess: 60
        });
        const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
        ocean.rotation.x = -Math.PI / 2;
        ocean.position.y = 35; // Changed from -20 to match terrain height
        ocean.position.x = -1450;
        scene.add(ocean);

        // <chatbase.co chat bubble cloud>
            // Create chat bubble cloud for chatbase.co
            const chatBubbleMainGroup = new THREE.Group();

            // Load texture
            const chatbaseTexture = new THREE.TextureLoader().load('/assets/fly_chatbase_bg.jpg');
            chatbaseTexture.wrapS = THREE.RepeatWrapping;
            chatbaseTexture.wrapT = THREE.RepeatWrapping;
            chatbaseTexture.repeat.set(1, 1);

            // Create the main bubble shape
            const chatBubbleSphereGeometry = new THREE.SphereGeometry(10, 32, 32);
            const chatBubbleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 1,
                map: chatbaseTexture
            });
            const chatBubbleSphere = new THREE.Mesh(chatBubbleSphereGeometry, chatBubbleMaterial);
            
            // Create the bubble tail
            const chatBubbleTailGeometry = new THREE.ConeGeometry(5, 10, 32);
            const chatBubbleTail = new THREE.Mesh(chatBubbleTailGeometry, chatBubbleMaterial);
            chatBubbleTail.position.set(-6, -10, -5);
            chatBubbleTail.rotation.z = -3.7;
            
            // Add bubble and tail to group
            chatBubbleMainGroup.add(chatBubbleSphere);
            chatBubbleMainGroup.add(chatBubbleTail);

            // Add sign with chatbase logo
            const chatBubbleLogoSignGeometry = new THREE.PlaneGeometry(12, 4); // Scaled down from 1200:390
            const chatBubbleLogoSignTexture = new THREE.TextureLoader().load('/assets/fly_chatbase.png');
            const chatBubbleLogoSignMaterial = new THREE.MeshBasicMaterial({
                map: chatBubbleLogoSignTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            const chatBubbleLogoSign = new THREE.Mesh(chatBubbleLogoSignGeometry, chatBubbleLogoSignMaterial);
            chatBubbleLogoSign.position.set(-1, -2, 10);
            chatBubbleMainGroup.add(chatBubbleLogoSign);

            // Position the chat bubble near runway
            chatBubbleMainGroup.position.set(40, 40, RUNWAY_SPAWN_Z-100);

            // Add floating animation
            function animateChatBubble() {
                chatBubbleMainGroup.position.y = 80 + Math.sin(Date.now() * 0.001) * 5;
                requestAnimationFrame(animateChatBubble);
            }
            animateChatBubble();
            
            scene.add(chatBubbleMainGroup);
        // </chatbase.co chat bubble cloud>

        

        // <aircraft carrier>
            const carrierGroup = new THREE.Group();

            // Main hull
            const hullGeometry = new THREE.BoxGeometry(40, 10, 150);
            const hullMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.y = -5; // Half height below deck
            carrierGroup.add(hull);
            
            // Flight deck
            const deckGeometry = new THREE.BoxGeometry(40, 0.5, 150);
            const deckMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const deck = new THREE.Mesh(deckGeometry, deckMaterial);
            deck.position.y = 0.25; // Half height of deck
            carrierGroup.add(deck);
            
            // Runway markings
            const markingMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            
            // Center line
            const centerLineGeometry = new THREE.PlaneGeometry(1, 140);
            const centerLine = new THREE.Mesh(centerLineGeometry, markingMaterial);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.51; // Just above deck
            centerLine.position.z = 0;
            carrierGroup.add(centerLine);
            
            // Landing markers
            for (let z = -60; z <= 60; z += 20) {
                const markerGeometry = new THREE.PlaneGeometry(20, 2);
                const marker = new THREE.Mesh(markerGeometry, markingMaterial);
                marker.rotation.x = -Math.PI / 2;
                marker.position.y = 0.51;
                marker.position.z = z;
                carrierGroup.add(marker);
            }
            
            // Island (control tower)
            const islandGeometry = new THREE.BoxGeometry(10, 15, 30);
            const islandMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.position.set(15, 7.5, 20); // Right side of carrier
            carrierGroup.add(island);

            // <seats.aero sponsor>
                // Add SEATS.AERO text to the front of the island towards user spawn
                const islandTextBannerGeometry = new THREE.PlaneGeometry(20, 5);
                const islandTextBannerMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const islandTextBannerPlane = new THREE.Mesh(islandTextBannerGeometry, islandTextBannerMaterial);
                
                // Position on the side facing the runway
                islandTextBannerPlane.position.set(15, 7.55, 35.1);
                
                // Create canvas for text
                const islandTextBannerCanvas = document.createElement('canvas');
                const islandTextBannerContext = islandTextBannerCanvas.getContext('2d');
                islandTextBannerCanvas.width = 512;
                islandTextBannerCanvas.height = 128;
                
                // Draw text
                islandTextBannerContext.fillStyle = 'white';
                islandTextBannerContext.font = 'bold 35px system-ui';
                islandTextBannerContext.textAlign = 'center';
                islandTextBannerContext.textBaseline = 'middle';
                islandTextBannerContext.fillText('SEATS.AERO', islandTextBannerCanvas.width/2, islandTextBannerCanvas.height/2);
                
                // Create texture from canvas
                const islandTextBannerTexture = new THREE.CanvasTexture(islandTextBannerCanvas);
                islandTextBannerMaterial.map = islandTextBannerTexture;
                
                carrierGroup.add(islandTextBannerPlane);
            // </seats.aero sponsor>
            
            // <seats.aero sponsor>
                // Add SEATS.AERO text to the side of the island
                const islandTextBanner2Geometry = new THREE.PlaneGeometry(20, 5);
                const islandTextBanner2Material = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8,
                    side: THREE.DoubleSide
                });
                const islandTextBanner2Plane = new THREE.Mesh(islandTextBanner2Geometry, islandTextBanner2Material);
                
                // Position on the side facing the ocean
                islandTextBanner2Plane.position.set(20.1, 7.55, 20);
                islandTextBanner2Plane.rotation.y = Math.PI / 2; // Rotate 90 degrees left
                
                // Create canvas for text
                const islandTextBanner2Canvas = document.createElement('canvas');
                const islandTextBanner2Context = islandTextBanner2Canvas.getContext('2d');
                islandTextBanner2Canvas.width = 612;
                islandTextBanner2Canvas.height = 128;
                
                // Draw text
                islandTextBanner2Context.fillStyle = 'white';
                islandTextBanner2Context.font = 'bold 90px system-ui';
                islandTextBanner2Context.textAlign = 'center';
                islandTextBanner2Context.textBaseline = 'middle';
                islandTextBanner2Context.fillText('SEATS.AERO', islandTextBanner2Canvas.width/2, islandTextBanner2Canvas.height/2);
                
                // Create texture from canvas
                const islandTextBanner2Texture = new THREE.CanvasTexture(islandTextBanner2Canvas);
                islandTextBanner2Material.map = islandTextBanner2Texture;
                
                carrierGroup.add(islandTextBanner2Plane);
            // </seats.aero sponsor>
            
            // Radar/antenna
            const radarBaseGeometry = new THREE.CylinderGeometry(2, 2, 5, 8);
            const radarBase = new THREE.Mesh(radarBaseGeometry, islandMaterial);
            radarBase.position.set(15, 17.5, 20);
            carrierGroup.add(radarBase);
            
            const radarDishGeometry = new THREE.CylinderGeometry(4, 4, 1, 8);
            const radarDish = new THREE.Mesh(radarDishGeometry, new THREE.MeshPhongMaterial({ color: 0x888888 }));
            radarDish.rotation.x = Math.PI / 2;
            radarDish.position.set(15, 21, 20);
            
            carrierGroup.add(radarDish);
            
            // Animate radar rotation
            function animateRadar() {
                radarDish.rotation.z += 0.05; // Adjust speed by changing this value
                requestAnimationFrame(animateRadar);
            }
            animateRadar();
            
            // Add some deck lights
            const lightGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const lightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 1.0
            });
            
            // Edge lights
            for (let z = -70; z <= 70; z += 10) {
                const leftLight = new THREE.Mesh(lightGeometry, lightMaterial.clone());
                leftLight.position.set(-19, 0.5, z);
                carrierGroup.add(leftLight);
                
                const rightLight = new THREE.Mesh(lightGeometry, lightMaterial.clone());
                rightLight.position.set(19, 0.5, z);
                carrierGroup.add(rightLight);
                
            }
            // Position carrier in the ocean
            carrierGroup.position.set(-600, 35, 0);
            
            // Create collision box for the carrier deck
            const deckBoundingBox = new THREE.Box3(
                new THREE.Vector3(-20, 35, -75).add(carrierGroup.position),
                new THREE.Vector3(20, 36, 75).add(carrierGroup.position)
            );
            carrierGroup.deckBoundingBox = deckBoundingBox;
            
            // Add to scene
            scene.add(carrierGroup);
        // </aircraft carrier>


        // Create beach along the coast
        const beachGeometry = new THREE.PlaneGeometry(100, 4000);
        const beachMaterial = new THREE.MeshPhongMaterial({
            color: 0xf2d16b
        });
        const beach = new THREE.Mesh(beachGeometry, beachMaterial);
            beach.rotation.x = -Math.PI / 2;
            beach.position.y = 35; // Changed from -19.9 to match terrain height
            beach.position.x = -400;
            scene.add(beach);

        // <beach text> 
            // Create text on beach
            const beachTextCanvas = document.createElement('canvas');
            const beachTextCtx = beachTextCanvas.getContext('2d');
            beachTextCanvas.width = 4096; // 2x wider to prevent text cutoff
            beachTextCanvas.height = 512; // Doubled height for bigger text

            // Create text mesh outside font load
            const beachTextGeometry = new THREE.PlaneGeometry(200, 25); // Doubled width to match wider canvas
            const beachTextMesh = new THREE.Mesh(beachTextGeometry, new THREE.MeshBasicMaterial());
            
            // Position text on beach
            beachTextMesh.rotation.x = -Math.PI / 2;
            beachTextMesh.rotation.z = -Math.PI / 2;
            beachTextMesh.position.set(-400, 35.1, 0); // Slightly above beach
            
            scene.add(beachTextMesh);

            // Load custom font
            const beachTextFontFace = new FontFace('FlyGummy', 'url(assets/fly_sourgummy.ttf)');
            beachTextFontFace.load().then(function(font) {
                document.fonts.add(font);
                
                // Draw text
                beachTextCtx.font = '240px FlyGummy'; // Doubled font size from 120px to 240px
                beachTextCtx.fillStyle = '#FF0000';
                beachTextCtx.textAlign = 'center';
                beachTextCtx.fillText('CALL FOR A GOOD TIME... 628-899-2257', beachTextCanvas.width/2, beachTextCanvas.height/2);
                
                // Create texture from canvas
                const beachTextTexture = new THREE.CanvasTexture(beachTextCanvas);
                const beachTextMaterial = new THREE.MeshBasicMaterial({
                    map: beachTextTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });

                // Update text mesh material
                beachTextMesh.material = beachTextMaterial;
            });
        // </beach text>

        // Add after missiles array declaration
        const buildings = []; // Array to store building references

        // Modify createBuilding function
        function createBuilding() {
            // these are the square flat buildings
            const height = Math.random() * 5 + 3;  // Lower buildings
            const width = Math.random() * 4 + 3;
            const depth = Math.random() * 4 + 3;
            
            // Create building geometry
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create wall texture
            const wallCanvas = document.createElement('canvas');
            wallCanvas.width = 128;
            wallCanvas.height = 128;
            const wallCtx = wallCanvas.getContext('2d');
            
            // White walls
            wallCtx.fillStyle = '#FFFFFF';
            wallCtx.fillRect(0, 0, 128, 128);
            
            // Windows
            const windowGeometry = new THREE.BoxGeometry(width * 0.2, height * 0.2, 0.1);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaff,
                emissive: 0x444444
            });
            
            const wallTexture = new THREE.CanvasTexture(wallCanvas);
            
            // Create materials array for each face of the cube
            const materials = [
                new THREE.MeshPhongMaterial({ map: wallTexture }), // right
                new THREE.MeshPhongMaterial({ map: wallTexture }), // left
                new THREE.MeshPhongMaterial({ color: 0xFF8C44 }), // top (orange roof)
                new THREE.MeshPhongMaterial({ map: wallTexture }), // bottom
                new THREE.MeshPhongMaterial({ map: wallTexture }), // front
                new THREE.MeshPhongMaterial({ map: wallTexture })  // back
            ];
            
            const building = new THREE.Mesh(buildingGeometry, materials);
            
            // Position buildings on top of ground
            building.position.x = Math.random() * 400 - 200;
            building.position.y = height/2 + 35; // Center + ground height
            building.position.z = Math.random() * 800 - 400;
            
            // Keep buildings away from runway and approach lights
            while (Math.abs(building.position.x) < 30 && Math.abs(building.position.z) < 150) { // Increased z clearance to 150
                building.position.x = Math.random() * 400 - 200;
                building.position.z = Math.random() * 800 - 400;
            }
            
            // Add windows that emit light - adjusted positions to be lower on building
            const windowPositions = [
                [-width/4, height * 0.05, depth/2],  // Lower row
                [width/4, height * 0.05, depth/2],
                [-width/4, height * 0.25, depth/2],  // Upper row
                [width/4, height * 0.25, depth/2]
            ];
            
            windowPositions.forEach(pos => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(...pos);
                building.add(window);
            });
            // Create collision box
            const boundingBox = new THREE.Box3().setFromObject(building);
            building.boundingBox = boundingBox;
            
            buildings.push(building);
            scene.add(building);
        }

        // Create multiple buildings
        for (let i = 0; i < 100; i++) {  // More buildings for a denser town
            createBuilding();
        }

        // Directional light setup for softer shadows
        const sunLight = new THREE.DirectionalLight(0xfff0e0, 0.7);
        sunLight.position.set(100, 100, 50);
        sunLight.castShadow = true;


        // Set shadow quality
        sunLight.shadow.mapSize.width = 1024;
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;


        // Add slightly warmer ambient light
        const ambientLight = new THREE.AmbientLight(0xfff6e6, 0.5); // Less intense, slightly warm ambient
        scene.add(ambientLight);

        // Adjust shadow darkness
        sunLight.shadow.bias = -0.001;
        sunLight.shadow.darkness = 0.5;

        scene.add(sunLight);

        // Controls
        let keys = {};
        window.addEventListener('keydown', (event) => { keys[event.code] = true; });
        window.addEventListener('keyup', (event) => { keys[event.code] = false; });

        // Add after player constants
        let missiles = [];
        const PROJECTILE_SPEED = 2.0; // Increased from 0.6 to match new game speeds
        const MAX_MISSILES = 50;
        const FIRE_RATE = 10;  // Shots per second
        let lastFireTime = Date.now();  // Initialize with current time
        const MAX_MISSILE_DISTANCE = 100;

        // Create foam missile geometry - increased sizes
        const missileGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2.0, 8); // Doubled length to 2.0
        const missileTipGeometry = new THREE.ConeGeometry(0.2, 0.4, 8); // Kept tip size
        const missileMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff4444,
            roughness: 0.8,  // Make it look more like foam
            metalness: 0.1   // Slight sheen like nerf foam
        }); 
        const missileTipMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xffaa44,
            roughness: 0.7,
            metalness: 0.2
        });

        // Update the shootMissile function to include rate limiting
        function shootMissile() {

            if(window.gameEnded) {
                // avoid shooting geting stuck after crashing on mobile
                // because tapping screen emulates space there (to restart game)
                return;
            }
            if(vehicleName == 'a10') {
                isA10Shooting=true;
            }
    
            let fireDelay = 1000 / FIRE_RATE;  // Convert to milliseconds between shots

            // Check if enough time has passed since last shot
            const currentTime = Date.now();
            if (currentTime - lastFireTime < fireDelay) {
                // console.log('Too soon to fire again');
                // console.log(currentTime,lastFireTime,currentTime - lastFireTime,fireDelay);
                return; // Too soon to fire again
            }
            
            // Update last fire time
            lastFireTime = currentTime;

            if (missiles.length >= MAX_MISSILES) {
                const oldestMissile = missiles.shift();
                scene.remove(oldestMissile);
            }

            const missile = new THREE.Group();
            
            // Create missile body with more detail
            const body = new THREE.Mesh(missileGeometry, missileMaterial);
            body.rotation.x = Math.PI / 2; // Rotate to align with flight direction
            
            const tip = new THREE.Mesh(missileTipGeometry, missileTipMaterial);
            tip.position.z = 1.2; // Adjusted for longer body
            tip.rotation.x = Math.PI / 2; // Align with body
            
            // Add foam texture details - rings along the longer body
            const ringGeometry = new THREE.TorusGeometry(0.21, 0.05, 8, 16);
            const ringCount = 5; // More rings for longer body
            for(let i = 0; i < ringCount; i++) {
                const ring = new THREE.Mesh(ringGeometry, missileMaterial);
                ring.position.z = (i * 0.4) - 0.8; // Spread rings along body
                missile.add(ring);
            }
            
            missile.add(body);
            missile.add(tip);
            

            if(vehicleName == 'cessna' || vehicleName == 'f16' || vehicleName == 'apache' || vehicleName == 'a10' || vehicleName == 'triangle') {

                // Position missile at plane's nose and align with flight direction
                missile.position.copy(player.position);
                missile.rotation.copy(player.rotation);
                missile.translateZ(-2.5);
                
                // Calculate missile velocity
                const baseVelocity = new THREE.Vector3(0, 0, -PROJECTILE_SPEED);
                baseVelocity.applyQuaternion(player.quaternion);
                
                // Add plane's velocity
                const planeVelocity = new THREE.Vector3(0, 0, -currentSpeed);
                planeVelocity.applyQuaternion(player.quaternion);
                
                // Combine velocities
                missile.velocity = baseVelocity.add(planeVelocity);
            }
            if(vehicleName == 'tank') {
                // Position missile at tank's turret and align with turret rotation
                missile.position.copy(player.position);
                missile.position.y += 2; // Raise to turret height
                missile.rotation.copy(player.rotation);
                missile.rotation.x = tankTurret.rotation.x; // Match turret elevation
                missile.translateZ(-2.5);
                
                // Calculate missile velocity based on turret direction
                const baseVelocity = new THREE.Vector3(0, 0, -PROJECTILE_SPEED);
                baseVelocity.applyAxisAngle(new THREE.Vector3(1, 0, 0), tankTurret.rotation.x); // Apply turret elevation
                baseVelocity.applyQuaternion(player.quaternion); // Apply tank rotation
                
                // Add tank's velocity
                const tankVelocity = new THREE.Vector3(0, 0, -currentSpeed);
                tankVelocity.applyQuaternion(player.quaternion);
                
                // Combine velocities
                missile.velocity = baseVelocity.add(tankVelocity);
            }
            
            playMissileSound();
            
            scene.add(missile);
            missiles.push(missile);
            
            if(vehicleName == 'cessna') {
                // Add some "recoil" effect
                if(!isMobileDevice && isAirborne) {
                    currentPitch -= 0.02;
                }
            }
        }

        // Base turbulence variables
        let baseTurbulenceIntensity = 0.025; // Base intensity
        let baseTurbulenceFrequency = 0.01; // Base frequency

        // Add this helper function to ensure audio values are valid
        function clampAudioValue(value) {
            // Ensure the value is finite and within reasonable bounds
            if (!isFinite(value)) return 0;
            return Math.max(0, Math.min(value, 100));
        }

        // Add this helper function at the top
        function isValidAudioValue(value) {
            return typeof value === 'number' && isFinite(value) && !isNaN(value);
        }

        // Add time system variables at the top with other constants
        // start time of game
        let gameTime = 12000; // Start at 18:00 (6 PM - sunset)
        // let gameTime = 24000; // Start at 18:00 (6 PM - sunset)
        const dayLength = 1200; // 1200 seconds = 20 minutes per day
        const timeScale = 1; // We'll increment by 1 tick per frame

        // Add after other global variables
        let lastTime = performance.now();
        let frameCount = 0;
        let currentFps = 0;

        // Modify updateMetrics function to include FPS
        function updateMetrics() {
            const metricsDiv = document.getElementById('metrics');
            
            metricsDiv.style.display = 'block';
            
            // Add FPS to the start of metrics display with color coding
            const fpsColor = currentFps > 50 ? '#00ff00' : // Green for good FPS
                             currentFps > 30 ? '#ffff00' : // Yellow for okay FPS
                             '#ff0000';                    // Red for poor FPS
            
            // Add health
            const healthColor = currentHealth > 50 ? '#00ff00' :
            currentHealth > 30 ? '#ffff00' :
                             '#ff0000';                   
            const healthDisplay = `<span style="color: ${healthColor}">Health: ${currentHealth}%</span><br>`;
            
            const fpsDisplay = `<span style="color: ${fpsColor}">FPS: ${currentFps}</span> | `;
            
            // Convert game time to hours and minutes
            const gameHours = Math.floor((gameTime / 24000) * 24);
            const gameMinutes = Math.floor(((gameTime / 24000) * 24 % 1) * 60);
            const timeString = `${gameHours.toString().padStart(2, '0')}:${gameMinutes.toString().padStart(2, '0')}`;
            const altitude = Math.round((player.position.y - 35.2) * 33.33);
            const speedKmh = Math.round(currentSpeed * 525); // Allow speed to go higher than maxSpeed, but maxSpeed is still 1235 km/h
            const takeoffSpeedKmh = Math.round(takeoffSpeed * 525); // Changed from 2100 to 525
            const pitch = Math.round(currentPitch * (180/Math.PI));
            const roll = Math.round(currentRoll * (180/Math.PI));
            const heading = Math.round(((yawAngle * (180/Math.PI)) + 180) % 360);
            const windSpeedKmh = Math.round(windSpeed * 100);
            const windDegrees = Math.round((windDirection * (180/Math.PI) + 180) % 360);
            const throttlePercent = Math.round((currentSpeed / maxSpeed) * 100);
            // Count the number of other planes (otherPlayers) plus 1 for the current player
            const playerCount = (otherPlayers ? otherPlayers.size : 0) + 1;
            playerCountText = `Players Online: ${playerCount}`;
            if(otherPlayers.size == 0) {
                // playerCountText = 'Disconnected from server, you are in cooldown mode. Try again in a minute (this is to avoid spammers)';
                playerCountText = 'Disconnected from server, reconnecting...stand by!';
                            }
            
            // Hide controls after 10 seconds and don't show on mobile
            let controlsText = '';
            if(!isMobileDevice && performance.now() - startTime < 10000) {
                controlsText =
                    `<br/>W/S - Throttle Up/Down<br>` +
                    `‚Üê/‚Üí - Roll Left/Right<br>` +
                    `A/D - Rudder Left/Right<br>` +
                    `‚Üë/‚Üì - Pitch Up/Down<br>` +
                    `SPACE - Shoot Missiles<br>` +
                    `Right SHIFT - Go SuperTURBO XXL<br>` +
                    `V - Toggle Camera View<br>` +
                    `M - Mute Sound<br>` +
                    `T - Chat<br>` +
                    `TAB - Leaderboard<br>`;
            }
            else {
                controlsText = '';
            }
            metricsDiv.innerHTML = 
                fpsDisplay +  // Add FPS at the top
                (isLocalGame ? 
                '<span style="color: #ffff00">LOCAL DEBUG MODE</span><br>' : '') +
                `Time: ${timeString}<br>` +
                `<span style="color: #ff0000">${playerCountText}</span><br>` +
                healthDisplay +
                `<span style="color: #ffff00">Score: ${score.toLocaleString()}</span><br>` +
                `<br>` +
                `Altitude: ${altitude} ft<br>` +
                `Speed: ${speedKts} kts<br>` +
                // `Throttle: ${throttlePercent}%<br>` +
                // `Pitch: ${pitch}¬∞<br>` +
                // `Roll: ${roll}¬∞<br>` +
                // `Heading: ${heading}¬∞<br>` +
                // `Wind: ${windSpeedKmh} km/h at ${windDegrees}¬∞<br>` +
                `Vertical Speed: ${Math.round(verticalSpeed*3281/60)} ft/min<br>` +
                `<br>` +
                `<b>Missions:</b><br/>` +
                `- Shoot down all the balloons</br>` +
                `- Shoot down other planes :D</br>` +
                `- Fly to space</br>` +
                controlsText
                ;
        }

        // Update time and lighting update function
        function updateDayNightCycle() {
            // Update time
            // gameTime += deltaTime * 240;
            gameTime += deltaTime * 60;
            if (gameTime >= 24000) {
                gameTime -= 24000;
            }

            // console.log('Altitude',player.position.y)

            if(gameStarted) {
                // Calculate altitude-based darkness
                const altitudeFactor = Math.max(0, Math.min(1, 
                    (player.position.y - SPACE_ALTITUDE) / SPACE_TRANSITION_RANGE
                ));
            }
            else {
                altitudeFactor = 0;
            }

            // Calculate transition factors for dawn and dusk
            const dawnStart = 4000; // Earlier dawn
            const dawnEnd = 6000;  // Earlier dawn end
            const duskStart = 19000; // Later dusk start
            const duskEnd = 21000;  // Later dusk end
            
            let transitionFactor = 0;
            let planetVisibility = 0;
            
            if (gameTime >= dawnStart && gameTime <= dawnEnd) {
                // Dawn transition (night to day)
                transitionFactor = (gameTime - dawnStart) / (dawnEnd - dawnStart);
                planetVisibility = Math.max(0.5, 1 - transitionFactor); // Keep 10% minimum visibility
            } else if (gameTime >= duskStart && gameTime <= duskEnd) {
                // Dusk transition (day to night)
                transitionFactor = 1 - ((gameTime - duskStart) / (duskEnd - duskStart));
                planetVisibility = Math.max(0.5, 1 - transitionFactor); // Keep 10% minimum visibility
            } else if (gameTime > dawnEnd && gameTime < duskStart) {
                // Full day
                transitionFactor = 1;
                planetVisibility = 0.5; // 10% visibility during day
            } else {
                // Full night
                planetVisibility = 1;
            }
            
            // Update mars opacity
            if (typeof marsMaterial !== 'undefined' && marsMaterial) {
                marsMaterial.opacity = planetVisibility;
            }
            if (typeof jupiterMaterial !== 'undefined' && jupiterMaterial) {
                jupiterMaterial.opacity = planetVisibility;
            }
            
            // Define day and night colors/intensities
            const dayColor = 0xfff0e0;
            const nightColor = 0x2b4c8c;
            const daySkyColor = 0x7FAFFF;
            const nightSkyColor = 0x000000;
            
            // Colors and intensities based on both time and altitude
            const timeBasedSunColor = new THREE.Color(nightColor).lerp(new THREE.Color(dayColor), transitionFactor);
            const timeBasedSkyColor = new THREE.Color(nightSkyColor).lerp(new THREE.Color(daySkyColor), transitionFactor);
            
            // Darken colors based on altitude
            const finalSunColor = timeBasedSunColor.lerp(new THREE.Color(nightColor), altitudeFactor);
            const finalSkyColor = timeBasedSkyColor.lerp(new THREE.Color(nightSkyColor), altitudeFactor);
            
            // Calculate final intensities considering both time and altitude
            const timeBasedSunIntensity = 0.5 + (transitionFactor * 0.8); // 0.2 to 1.0
            const timeBasedAmbientIntensity = 0.25 + (transitionFactor * 0.1); // 0.7 to 0.8
            
            const finalSunIntensity = timeBasedSunIntensity * (1 - altitudeFactor * 0.8);
            const finalAmbientIntensity = timeBasedAmbientIntensity * (1 - altitudeFactor * 0.8);
            
            // Apply final color values
            sunLight.color.copy(finalSunColor);
            sunLight.intensity = finalSunIntensity;
            ambientLight.intensity = finalAmbientIntensity;
            scene.background.copy(finalSkyColor);
            scene.fog.color.copy(finalSkyColor);
            
            // Update runway lights based on both time and altitude factors
            const runwayLightIntensity = Math.max(0, 1.5 - (transitionFactor * 1.5)) + altitudeFactor;
            runwayLights.forEach(light => {
                light.mesh.material.opacity = runwayLightIntensity;
            });
        }

        // Create different types of clouds
        function createLowCloud() {
            const cloudGroup = new THREE.Group();
            const blockGeometry = new THREE.BoxGeometry(4, 2, 4);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9,
                flatShading: true
            });

            // Larger, denser cumulus-style clouds
            const width = 4 + Math.floor(Math.random() * 3);
            const length = 5 + Math.floor(Math.random() * 4);
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < length; z++) {
                    const height = Math.random() > 0.5 ? 2 : 3;
                    for (let y = 0; y < height; y++) {
                        const block = new THREE.Mesh(blockGeometry, cloudMaterial);
                        block.position.set(
                            x * 3.5 + (Math.random() - 0.5) * 0.5,
                            y * 1.5,
                            z * 3.5 + (Math.random() - 0.5) * 0.5
                        );
                        cloudGroup.add(block);
                    }
                }
            }

            // Position between 2,000-6,500 feet
            cloudGroup.position.y = 60 + Math.random() * 60; // ~2000-6500 feet
            return cloudGroup;
        }

        function createMidCloud() {
            const cloudGroup = new THREE.Group();
            const blockGeometry = new THREE.BoxGeometry(4, 1.5, 4);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });

            // Flatter, more spread out alto-style clouds
            const width = 5 + Math.floor(Math.random() * 4);
            const length = 6 + Math.floor(Math.random() * 5);
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < length; z++) {
                    if (Math.random() > 0.3) { // Some gaps
                        const block = new THREE.Mesh(blockGeometry, cloudMaterial);
                        block.position.set(
                            x * 4 + (Math.random() - 0.5),
                            0,
                            z * 4 + (Math.random() - 0.5)
                        );
                        cloudGroup.add(block);
                    }
                }
            }

            // Position between 6,500-15,000 feet
            cloudGroup.position.y = 195 + Math.random() * 255; // ~6500-15000 feet
            return cloudGroup;
        }

        function createHighCloud() {
            const cloudGroup = new THREE.Group();
            const blockGeometry = new THREE.BoxGeometry(5, 0.5, 5);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.6,
                flatShading: true
            });

            // Thin, wispy cirrus-style clouds
            const width = 8 + Math.floor(Math.random() * 5);
            const length = 10 + Math.floor(Math.random() * 6);
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < length; z++) {
                    if (Math.random() > 0.5) { // Very sparse
                        const block = new THREE.Mesh(blockGeometry, cloudMaterial);
                        block.position.set(
                            x * 5 + (Math.random() - 0.5) * 2,
                            0,
                            z * 5 + (Math.random() - 0.5) * 2
                        );
                        cloudGroup.add(block);
                    }
                }
            }

            // Position above 15,000 feet
            cloudGroup.position.y = 450 + Math.random() * 150; // ~15000-20000 feet
            return cloudGroup;
        }

        // Create multiple clouds at different levels
        const clouds = [];
        
        // Low-level clouds (more numerous)
        for (let i = 0; i < 50; i++) {  // Increased from 20 to 50
            const cloud = createLowCloud();
            cloud.position.x = Math.random() * 1400 - 700;  // Wider spread
            cloud.position.z = Math.random() * 1400 - 700;
            clouds.push(cloud);
            scene.add(cloud);
        }

        // Mid-level clouds
        for (let i = 0; i < 40; i++) {  // Increased from 15 to 40
            const cloud = createMidCloud();
            cloud.position.x = Math.random() * 1600 - 800;  // Even wider spread
            cloud.position.z = Math.random() * 1600 - 800;
            clouds.push(cloud);
            scene.add(cloud);
        }

        // High-level clouds (fewer)
        for (let i = 0; i < 30; i++) {  // Increased from 10 to 30
            const cloud = createHighCloud();
            cloud.position.x = Math.random() * 1800 - 900;  // Widest spread
            cloud.position.z = Math.random() * 1800 - 900;
            clouds.push(cloud);
            scene.add(cloud);
        }

        // Update clouds with different speeds based on altitude
        function updateClouds() {
            clouds.forEach((cloud) => {
                // Higher clouds move faster, make speed frame-rate independent
                const speed = (cloud.position.y > 400 ? 0.2 : 
                              cloud.position.y > 200 ? 0.15 : 0.1) * deltaTime * 60;
                
                cloud.position.x += speed;
                
                // Reset cloud position when it goes too far
                if (cloud.position.x > 700) {
                    cloud.position.x = -700;
                    cloud.position.z = Math.random() * 1400 - 700;
                }
            });
        }

        // Update missile movement with smarter cleanup
        function updateMissiles() {
             // Create a new array for missiles to keep
            const activeMissiles = [];

            // console.log(missiles.length);

            for (let i = missiles.length - 1; i >= 0; i--) {
                const missile = missiles[i];
                
                // Check collisions with targets (balloons)
                for (let j = targets.length - 1; j >= 0; j--) {
                    const target = targets[j];
                    target.boundingBox.setFromObject(target);
                    
                    if (target.boundingBox.containsPoint(missile.position)) {
                        // Create hit effect
                        createHitEffect(missile.position);
                        
                        // Remove missile and target
                        scene.remove(missile);
                        scene.remove(target);
                        missiles.splice(i, 1);
                        targets.splice(j, 1);
                        
                        // Update score ONLY in the overlay
                        balloonsHit++;
                        updateScoreDisplay();
                        
                        // Add points for hitting balloon
                        score += 50;
                        break;
                    }
                }
                
                // Move missile based on its velocity and deltaTime
                missile.position.x += missile.velocity.x * deltaTime * 60;
                missile.position.y += missile.velocity.y * deltaTime * 60;
                missile.position.z += missile.velocity.z * deltaTime * 60;
                
                // Add gravity effect (make frame-rate independent)
                missile.velocity.y -= 0.0005 * deltaTime * 60;
                
                // Check if missile has gone too far
                if (missile.position.distanceTo(player.position) > MAX_MISSILE_DISTANCE) {
                    scene.remove(missile);
                    missiles.splice(i, 1);
                    continue;
                }
                
                // Rotate missile to face direction of travel
                const direction = new THREE.Vector3().copy(missile.velocity).normalize();
                missile.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
                
                activeMissiles.push(missile);
                
            }

            // Update missiles array with only active missiles
            missiles = activeMissiles;

        }

        let gameOverleaderboardTimeout=setTimeout(() => {}, 100);

        // Add gameOver function
        function gameOver(message) {
            // Prevent multiple calls to gameOver
            if (window.gameEnded) return;
            window.gameEnded = true;

            console.log('gameOver')
            
            // Show message
            showMessage(message);

            // Stop the game loop
            cancelAnimationFrame(animationFrameId);
            
            // Reset all controls and movement
            keys = {};
            currentSpeed = 0;
            currentRoll = 0;
            currentPitch = 0;
            leftJoystickData = { x: 0, y: 0 };
            rightJoystickData = { x: 0, y: 0 };
            
            // Stop all audio safely
            try {
                if (window.engineSound) {
                    window.engineSound.osc1.stop();
                    window.engineSound.osc2.stop();
                    window.engineSound.osc3.stop();
                }
                
                if (window.audioContext && window.audioContext.state !== 'closed') {
                    window.audioContext.close();
                }
            } catch (error) {
                console.log('Audio cleanup error:', error);
            }
            
            // Apply grayscale filter
            const canvas = renderer.domElement;
            canvas.style.filter = 'grayscale(100%) brightness(70%)';
            canvas.style.transition = 'filter 1s';
            
            // Create game over screen
            const gameOverScreen = document.createElement('div');
            gameOverScreen.id = 'gameOverScreen';
            gameOverScreen.style.position = 'fixed';
            gameOverScreen.style.top = '0';
            gameOverScreen.style.left = '0';
            gameOverScreen.style.width = '100%';
            gameOverScreen.style.height = '100%';
            gameOverScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            gameOverScreen.style.display = 'flex';
            gameOverScreen.style.flexDirection = 'column';
            gameOverScreen.style.justifyContent = 'center';
            gameOverScreen.style.alignItems = 'center';
            gameOverScreen.style.zIndex = '1000';
            gameOverScreen.style.fontFamily = 'system-ui, sans-serif';
            
            // Add WASTED text
            const wastedText = document.createElement('h1');
            wastedText.textContent = 'WASTED';
            wastedText.style.fontSize = '96px';
            wastedText.style.fontWeight = 'bold';
            wastedText.style.color = '#ff0000';
            wastedText.style.textShadow = '4px 4px 0px #000000';
            wastedText.style.letterSpacing = '10px';
            wastedText.style.marginBottom = '40px';
            wastedText.style.animation = 'fadeIn 2s';
            wastedText.style.opacity = '0';
            gameOverScreen.appendChild(wastedText);
            
            wastedText.style.opacity = '1';
            wastedText.style.transition = 'opacity 1s';
            
            // Add message text below WASTED
            const messageText = document.createElement('div');
            messageText.innerHTML = message;
            messageText.style.fontSize = '32px';
            messageText.style.color = '#ffffff';
            messageText.style.textAlign = 'center';
            messageText.style.marginBottom = '30px';
            messageText.style.maxWidth = '80%';
            gameOverScreen.appendChild(messageText);
            
            // Add restart instructions for both keyboard and touch
            const restartText = document.createElement('div');
            restartText.textContent = isMobileDevice ? 'Tap anywhere to continue' : 'Press SPACE to continue';
            restartText.style.fontSize = '24px';
            restartText.style.color = '#ffffff';
            restartText.style.marginTop = '20px';
            gameOverScreen.appendChild(restartText);
            
            document.body.appendChild(gameOverScreen);

            // Function to handle restart
            const handleRestart = () => {
                // Safely remove game over screen if it exists
                const existingGameOverScreen = document.getElementById('gameOverScreen');
                if (existingGameOverScreen) {
                    existingGameOverScreen.remove();
                }
                
                // Hide leaderboard
                clearTimeout(gameOverleaderboardTimeout);
                const leaderboard = document.getElementById('leaderboard');
                if (leaderboard) {
                    leaderboard.style.display = 'none';
                }

                // reset health
                currentHealth=maxHealth;

                // Reset canvas filter
                canvas.style.filter = 'none';
                
                // Reset game state
                window.gameEnded = false;
                
                // Reset player position and orientation
                player.position.set(SPAWN_POINT_X, SPAWN_POINT_Y, SPAWN_POINT_Z);
                player.rotation.set(0, 0, 0);
                yawAngle = 0;
                currentRoll = 0;
                currentPitch = 0;
                currentSpeed = 0;
                
                // Reinitialize audio
                window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Start game directly
                startGame();
            };

            // Add keydown listener for restart (Space key)
            const keyRestartHandler = (event) => {
                if (event.code === 'Space') {
                    handleRestart();
                    window.removeEventListener('keydown', keyRestartHandler);
                }
            };
            window.addEventListener('keydown', keyRestartHandler);
            
            // Add touch listener for mobile restart (tap anywhere)
            const touchRestartHandler = (event) => {
                handleRestart();
                gameOverScreen.removeEventListener('touchstart', touchRestartHandler);
            };
            gameOverScreen.addEventListener('touchstart', touchRestartHandler);
        }

        function handleCrash() {
            // Stop the plane and engine sound
            currentSpeed = 0;
            if (window.engineSound) {
                window.engineSound.gain1.gain.setValueAtTime(0, window.audioContext.currentTime);
                window.engineSound.gain2.gain.setValueAtTime(0, window.audioContext.currentTime);
                window.engineSound.gain3.gain.setValueAtTime(0, window.audioContext.currentTime);
                window.engineSound.noise.gain.setValueAtTime(0, window.audioContext.currentTime);
            }

            // Disable controls temporarily
            const oldKeys = {...keys};
            Object.keys(keys).forEach(key => keys[key] = false);
            
            // Create explosion effect
            createExplosionEffect(player.position.clone());
            
            // Hide the plane temporarily
            player.visible = false;
            
            // Show start screen again
            document.getElementById('startScreen').style.display = 'flex';
            
            // Reset after 2 seconds
            setTimeout(() => {
                // Reset position to runway surface
                player.position.set(0, 36, 90); // Update reset height
                player.rotation.set(0, 0, 0);
                yawAngle = 0;
                currentRoll = 0;
                currentPitch = 0;
                currentSpeed = minSpeed;
                
                // Show plane again
                player.visible = true;
                
                // Stop animation loop
                cancelAnimationFrame(animationFrameId);
                
                // Clear any remaining missiles
                missiles.forEach(missile => scene.remove(missile));
                missiles.length = 0;
                
                // Restore controls
                Object.assign(keys, oldKeys);
            }, 2000);
        }

        // Modified explosion effect to handle different sizes
        function createExplosionEffect(position, isHouse = false) {
            // Play explosion sound
            playExplosionSound();
            
            const particleCount = isHouse ? 100 : 50; // More particles for houses
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(isHouse ? 0.3 : 0.2, 8, 8);
                const material = new THREE.MeshPhongMaterial({
                    color: Math.random() > 0.5 ? 0xff4400 : 0xff8800,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                // Stronger explosion for houses
                const velocityMultiplier = isHouse ? 0.5 : 0.3;
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * velocityMultiplier,
                    Math.random() * velocityMultiplier,
                    (Math.random() - 0.5) * velocityMultiplier
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            animateExplosion();
        }

        // Add after other global variables
        let lastFrameTime = performance.now();
        let deltaTime = 1/60; // Default to 60fps timing if first frame
        let lastPosition = new THREE.Vector3(); // Add this line to track last position


        function updateAfterburner() {
            if (!player.afterburner) return;
            
            // Activate afterburner automatically at high speeds (80% of max speed)
            const highSpeed = currentSpeed > (maxSpeed * 0.8);

            // Also activate when boost key is pressed
            const boostActive = keys['ShiftRight'] === true;
            
            // Set afterburner state
            player.afterburnerActive = highSpeed || boostActive;
            
            // Show/hide afterburner based on active state
            player.afterburner.visible = player.afterburnerActive;
            
            if (player.afterburnerActive) {
                // Apply speed boost when afterburner is active
                if (boostActive && currentSpeed > maxSpeed * 0.5) {
                    currentSpeed = Math.min(currentSpeed * 1.01, maxSpeed * 1.5);
                }
                
                // Animate flames
                const time = Date.now() * 0.003;
                const speedFactor = Math.min(1, (currentSpeed / maxSpeed));
                
                // Get flame components
                const innerFlame = player.afterburner.children[0];
                const middleFlame = player.afterburner.children[1];
                const outerFlame = player.afterburner.children[2];
                const afterburnerLight = player.afterburner.children[3];
                
                // Pulsate flame sizes
                const pulseFactor = 0.8 + Math.sin(time * 10) * 0.2;
                
                // Scale flames based on speed and pulse
                innerFlame.scale.set(
                    0.8 + 0.2 * Math.sin(time * 15),
                    0.8 + 0.2 * Math.sin(time * 15),
                    speedFactor * pulseFactor
                );
                
                middleFlame.scale.set(
                    0.7 + 0.3 * Math.sin(time * 12),
                    0.7 + 0.3 * Math.sin(time * 12),
                    speedFactor * pulseFactor * 1.2
                );
                
                outerFlame.scale.set(
                    0.6 + 0.4 * Math.sin(time * 8),
                    0.6 + 0.4 * Math.sin(time * 8),
                    speedFactor * pulseFactor * 1.5
                );
                
                // Adjust light intensity based on speed
                afterburnerLight.intensity = 2 + speedFactor * 3;
            }
        }
        
        let clampedDeltaTime = 0; // Global variable
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const rawDeltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            // Calculate FPS using a rolling average over the last second
            frameCount++;
            const timeSinceLastUpdate = currentTime - lastTime;
            
            if (timeSinceLastUpdate >= 1000) { // Update every second
                currentFps = Math.round((frameCount * 1000) / timeSinceLastUpdate);
                frameCount = 0;
                lastTime = currentTime;
            }

            // Limit maximum delta time to prevent huge jumps
            const maxDeltaTime = 0.25; // Maximum 250ms between frames
            clampedDeltaTime = Math.min(rawDeltaTime, maxDeltaTime);
            
            timeAccumulator += clampedDeltaTime;
            const fixedTimeStep = 1/60;

            // Run fixed timestep updates
            while (timeAccumulator >= fixedTimeStep) {
                deltaTime = fixedTimeStep; // Ensure fixed timestep for ALL physics

                updateDayNightCycle();
                animateWindsock();
                animateBanner(); // Add this line to animate the banner
                updateClouds();
                updateStars();
                animateHotAirBalloon();

                if(gameStarted) {
                    // Update game with delta time
                    handleGamepadInput();
                    updatePlayer();
                    updateHUD();
                    updateRain();
                    updateMissiles();
                    checkMissileCollisions(); // Check missile hits
                    checkCollisions(); // Check player collisions with objects
                    updateApproachLights();
                    updateMinimap();
                    checkForRefuel();
                    updateRearViewMirror();
                    updateScoreDisplay();
                    updateMetrics();
                }

                if(!gameStarted) {
                    // animate the pre game camera and slowly move it down the runway
                    // start screen animation
                    camera.position.x-=-0.25;
                    // camera.position.z-=-0.025;
                    // camera.position.y-=-0.025;
                    if(
                        camera.position.x > 500 ||
                        camera.position.y > 500 ||
                        camera.position.z > 500
                    ) {
                        camera.position.x=INITIAL_CAMERA_X;
                        camera.position.y=INITIAL_CAMERA_Y;
                        camera.position.z=INITIAL_CAMERA_Z;
                    }
                }

                
                if(vehicleName=='f16') {
                    updateAfterburner();
                }

                timeAccumulator -= fixedTimeStep;
            }
            
            renderer.render(scene, camera);
        }

        // init
        // immediately start animating the world for the start screen
        camera.position.x=INITIAL_CAMERA_X;
        camera.position.y=INITIAL_CAMERA_Y;
        camera.position.z=INITIAL_CAMERA_Z;
        // camera.rotation.x=-1;
        camera.rotation.x=-0.45;

        animate();

        // Add animationFrameId variable at the top with other globals
        let animationFrameId;

        // Add escape key handler to exit pointer lock
        window.addEventListener('keydown', (event) => {
            if (event.code === 'Escape') {
                document.exitPointerLock = document.exitPointerLock ||
                                         document.mozExitPointerLock;
                document.exitPointerLock();
            }
        });



        function updateHUD() {

            if (isThirdPerson) {
                // hide HUD in third person
                const hudCanvas = document.getElementById('hud');
                if (hudCanvas) {
                    hudCanvas.style.display = 'none';
                }
                return;
            }
            else {
                const hudCanvas = document.getElementById('hud');
                if (hudCanvas) {
                    hudCanvas.style.display = 'block';
                }
            }

            const hud = document.getElementById('hud');
            const hudCtx = hud.getContext('2d');

            // Set canvas size to match window
            hud.width = window.innerWidth;
            hud.height = window.innerHeight;

            // Clear previous frame
            hudCtx.clearRect(0, 0, hud.width, hud.height);

            // Set HUD style
            hudCtx.strokeStyle = '#0f0';
            hudCtx.fillStyle = '#0f0';
            hudCtx.lineWidth = 4;
            hudCtx.font = '24px monospace';
            hudCtx.globalAlpha = 1;

            const centerX = hud.width / 2;
            const centerY = hud.height / 2;

            // Draw advanced crosshair
            hudCtx.beginPath();
            hudCtx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            hudCtx.moveTo(centerX - 30, centerY);
            hudCtx.lineTo(centerX - 10, centerY);
            hudCtx.moveTo(centerX + 10, centerY);
            hudCtx.lineTo(centerX + 30, centerY);
            hudCtx.moveTo(centerX, centerY - 30);
            hudCtx.lineTo(centerX, centerY - 10);
            hudCtx.moveTo(centerX, centerY + 10);
            hudCtx.lineTo(centerX, centerY + 30);
            hudCtx.stroke();

            // Draw artificial horizon that responds to pitch and roll
            const horizonWidth = hud.width * 0.6;
            const pitchSensitivity = 100; // How much the horizon moves with pitch changes

            // Save context for rotation
            hudCtx.save();
            hudCtx.translate(centerX, centerY);
            hudCtx.rotate(currentRoll); // Roll the horizon opposite to aircraft roll

            // Draw horizon line
            const pitchOffset = currentPitch * pitchSensitivity;
            hudCtx.beginPath();
            hudCtx.moveTo(-horizonWidth/2, pitchOffset);
            hudCtx.lineTo(horizonWidth/2, pitchOffset);
            hudCtx.stroke();

            // Draw pitch ladder - DOUBLED vertical spacing between lines
            const ladderSpacing = 40; // Increased from 20 to 40 for more spread
            const degreesPerRung = 5; // Each rung represents 5 degrees
            const numRungs = 4; // Show 4 rungs above and below current pitch (¬±20 degrees total)

            // Calculate current pitch in degrees
            const currentPitchDegrees = currentPitch * (180/Math.PI);

            for(let i = -numRungs; i <= numRungs; i++) {
                if(i === 0) continue; // Skip the horizon line as we already drew it
                
                // Calculate the pitch angle for this rung relative to current pitch
                const pitchAngle = i * degreesPerRung;
                
                // Calculate vertical position based on relative pitch from current position
                const y = pitchOffset - (pitchAngle * ladderSpacing / degreesPerRung);
                
                // Width decreases as we move away from horizon
                const width = horizonWidth * 0.4 - Math.abs(i) * 10;
                
                hudCtx.beginPath();
                hudCtx.moveTo(-width/2, y);
                hudCtx.lineTo(width/2, y);
                hudCtx.stroke();
                
                // Add pitch angle indicators (absolute pitch value)
                const absolutePitchAngle = Math.round(currentPitchDegrees + pitchAngle);
                
                // Fix for numbers not showing - ensure text is drawn after stroke
                // Only show text on 10-degree increments
                // if(absolutePitchAngle % 10 === 0) {
                    // Save context before setting text alignment
                    hudCtx.save();
                    hudCtx.textAlign = 'left';
                    hudCtx.fillText(Math.abs(absolutePitchAngle) + "¬∞", width/2 + 10, y + 5);
                    hudCtx.textAlign = 'right';
                    hudCtx.fillText(Math.abs(absolutePitchAngle) + "¬∞", -width/2 - 10, y + 5);
                    hudCtx.restore();
                // }
            }

            // Restore context after rotation
            hudCtx.restore();

            // Draw heading indicator at top
            const headingY = 40;
            const headingWidth = hud.width * 0.4;
            const heading = Math.round(((yawAngle * (180/Math.PI)) + 180) % 360);

            hudCtx.beginPath();
            hudCtx.moveTo(centerX, headingY - 10);
            hudCtx.lineTo(centerX, headingY);
            hudCtx.stroke();

            hudCtx.textAlign = 'center';
            hudCtx.fillText(heading + "¬∞", centerX, headingY - 15);

            // Draw heading tape
            hudCtx.beginPath();
            hudCtx.moveTo(centerX - headingWidth/2, headingY);
            hudCtx.lineTo(centerX + headingWidth/2, headingY);
            hudCtx.stroke();

            // Draw cardinal directions on heading tape
            const cardinalPoints = [
                {angle: 0, label: "N"},
                {angle: 90, label: "E"},
                {angle: 180, label: "S"},
                {angle: 270, label: "W"}
            ];

            cardinalPoints.forEach(point => {
                const pointPosition = centerX + (((point.angle - heading + 540) % 360 - 180) / 180) * headingWidth/2;
                if(pointPosition >= centerX - headingWidth/2 && pointPosition <= centerX + headingWidth/2) {
                    hudCtx.fillText(point.label, pointPosition, headingY - 15);
                }
            });

            // Draw speed and altitude indicators
            const speedKts = Math.round(currentSpeed * 525 * 0.539957);
            const altitudeFt = Math.round(camera.position.y * 3.28084);
            const verticalSpeedFtMin = Math.round(verticalSpeed * 3281/60);

            // Speed indicator (left side)
            hudCtx.textAlign = 'right';
            hudCtx.fillText(`${speedKts} kts`, 150, hud.height - 80);

            // Altitude indicator (right side)
            hudCtx.textAlign = 'left';
            hudCtx.fillText(`${altitudeFt} ft`, hud.width - 150, hud.height - 80);

            // Vertical speed indicator
            hudCtx.textAlign = 'left';
            hudCtx.fillText(`VS: ${verticalSpeedFtMin} ft/min`, hud.width - 150, hud.height - 50);

            // Roll indicator
            hudCtx.textAlign = 'right';
            hudCtx.fillText(`ROLL: ${Math.round(currentRoll * (180/Math.PI))}¬∞`, 150, hud.height - 50);

            // Draw throttle indicator
            const throttlePercent = Math.round((currentSpeed / maxSpeed) * 100);
            hudCtx.textAlign = 'center';
            hudCtx.fillText(`THROTTLE: ${throttlePercent}%`, centerX, hud.height - 30);

            // Draw health bar if available
            if(typeof health !== 'undefined') {
                const healthBarWidth = 200;
                const healthBarHeight = 10;
                const healthX = centerX - healthBarWidth/2;
                const healthY = hud.height - 60;
                
                // Background
                hudCtx.fillStyle = '#300';
                hudCtx.fillRect(healthX, healthY, healthBarWidth, healthBarHeight);
                
                // Health level
                hudCtx.fillStyle = '#0f0';
                hudCtx.fillRect(healthX, healthY, healthBarWidth * (health/100), healthBarHeight);
                
                // Reset fill style
                hudCtx.fillStyle = '#0f0';
            }
            }



        let verticalMovement = 0;

        function updatePlayer() {
            // Add helicopter rotor rotation
            if (vehicleName === 'apache' && mainRotor && mainRotor2 && tailRotor) {
                // Calculate rotor speed based on throttle/engine power
                const idleRotorSpeed = 0.1; // Minimum speed when engine is on
                const maxRotorSpeed = 0.5;   // Maximum rotor speed
                
                // Smoothly adjust rotor speed based on current speed
                const targetRotorSpeed = idleRotorSpeed + 
                    ((currentSpeed - minSpeed) / (maxSpeed - minSpeed)) * (maxRotorSpeed - idleRotorSpeed);
                
                rotorSpeed = THREE.MathUtils.lerp(rotorSpeed, targetRotorSpeed, deltaTime * 2);
                
                // Rotate the rotors
                mainRotor.rotation.y += rotorSpeed;
                mainRotor2.rotation.y += rotorSpeed;
                tailRotor.rotation.y = -1.5;
                tailRotor.rotation.x += rotorSpeed * 1.5; // Tail rotor spins faster
            }



            // ‚úÖ Handle Speed Control (W/S keys or Right Joystick)
            if (!skipControls) {
                const speedInc = speedIncrement * deltaTime;

                if(keys['Space']) {
                    shootMissile();
                }
                
                if (vehicleName == 'tank') {
                    if (keys['KeyW'] || rightJoystickData.y > 0.3) {
                        currentSpeed += speedInc;
                    } else if (keys['KeyS'] || rightJoystickData.y < -0.3) {
                        currentSpeed = Math.max(currentSpeed - speedIncrement * 8 * deltaTime, minSpeed);
                    } else if (keys['ShiftRight']) {
                        currentSpeed += speedInc;
                        currentSpeed = Math.min(currentSpeed, maxSpeed);
                    }
                    // Tank turret control with up/down arrows
                    if (keys['ArrowUp'] || leftJoystickData.y > 0.3) {
                        // Raise turret
                        tankTurret.rotation.x = Math.max(tankTurret.rotation.x - pitchSpeed * deltaTime, -0.5); // Limit upward angle
                    }
                    else if (keys['ArrowDown'] || leftJoystickData.y < -0.3) {
                        // Lower turret
                        tankTurret.rotation.x = Math.min(tankTurret.rotation.x + pitchSpeed * deltaTime, 0.1); // Limit downward angle
                    }
                } else {
                    if (keys['KeyW'] || rightJoystickData.y > 0.3) {
                        currentSpeed += speedInc;
                    } else if (keys['KeyS'] || rightJoystickData.y < -0.3) {
                        currentSpeed = Math.max(currentSpeed - speedIncrement * 8 * deltaTime, minSpeed);
                    } else if (keys['ShiftRight']) {
                        currentSpeed += speedInc * TURBO_SPEED_MULTIPLIER;
                        currentSpeed = Math.min(currentSpeed, maxSpeed);
                    }
                }
            }



            // Update FOV based on speed and turbo state
            const speedRatio = (currentSpeed - minSpeed) / (maxSpeed - minSpeed);
            let baseFovIncrease;
            if (vehicleName === 'cessna') {
                baseFovIncrease = speedRatio * MAX_FOV_INCREASE;
            } else if (vehicleName === 'f16' || vehicleName === 'a10') {
                baseFovIncrease = speedRatio * MAX_FOV_INCREASE * 0.1; // Slower FOV increase for faster planes
            } else {
                baseFovIncrease = speedRatio * MAX_FOV_INCREASE;
            }
            const turboFovIncrease = !skipControls && keys['ShiftRight'] ? TURBO_EXTRA_FOV * speedRatio : 0;
            const targetFOV = MIN_FOV + baseFovIncrease + turboFovIncrease;

            camera.fov += (targetFOV - camera.fov) * 0.2;
            camera.updateProjectionMatrix();

            isAirborne = player.position.y > 36.1;

            // ‚úÖ Move Forward
            player.translateZ(-currentSpeed);

            const speedKmh = currentSpeed * 525; // Convert speed to km/h
            speedKts=Math.round(speedKmh*0.539957);

            if(!skipControls) {

                if(vehicleName == 'cessna' || vehicleName == 'a10' || vehicleName == 'f16' || vehicleName == 'triangle') {
                    
                    // <propeller movement>
                        if (vehiclePropeller) {
                            // Base rotation speed plus additional speed based on current speed
                            const propellerSpeed = 1 + (currentSpeed * 3);
                            vehiclePropeller.rotation.z += propellerSpeed;
                        }
                    // </propeller movement>

                    // <rudder movement>
                        // put rudder movement here because it also should work on the ground
                        if (vehicleRudder) {
                            if (keys['KeyA']) {
                                vehicleRudder.rotation.y = 0.06;
                            } else if (keys['KeyD']) {
                                vehicleRudder.rotation.y = -0.06;
                            }
                            else {
                                vehicleRudder.rotation.y = 0;
                            }
                        }
                    // <rudder movement>

                    // <aileron movement>
                        // put aileron movement here because it also should work on the ground
                        if (vehicleAileronLeft && vehicleAileronRight) {
                            if (keys['ArrowLeft']) {
                                vehicleAileronLeft.rotation.x = -0.5;
                                vehicleAileronRight.rotation.x = 0.5;
                            } else if (keys['ArrowRight']) {
                                vehicleAileronLeft.rotation.x = 0.5; 
                                vehicleAileronRight.rotation.x = -0.5;
                            }
                            else {
                                vehicleAileronLeft.rotation.x = 0;
                                vehicleAileronRight.rotation.x = 0;
                            }
                        }
                    // </aileron movement>

                    // <elevator movement>
                        // put elevator movement here because it also should work on the ground
                        if (vehicleElevator) {
                            if (keys['ArrowUp']) {
                                vehicleElevator.rotation.x = 0.25; // Elevator down for nose up
                            } else if (keys['ArrowDown']) {
                                vehicleElevator.rotation.x = -0.25; // Elevator up for nose down
                            }
                            else {
                                vehicleElevator.rotation.x = 0; // Neutral position
                            }
                        }
                    // </elevator movement>

                    // <airborne steering>
                        if (isAirborne) {
                            // <desktop steering>
                                if(!isMobileDevice) {
                                    // <rudder / yaw>
                                        if (keys['KeyA']) {
                                            // Calculate rudder effectiveness for yaw and pitch based on roll angle
                                            const yawMultiplier = Math.cos(currentRoll);
                                            const pitchMultiplier = Math.sin(currentRoll);
                                            
                                            // Apply yaw effect (reduced as roll increases)
                                            const speedFactor = currentSpeed / maxSpeed;
                                            yawAngle += 0.1 * yawRate * deltaTime * yawMultiplier * (1 + speedFactor);
                                            
                                            // Apply pitch effect (increases as roll increases)
                                            currentPitch -= pitchSpeed * deltaTime * pitchMultiplier * (1 + speedFactor);
                                            
                                        } else if (keys['KeyD']) {
                                            // Calculate rudder effectiveness for yaw and pitch based on roll angle
                                            const yawMultiplier = Math.cos(currentRoll);
                                            const pitchMultiplier = Math.sin(currentRoll);
                                            
                                            // Apply yaw effect (reduced as roll increases)
                                            const speedFactor = currentSpeed / maxSpeed;
                                            yawAngle -= 0.1 * yawRate * deltaTime * yawMultiplier * (1 + speedFactor);
                                            
                                            // Apply pitch effect (increases as roll increases)
                                            currentPitch += pitchSpeed * deltaTime * pitchMultiplier * (1 + speedFactor);
                                            
                                        }
                                    // </rudder / yaw>
                                    // <ailerons / roll>
                                        if ((keys['ArrowLeft'] || leftJoystickData.x < -0.3)) {
                                            // strong roll when turning
                                            currentRoll = currentRoll + rollSpeed * deltaTime;
                                            // gradual yaw when turning
                                            yawAngle += 0.1*yawRate * deltaTime * (currentSpeed / maxSpeed);
                                        } else if ((keys['ArrowRight'] || leftJoystickData.x > 0.3)) {
                                            // strong roll when turning
                                            currentRoll = currentRoll - rollSpeed * deltaTime;
                                            // gradual yaw when turning
                                            yawAngle -= 0.1*yawRate * deltaTime * (currentSpeed / maxSpeed);
                                        } else {
                                            // this code slowly stabilizes plane back to normal if no input is given
                                            currentRoll = Math.abs(currentRoll) > 0.01 ? currentRoll - Math.sign(currentRoll) * rollRecoverySpeed * deltaTime : 0;
                                        }
                                    // </ailerons / roll>
                                }
                            // </desktop steering>
                            // <mobile steering>
                                else if(isMobileDevice) {
                                    // simplified steering for mobile devices - direct left/right turning
                                    if (leftJoystickData.x < -0.3) {
                                        // Turn left when joystick moves left
                                        yawAngle += yawRate * deltaTime * (currentSpeed / maxSpeed);
                                        // Add slight roll for visual effect
                                        currentRoll = Math.min(currentRoll + (rollSpeed * 0.5 * deltaTime), Math.PI / 4);
                                    } else if (leftJoystickData.x > 0.3) {
                                        // Turn right when joystick moves right
                                        yawAngle -= yawRate * deltaTime * (currentSpeed / maxSpeed);
                                        // Add slight roll for visual effect
                                        currentRoll = Math.max(currentRoll - (rollSpeed * 0.5 * deltaTime), -Math.PI / 4);
                                    } else {
                                        // this code slowly stabilizes plane back to normal if no input is given
                                        currentRoll = Math.abs(currentRoll) > 0.01 ? currentRoll - Math.sign(currentRoll) * rollRecoverySpeed * deltaTime : 0;
                                    }
                                }
                            // </mobile steering>

                            if (currentRoll <= -2*Math.PI || currentRoll >= 2*Math.PI) {
                                currentRoll = 0;
                            }

                            // Limit roll to 90 degrees (PI/2) on mobile devices
                            if (isMobileDevice) {
                                const maxRoll = Math.PI / 2; // 90 degrees
                                if (Math.abs(currentRoll) > maxRoll) {
                                    currentRoll = Math.sign(currentRoll) * maxRoll;
                                }
                            }

                            // console.log(currentPitch,currentRoll);

                            // Handle flying upside down - if pitch is near vertical and we're rolled over, reset both
                            if (Math.abs(currentPitch) > 1.4) {
                                console.log('flying upside down');
                            }

                            // Normal roll handling
                            currentRoll = currentRoll % (2*Math.PI);
                            if (Math.abs(currentRoll) > Math.PI) {
                                currentRoll = (currentRoll > 0) ? currentRoll - 2*Math.PI : currentRoll + 2*Math.PI;
                            }

                            // Gradually increase yaw angle based on roll direction
                            // because rolling the plane right or left should also turn the plane a bit
                            if (Math.abs(currentRoll) > 0.1) { // Only apply when there's significant roll
                                // Roll direction determines yaw direction
                                const rollDirection = Math.sign(currentRoll);
                                
                                // Increase yaw more as roll increases, up to a maximum effect
                                const rollMagnitude = Math.min(Math.abs(currentRoll), Math.PI/2) / (Math.PI/2);
                                
                                // Apply gradual yaw change
                                yawAngle += rollDirection * rollMagnitude * 0.2 * deltaTime;

                                // console.log('applying yaw from roll',rollDirection * rollMagnitude * 0.2 * deltaTime);
                            }
                        }
                    // </airborne steering>
                    // <ground steering>
                        else {
                            currentRoll = 0;
                            if ((keys['ArrowLeft'] || keys['KeyA'] || leftJoystickData.x < -0.3)) {
                                yawAngle += (yawRate * 2 * (currentSpeed / maxSpeed)) * deltaTime;
                            } else if ((keys['ArrowRight'] || keys['KeyD'] || leftJoystickData.x > 0.3)) {
                                yawAngle -= (yawRate * 2 * (currentSpeed / maxSpeed)) * deltaTime;
                            }
                        }
                    // </ground steering>
                    // ‚úÖ Handle Pitch (Up/Down)
                    if (speedKmh >= 74 || isAirborne) { // Only allow pitch control above takeoff speed or if airborne
                        // Calculate roll factor for yaw adjustment (0 to 1)
                        const rollFactor = Math.abs(currentRoll) / Math.PI;

                        if ((keys['ArrowUp'] || leftJoystickData.y > 0.3)) {
                            // Reduce pitch effect based on roll amount
                            const pitchMultiplier = Math.cos(Math.abs(currentRoll));
                            currentPitch = currentPitch - pitchSpeed * deltaTime * pitchMultiplier;
                            // When rolled, up also affects yaw based on roll amount
                            if (Math.abs(currentRoll) > 0.1 && Math.abs(currentRoll) < 2.5) {
                                yawAngle -= 0.25*yawRate * deltaTime * rollFactor * Math.sign(currentRoll);
                            }
                        }
                        if ((keys['ArrowDown'] || leftJoystickData.y < -0.3)) {
                            // Reduce pitch effect based on roll amount
                            const pitchMultiplier = Math.cos(Math.abs(currentRoll));
                            currentPitch = currentPitch + pitchSpeed * deltaTime * pitchMultiplier;
                            // When rolled, down also affects yaw based on roll amount
                            if (Math.abs(currentRoll) > 0.1 && Math.abs(currentRoll) < 2.5) {
                                yawAngle += 0.25*yawRate * deltaTime * rollFactor * Math.sign(currentRoll);
                            }
                        }
                        // 6.299 is the 0 point after a full rotation for some reason so reset
                        if (currentPitch <= -6.299 || currentPitch >= 6.299) {
                            currentPitch = 0;
                        }
                    }

                    // console.log('currentRoll',currentRoll,'currentPitch',currentPitch,'yawAngle',yawAngle);


                    // ‚úÖ Handle Lift and Gravity
                    if (speedKmh >= 74) { // Takeoff speed check
                        const liftAmount = (currentSpeed * liftFactor * deltaTime * 60) * Math.cos(currentRoll);
                        player.position.y += liftAmount;
                    }

                    // ‚úÖ Apply Gravity if Above Ground
                    player.position.y = Math.max(player.position.y - gravityFactor * deltaTime * 60, 36);
                    
                }
                if(vehicleName == 'tank') {
                    currentRoll = 0;
                    if ((keys['ArrowLeft'] || keys['KeyA'] || leftJoystickData.x < -0.3)) {
                        yawAngle += (yawRate * 2 * (currentSpeed / maxSpeed)) * deltaTime;
                    } else if ((keys['ArrowRight'] || keys['KeyD'] || leftJoystickData.x > 0.3)) {
                        yawAngle -= (yawRate * 2 * (currentSpeed / maxSpeed)) * deltaTime;
                    }

                    // Add turret rotation speed constant
                    const turretRotationSpeed = 5; 
                    
                    // let up and down control the tank's turret rotation to go up and down (limited range)
                    if ((keys['ArrowUp'] || leftJoystickData.y > 0.3)) {
                        // up means move turret down to ground
                        const currentRotation = tankTurret.rotation.x;
                        if (currentRotation > 0) {
                            tankTurret.rotateX(-turretRotationSpeed * deltaTime);
                        }
                        // console.log(currentRotation);
                    } else if ((keys['ArrowDown'] || leftJoystickData.y < -0.3)) {
                        // down means move turret up to air
                        const currentRotation = tankTurret.rotation.x;
                        if (currentRotation < 1.5) {
                            tankTurret.rotateX(turretRotationSpeed * deltaTime);
                        }
                        // console.log(currentRotation);
                    }

                }
            }

            // Calculate vertical speed (add this before updating lastPosition)
            verticalSpeed = Math.round((player.position.y - lastPosition.y) * 525); // Convert to km/h like other speeds
            
            // Store current position for next frame
            lastPosition.copy(player.position);

            // <update camera>
                if (isThirdPerson) {
                    const currentTime = Date.now();

                                            if (currentTime - lastMouseMoveTime > MOUSE_TIMEOUT) {
                            const lerpFactor = 0.02 * deltaTime * 60;
                            mouseX *= (1 - lerpFactor);
                            mouseY *= (1 - lerpFactor);
                        }
                                        
                    const idealOffset = new THREE.Vector3(
                        Math.sin(mouseX) * 10,
                        Math.max(2 + Math.sin(mouseY) * 5, 1),
                        Math.cos(mouseX) * 10
                    ).applyMatrix4(player.matrixWorld);

                    camera.position.lerp(idealOffset, 0.1);
                    camera.position.y = Math.max(camera.position.y, 35.5);
                    camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 1, 0)));
                    
                    // Hide crosshair in third person
                    crosshairGroup.visible = false;
                } else {

                    const cockpitPos = player.localToWorld(COCKPIT_OFFSET.clone());
                    camera.position.copy(cockpitPos);
                    camera.quaternion.copy(player.quaternion);
                    
                    // Add head movement effects in first person
                    const headBobAmount = 0.05;
                    const headTiltAmount = -0.05;
                    
                    // Head bob based on speed
                    const speedFactor = currentSpeed / maxSpeed;
                    const bobOffset = Math.sin(Date.now() * 0.1 * speedFactor) * headBobAmount * speedFactor;
                    camera.position.y += bobOffset;
                    
                    // Head tilt during turns
                    let tiltAngle = 0;
                    // Add head tilt based on current roll angle
                    tiltAngle = currentRoll * headTiltAmount;
                    camera.rotateZ(tiltAngle);
                    camera.rotateY(mouseX);
                    camera.rotateX(mouseY);
                    
                    // Show crosshair in cockpit view
                    crosshairGroup.visible = true;

                    if(vehicleName == 'tank') {
                        // Move 2 units forward relative to tank's heading
                        const forwardVector = new THREE.Vector3(0, 0, -2).applyQuaternion(player.quaternion);
                        camera.position.add(forwardVector);
                        // Apply turret rotation to camera in first person view
                        camera.rotateX(tankTurret.rotation.x); // Add turret's vertical rotation to camera

                        // Move crosshair in front of tank based on turret direction
                        const crosshairDistance = 20; // Distance in front of tank
                        const turretDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tankTurret.quaternion);
                        const crosshairPosition = player.position.clone().add(turretDirection.multiplyScalar(crosshairDistance));
                        crosshairGroup.position.copy(crosshairPosition);
                        
                        // Apply tank and turret rotations to crosshair
                        crosshairGroup.quaternion.copy(player.quaternion);
                        crosshairGroup.rotateY(tankTurret.rotation.y);
                        crosshairGroup.rotateX(tankTurret.rotation.x);
                    }
                }
            // </update camera>

            updateEngineSound();

            
            // ‚úÖ Apply Rotations
            player.rotation.set(0, 0, 0);
            player.rotateY(yawAngle);
            player.rotateX(currentPitch);
            player.rotateZ(currentRoll);
    
            // Convert yawAngle from radians to degrees and normalize to 0-360 range
            currentHeading = Math.round(((yawAngle * 180 / Math.PI) % 360) + 360) % 360;

            // also get the vertical speed
            currentVerticalSpeed = player.position.y - lastPosition.y;


            // ‚úÖ Broadcast Position to Other Players
            const updateTime = Date.now();
            if (updateTime - lastPositionUpdate > BROADCAST_INTERVAL * 1000) {
                broadcastPosition();
                lastPositionUpdate = updateTime;
            }

            addTurbulence();

        }

        function createRain() {
            return;

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(RAIN_COUNT * 3);
            
            for (let i = 0; i < RAIN_COUNT * 3; i += 3) {
                positions[i] = Math.random() * RAIN_AREA - RAIN_AREA/2;
                positions[i+1] = Math.random() * RAIN_HEIGHT;
                positions[i+2] = Math.random() * RAIN_AREA - RAIN_AREA/2;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                // color: 0xaaaaaa,
                color: 0xffffff,
                size: 0.3,
                transparent: true,
                opacity: 0.6,
                fog: true
            });
            
            raindrops = new THREE.Points(geometry, material);
            scene.add(raindrops);
        }

        function updateRain() {
            if (!raindrops || !isRaining) return;

            const positions = raindrops.geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i+1] -= RAIN_SPEED * deltaTime;
                
                if (positions[i+1] < 36) {
                    positions[i+1] = RAIN_HEIGHT;
                    positions[i] = Math.random() * RAIN_AREA - RAIN_AREA/2;
                    positions[i+2] = Math.random() * RAIN_AREA - RAIN_AREA/2;
                }
            }
            
            raindrops.position.x = player.position.x;
            raindrops.position.z = player.position.z;
            
            raindrops.geometry.attributes.position.needsUpdate = true;
        }

        // After runway creation, add runway markings (no lights)
        function createRunwayLights() {
            const edgeMarkingGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.2);
            const edgeMarkingMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,  // Pure white, no lighting calculations
                transparent: true // For animation effects
            });

            // Create runway edge markings (no lights)
            for(let z = -95; z <= 95; z += 10) {
                // Left edge markings
                const leftMarking = new THREE.Mesh(edgeMarkingGeometry, edgeMarkingMaterial.clone());
                leftMarking.position.set(-5, 35.2, z);
                scene.add(leftMarking);

                // Right edge markings
                const rightMarking = new THREE.Mesh(edgeMarkingGeometry, edgeMarkingMaterial.clone());
                rightMarking.position.set(5, 35.2, z);
                scene.add(rightMarking);

                // Store references for updating
                runwayLights.push({
                    mesh: leftMarking
                }, {
                    mesh: rightMarking
                });
            }

            // Create approach markings (before runway)
            for(let z = 150; z >= 100; z -= 10) {
                const approachMarking = new THREE.Mesh(edgeMarkingGeometry, edgeMarkingMaterial.clone());
                approachMarking.position.set(0, 35.2, z);
                scene.add(approachMarking);

                approachLights.push({
                    mesh: approachMarking,
                    baseOpacity: 0.5  // Base opacity for day/night
                });
            }
        }

        // Add to global variables
        const runwayLights = [];
        const approachLights = [];
        let lastApproachLightUpdate = 0;
        const APPROACH_LIGHT_INTERVAL = 100; // Time between marking transitions in ms
        let currentApproachLightIndex = 0;

        // Call createRunwayLights after scene setup
        createRunwayLights();

        // Update animation function to use opacity instead of emissive/lights
        function updateApproachLights() {
            const currentTime = Date.now();
            const isNight = gameTime < 6000 || gameTime > 18000;
            const isDusk = gameTime >= 17000 && gameTime <= 19000;
            const isDawn = gameTime >= 5000 && gameTime <= 7000;
            
            // Animate markings during night/dusk/dawn
            if (isNight || isDusk || isDawn) {
                if (currentTime - lastApproachLightUpdate > APPROACH_LIGHT_INTERVAL) {
                    // Reset all markings to base opacity
                    approachLights.forEach(marking => {
                        marking.mesh.material.opacity = marking.baseOpacity;
                    });
                    
                    // Highlight current marking
                    if (approachLights[currentApproachLightIndex]) {
                        approachLights[currentApproachLightIndex].mesh.material.opacity = 1.0;
                    }
                    
                    // Move to next marking
                    currentApproachLightIndex = (currentApproachLightIndex + 1) % approachLights.length;
                    lastApproachLightUpdate = currentTime;
                }
                
                // Make edge markings visible during night
                runwayLights.forEach(light => {
                    light.mesh.material.opacity = 1.0;
                });
            } else {
                // During day, lower opacity but keep visible
                approachLights.forEach(marking => {
                    marking.mesh.material.opacity = 0.5; // Still visible but dimmer
                });
                runwayLights.forEach(light => {
                    light.mesh.material.opacity = 0.5; // Still visible but dimmer
                });
            }
        }

        // Add to keyboard event listener setup
        window.addEventListener('keydown', (event) => { keys[event.code] = true; });
        window.addEventListener('keyup', (event) => { keys[event.code] = false; });

        // Add after other global variables
        let score = 0;
        let lastAltitude = 35;

        // Add these balloon target functions
        function createBalloonTarget() {
            const balloonGroup = new THREE.Group();
            
            // Array of balloon colors with alpha
            const balloonColors = [
                0xff0000, // red
                0xffff00, // yellow
                0x00ff00, // green
                0xff69b4, // pink
                0x0000ff, // blue
                0x800080, // purple
                0xffffff, // white
                0x000000  // black
            ];
            
            const sizeScale = 0.8 + Math.random() * 2.2;
            const balloonGeometry = new THREE.SphereGeometry(2, 16, 16);
            const balloonMaterial = new THREE.MeshPhongMaterial({ 
                color: balloonColors[Math.floor(Math.random() * balloonColors.length)],
                shininess: 50,
                transparent: true,
                opacity: 0.85, // Make balloons slightly transparent
                depthWrite: true // Keep this true to avoid sorting issues
            });
            const balloon = new THREE.Mesh(balloonGeometry, balloonMaterial);
            balloon.scale.set(sizeScale, sizeScale, sizeScale);
            balloonGroup.add(balloon);
            
            // Adjust height based on balloon size to prevent tiny ones from being too high
            const minHeight = 50 + (sizeScale * 10); // Bigger balloons float higher
            const maxHeight = Math.min(450, minHeight + 200); // Cap maximum height
            
            balloonGroup.position.set(
                Math.random() * 1600 - 800,  // Wide spread
                minHeight + Math.random() * (maxHeight - minHeight), // Height varies with size
                Math.random() * 1600 - 800   // Wide spread
            );
            
            balloonGroup.boundingBox = new THREE.Box3();
            scene.add(balloonGroup);
            return balloonGroup;
        }

        // Create array for targets
        const targets = [];
        for(let i = 0; i < 100; i++) {  // Increased from 10 to 100 balloons
            const target = createBalloonTarget();
            
            // Spread balloons out more widely
            target.position.set(
                Math.random() * 1600 - 800,  // Doubled spread from ¬±400 to ¬±800
                50 + Math.random() * 400,    // Height range from 50 to 450
                Math.random() * 1600 - 800   // Doubled spread from ¬±400 to ¬±800
            );
            
            targets.push(target);
        }

        // Add message display function
        let messageTimeout = null;
        let priorityMessageActive = false;
        
        function showMessage(text, priority=false) {
            // If a priority message is active and this is not priority, skip
            if (priorityMessageActive && !priority) {
                return;
            }
            
            // Check if a message already exists and remove it
            const existingMessage = document.getElementById('gameMessage');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // Clear any existing timeout
            if (messageTimeout) {
                clearTimeout(messageTimeout);
            }
            
            const message = document.createElement('div');
            message.id = 'gameMessage';

            message.style.position = 'fixed';
            message.style.pointerEvents = 'none';
            // if mobile do smaller text
            if(isMobileDevice) {
                message.style.fontSize = '16px';
            } else {
                message.style.fontSize = '24px';
            }
            message.style.bottom = '20px';
            message.style.left = '20px';
            message.style.color = 'white';
            message.style.fontFamily = "system-ui";
            message.style.padding = '20px';
            message.style.background = 'rgba(0,0,0,0.5)';
            message.style.borderRadius = '10px';
            message.style.zIndex = '1000';
            message.style.maxWidth = '80%';
            message.innerHTML = text;
            
            document.body.appendChild(message);
            
            if (priority) {
                priorityMessageActive = true;
                setTimeout(() => {
                    priorityMessageActive = false;
                }, 3000); // Block other messages for 3 seconds
            }
            
            messageTimeout = setTimeout(() => {
                message.style.transition = 'opacity 1s';
                message.style.opacity = '0';
                setTimeout(() => message.remove(), 1000);
            }, 2000);
        }

        // Add hit effect function
        function createHitEffect(position) {
            const particles = new THREE.Group();
            
            for(let i = 0; i < 20; i++) {
                const geometry = new THREE.SphereGeometry(0.2, 8, 8);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    emissive: 0xffaa00
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                // Random velocity
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate particles
            let elapsedTime = 0;
            function animateHit() {
                elapsedTime += deltaTime;
                
                particles.children.forEach(particle => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime * 60));
                    particle.material.opacity = 1 - elapsedTime;
                    particle.material.transparent = true;
                });
                
                if(elapsedTime < 1) {
                    requestAnimationFrame(animateHit);
                } else {
                    scene.remove(particles);
                }
            }
            animateHit();
        }

        // After other global variables
        const ships = [];

        // Add after other creation functions
        function createShip() {
            const shipGroup = new THREE.Group();
            
            // Random ship size
            const length = 10 + Math.random() * 20; // Ships 10-30 units long
            const width = length * 0.2; // Width proportional to length
            const height = length * 0.15; // Height proportional to length
            
            // Hull
            const hullGeometry = new THREE.BoxGeometry(width, height, length);
            const hullMaterial = new THREE.MeshPhongMaterial({ 
                color: Math.random() > 0.5 ? 0x334455 : 0x445566 // Dark blue/grey variations
            });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.position.y = height/2;
            shipGroup.add(hull);
            
            // Deck structures (random number of them)
            const deckCount = Math.floor(Math.random() * 3) + 1;
            for(let i = 0; i < deckCount; i++) {
                const deckWidth = width * 0.8;
                const deckLength = length * (0.2 + Math.random() * 0.2);
                const deckHeight = height * 0.8;
                
                const deckGeometry = new THREE.BoxGeometry(deckWidth, deckHeight, deckLength);
                const deckMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff }); // White deck
                const deck = new THREE.Mesh(deckGeometry, deckMaterial);
                
                deck.position.y = height + deckHeight/2;
                deck.position.z = (length/3) * (i - 1);
                shipGroup.add(deck);
            }
            
            // Add a chimney/smokestack
            const stackRadius = width * 0.15;
            const stackHeight = height * 2;
            const stackGeometry = new THREE.CylinderGeometry(stackRadius, stackRadius, stackHeight);
            const stackMaterial = new THREE.MeshPhongMaterial({ 
                color: Math.random() > 0.5 ? 0xdd3311 : 0x333333 // Red or black smokestack
            });
            const stack = new THREE.Mesh(stackGeometry, stackMaterial);
            stack.position.y = height + stackHeight/2;
            stack.position.z = -length/4;
            shipGroup.add(stack);
            
            // Position ship on ocean only (negative X values)
            shipGroup.position.set(
                Math.random() * 500 - 1200, // Keep ships between x=-1200 and x=-700
                35.5, // Just above water level
                Math.random() * 1400 - 700 // Z spread
            );
            
            // Random rotation for variety
            shipGroup.rotation.y = Math.random() * Math.PI * 2;
            
            scene.add(shipGroup);
            return shipGroup;
        }

        // Create initial ships
        for(let i = 0; i < 20; i++) { // Create 20 ships
            ships.push(createShip());
        }

        // Add ship movement update function
        function updateShips() {
            ships.forEach(ship => {
                const time = performance.now() * 0.001;
                // Make bobbing frame-rate independent
                ship.position.y = 35.5 + Math.sin(time) * 0.1;
                ship.rotation.x = Math.sin(time) * 0.02;
            });
        }

        // Create houses function
        function createHouse() {
            // houses with pointy roofs
            const houseGroup = new THREE.Group();
            
            // Random house size
            const width = 4 + Math.random() * 4;
            const height = 6 + Math.random() * 8;
            const depth = 4 + Math.random() * 4;
            
            // Main building
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshPhongMaterial({
                color: new THREE.Color(
                    0.7 + Math.random() * 0.3,
                    0.7 + Math.random() * 0.3,
                    0.7 + Math.random() * 0.3
                )
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height/2;
            houseGroup.add(building);
            
            // Roof (pyramid style)
            const roofHeight = height * 0.3;
            const roofGeometry = new THREE.ConeGeometry(width * 0.8, roofHeight, 4);
            const roofMaterial = new THREE.MeshPhongMaterial({
                color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D // Brown variations
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = height + roofHeight/2;
            roof.rotation.y = Math.PI/4; // Rotate 45 degrees for better look
            houseGroup.add(roof);
            
            // Windows
            const windowSize = width * 0.2;
            const windowGeometry = new THREE.BoxGeometry(windowSize, windowSize, 0.1);
            const windowMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaff,
                emissive: 0x444444
            });
            
            // Add multiple windows
            const windowPositions = [
                [-width/4, height/2, depth/2],
                [width/4, height/2, depth/2],
                [-width/4, height*0.75, depth/2],
                [width/4, height*0.75, depth/2]
            ];
            
            windowPositions.forEach(pos => {
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set(...pos);
                houseGroup.add(window);
            });
            
            // Door
            const doorWidth = width * 0.3;
            const doorHeight = height * 0.4;
            const doorGeometry = new THREE.BoxGeometry(doorWidth, doorHeight, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, doorHeight/2, depth/2);
            houseGroup.add(door);
            
            return houseGroup;
        }

        // Create multiple houses
        const houses = [];
        // Create houses both along coast and inland
        for(let i = 0; i < 80; i++) {  // 80 houses total
            const house = createHouse();
            
            // Generate initial position
            let x = -400 + Math.random() * 600; // From coast (-400) to inland (+200)
            let z = Math.random() * 1600 - 800; // Spread along Z axis
            
            // Keep houses away from runway and approach path
            // Runway is at x=0, so check distance from center
            while (Math.abs(x) < 30 && Math.abs(z) < 150) { // Increased clearance area
                x = -400 + Math.random() * 600;
                z = Math.random() * 1600 - 800;
            }
            
            house.position.set(
                x,
                35, // Ground level
                z
            );
            house.rotation.y = Math.random() * Math.PI * 2; // Random rotation
            houses.push(house);
            scene.add(house);
        }

        // Define crash thresholds
        const HARD_LANDING_SPEED = 10; // Units per second
        const MAX_SAFE_ANGLE = 0.3; // Radians (about 17 degrees)
        

        // Add house collision detection to checkCollisions function
        function checkCollisions() {
            // console.log('checkCollisions');

            // Create bounding box for player with a small buffer to crash into things
            const COLLISION_BUFFER = 1;
            
            const playerBox = new THREE.Box3().setFromObject(player);
            playerBox.expandByScalar(-playerBox.getSize(new THREE.Vector3()).length() * (1 - COLLISION_BUFFER));

            // console.log(player.position.y);

            // Skip collision checks if player is dead or game has ended
            if (window.gameEnded) {
                return;
            }

            // Calculate vertical speed (change in height over time)
            const verticalSpeed = (player.position.y - lastAltitude) / deltaTime;
            
            // Calculate impact angle (how level is the plane)
            const impactAngle = Math.abs(currentPitch);
            
            // console.log('verticalSpeed',verticalSpeed);
            // console.log('HARD_LANDING_SPEED',HARD_LANDING_SPEED);
            // console.log('impactAngle',impactAngle);
            // console.log('MAX_SAFE_ANGLE',MAX_SAFE_ANGLE);

            // Check ground collision with impact detection
            if (player.position.y < 36) {
                // console.log('ground collision');

                // Check if it's a crash
                if (Math.abs(verticalSpeed) > HARD_LANDING_SPEED && impactAngle > MAX_SAFE_ANGLE) {
                    const now = Date.now();
                    if (!window.lastCrashTime || now - window.lastCrashTime > 3000) { // 3 seconds cooldown
                        window.lastCrashTime = now;
                        broadcastCrash("ground");
                        currentDeaths++;
                        gameOver("You're eating dirt");
                        console.log('crashed into ground at '+verticalSpeed+' and angle '+impactAngle);
                    }
                    return;
                } else {
                    // Safe landing - just keep plane at ground level
                    player.position.y = 36;
                }
            }
            

            
            // Check collision with Jupiter
            const jupiterBox = new THREE.Box3().setFromObject(jupiter);
            if (playerBox.intersectsBox(jupiterBox)) {

                broadcastCrash("jupiter");
                currentDeaths++;
                gameOver("That's one small crash for man, one giant SPLAT for mankind!");
                
                // Open Softgen.ai in a new tab
                window.open('https://softgen.ai/pricing?discountcode=JUPITER30', '_blank');
                
                // Prevent multiple triggers by moving player away from Jupiter
                player.position.set(0, 100, 0); // Reset to a safe position
                
                // Optional: Show a message
                showMessage('üöÄ Launching Softgen.ai...', true);
                return;
            }

            // Check collision with Mars
            if (mars) {
                const marsBox = new THREE.Box3().setFromObject(mars);
                if (playerBox.intersectsBox(marsBox)) {
                    broadcastCrash("mars");
                    currentDeaths++;
                    gameOver("That's one small crash for man, one giant SPLAT for mankind!");

                    // Open Softgen.ai in a new tab
                    window.open('https://softgen.ai/pricing?discountcode=JUPITER30', '_blank');
                    
                    // Prevent multiple triggers by moving player away from Jupiter
                    player.position.set(0, 100, 0); // Reset to a safe position
                    
                    // Optional: Show a message
                    showMessage('üöÄ Launching TryComp.ai...', true);
                    return;
                }
            }

            // Check collision with buildings (flat houses)
            for (let i = 0; i < buildings.length; i++) {
                const building = buildings[i];
                const buildingBox = new THREE.Box3().setFromObject(building);
                // console.log('checking collision with building',i);
                if (playerBox.intersectsBox(buildingBox)) {
                    console.log('collision with building',i);
                    broadcastCrash("building");
                    currentDeaths++;
                    gameOver("You just redefined 'open concept' floor plan!");
                    return;
                }
            }

            // Check collision with houses (with roofs) 
            for (let i = 0; i < houses.length; i++) {
                const house = houses[i];
                const houseBox = new THREE.Box3().setFromObject(house);
                // console.log('checking collision with house',i);
                if (playerBox.intersectsBox(houseBox)) {
                    console.log('collision with house',i);
                    broadcastCrash("house");
                    currentDeaths++;
                    gameOver("Knock knock! Who's there? YOUR PLANE!");
                    return;
                }
            }

            // Check collision with balloons
            for (let i = 0; i < targets.length; i++) {
                const target = targets[i];
                target.boundingBox.setFromObject(target);
                if (playerBox.intersectsBox(target.boundingBox)) {
                    broadcastCrash("balloon");
                    currentDeaths++;
                    gameOver("POP goes the balloon... and your plane!");
                    return;
                }
            }

            // Check castle collision
            const castleBox = new THREE.Box3().setFromObject(castle);
            if (playerBox.intersectsBox(castleBox)) {
                broadcastCrash("castle");
                currentDeaths++;
                gameOver("Your princess is in another castle... and now so is your plane!");
                return; // Important: Stop checking after a collision
            }
            

            // Check tower collision
            const towerBox = new THREE.Box3().setFromObject(towerGroup);
            if (playerBox.intersectsBox(towerBox)) {
                broadcastCrash("atc");
                currentDeaths++;
                gameOver("ATC, we have a problem... I'm IN the tower!");
                return; // Important: Stop checking after a collision
            }


            // // Check collision with mountain
            // const mountainBox = new THREE.Box3().setFromObject(mountain);
            // if (playerBox.intersectsBox(mountainBox)) {
            //     broadcastCrash("mountain");
            //     currentDeaths++;
            //     gameOver("Congratulations! You've just turned your plane into a very expensive mountain decoration!");
            //     return;
            // }

            // Update last altitude for next frame
            lastAltitude = player.position.y;
        }

        // Add after other global variables
        let leftJoystick, rightJoystick;
        let leftJoystickData = { x: 0, y: 0 };
        let rightJoystickData = { x: 0, y: 0 };

        let isRightJoystickDragged = false;

        // Modify WebRTC setup
        let peer;
        let localPlaneId;
        let connections = {};

        // Add after other global variables
        function getPlaneId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('id');
        }

        function setPlaneId(id) {
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('id', id);
            window.history.replaceState({}, '', newUrl);
        }

        const S = '7sw3hs9rmrmcq113';


        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        // Function to play sound when player is hit by another player's missile
        function playSelfHitSound() {
            if (isMuted || !window.audioContext) return;
            
            try {
                // Create oscillator for hit sound
                const oscillator = window.audioContext.createOscillator();
                const gainNode = window.audioContext.createGain();
                
                // Set up a distorted alarm-like sound
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(440, window.audioContext.currentTime); // A4 note
                oscillator.frequency.exponentialRampToValueAtTime(220, window.audioContext.currentTime + 0.2); // Drop to A3
                
                // Set volume envelope
                gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.5);
                
                // Add distortion for more impact
                const distortion = window.audioContext.createWaveShaper();
                
                distortion.curve = makeDistortionCurve(400);
                
                // Connect audio nodes
                oscillator.connect(distortion);
                distortion.connect(gainNode);
                gainNode.connect(window.audioContext.destination);
                
                // Play the sound
                oscillator.start();
                oscillator.stop(window.audioContext.currentTime + 0.5);
                
                // Create visual feedback for being hit
                const hitIndicator = document.createElement('div');
                hitIndicator.style.position = 'fixed';
                hitIndicator.style.top = '0';
                hitIndicator.style.left = '0';
                hitIndicator.style.width = '100%';
                hitIndicator.style.height = '100%';
                hitIndicator.style.border = '10px solid #ff0000';
                hitIndicator.style.boxSizing = 'border-box';
                hitIndicator.style.pointerEvents = 'none';
                hitIndicator.style.zIndex = '1000';
                hitIndicator.style.opacity = '0.7';
                document.body.appendChild(hitIndicator);

                // Fade out and remove the hit indicator
                setTimeout(() => {
                    hitIndicator.style.transition = 'opacity 0.5s';
                    hitIndicator.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(hitIndicator);
                    }, 500);
                }, 100);

                // Create full red overlay for more intense hit feedback
                const redOverlay = document.createElement('div');
                redOverlay.style.position = 'fixed';
                redOverlay.style.top = '0';
                redOverlay.style.left = '0';
                redOverlay.style.width = '100%';
                redOverlay.style.height = '100%';
                redOverlay.style.backgroundColor = '#ff0000';
                redOverlay.style.pointerEvents = 'none';
                redOverlay.style.zIndex = '999';
                redOverlay.style.opacity = '0.3';
                document.body.appendChild(redOverlay);
                
                // Fade out and remove the red overlay
                setTimeout(() => {
                    redOverlay.style.transition = 'opacity 0.5s';
                    redOverlay.style.opacity = '0';
                    setTimeout(() => {
                        document.body.removeChild(redOverlay);
                    }, 500);
                }, 100);
                
                
            } catch (error) {
                console.error('Error playing hit sound:', error);
            }
        }

        // Add handler for incoming hit data
        function handleIncomingHitData(data) {
            // Skip if this is our own hit (we already processed it locally)
            if (data.attackerId === selfPlaneId) return;

            // XSS prevention: Sanitize all incoming data
            if (data.attackerUsername) {
                data.attackerUsername = data.attackerUsername
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            
            if (data.targetUsername) {
                data.targetUsername = data.targetUsername
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            
            // Ensure attackerId and targetId are also sanitized
            if (data.attackerId) {
                data.attackerId = String(data.attackerId)
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }
            
            if (data.targetId) {
                data.targetId = String(data.targetId)
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }

            // console.log('handleIncomingHitData');

            console.log(data.attackerId, ' hit ', data.targetId);
            // console.log(data);
            
            // if it's a hit on ourselves
            // play a special sound 
            if (data.targetId === selfPlaneId) {
                console.log('üí• We are hit by ', data.attackerId);
                // update our own health from server
                currentHealth=data.health;
                playExplosionSound();
                playSelfHitSound();
                updateScoreDisplay();
                if(data.isKill) {
                    gameOver("You were killed by <b>" + data.attackerUsername + "</b>");
                    showMessage(`<b>${escapeHtml(data.attackerUsername)}</b> killed you`, true);
                }
                else {
                    showMessage(`<b>${escapeHtml(data.attackerUsername)}</b> hit you`, true);
                }
                return;
            }

            // Find the target plane in our local scene
            const targetPlane = otherPlayers.get(data.targetId);
            if (!targetPlane) {
                console.log(`‚ö†Ô∏è Received hit for unknown plane: ${data.targetId}`);
                return;
            }

            // Use the health value from the server data
            targetPlane.userData.health = data.health; // Use server's health value
            // console.log('Set targetPlane planeId ', data.targetId, ' health to ', data.health, ' = ',targetPlane.userData.health);
            
            // Update plane appearance based on new health
            updatePlaneColorBasedOnHealth(targetPlane);
            
            // Create visual effects
            createHitEffect(targetPlane.position.clone());
            if (data.isKill) {
                createExplosionEffect(targetPlane.position.clone());
                playExplosionSound();
            }
            
            // Show message about the hit
            const attackerName = data.attackerUsername || data.attackerId;
            const targetName = data.targetUsername || data.targetId;
            
            if (data.isKill) {
                showMessage(`<b>${escapeHtml(attackerName)}</b> killed <b>${escapeHtml(targetName)}</b>`);
            } else {
                showMessage(`<b>${escapeHtml(attackerName)}</b> hit <b>${escapeHtml(targetName)}</b> (${(targetPlane.userData.health)}%)`);
            }
        }

       
        function showChatMessage(username, message) {

            // Check for potentially malicious content
            const dangerousPatterns = [
                /<[^>]*>/,              // HTML tags
                /javascript:/i,          // JavaScript protocol
                /data:/i,               // Data protocol
                /vbscript:/i,           // VBScript protocol
                /on\w+=/i,              // Event handlers
                /&[#\w]+;/,             // HTML entities
                /\\x[0-9a-fA-F]{2}/,    // Hex escapes
                /\\u[0-9a-fA-F]{4}/,    // Unicode escapes
                /%[0-9a-fA-F]{2}/,      // URL encoding
                /\(\)/,                 // Function calls
                /\[\]/,                 // Array brackets
                /{{.*}}/,               // Template injection
                /\${.*}/,               // Template injection
                /`/                     // Backticks
            ];

            // Check message against dangerous patterns
            for (const pattern of dangerousPatterns) {
                if (pattern.test(message)) {
                    console.log('Blocked potentially malicious chat message');
                    return; // Exit without showing message
                }
            }
            // Create message element
            const messageElement = document.createElement('div');
            messageElement.className = 'chatMessage';

            // Sanitize username and message to prevent XSS
            const sanitizedUsername = username.replace(/[<>]/g, '');
            const sanitizedMessage = message.replace(/[<>]/g, '');

            // Format message with username
            messageElement.textContent = `${sanitizedUsername}: ${sanitizedMessage}`;

            // Add to chat messages container
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.appendChild(messageElement);
            // If we exceed 5 messages, fade out and remove the oldest one
            const messages = chatMessages.getElementsByClassName('chatMessage');
            if (messages.length > 5) {
                const oldestMessage = messages[0];
                oldestMessage.classList.add('fading');
                setTimeout(() => {
                    if (oldestMessage.parentNode) {
                        oldestMessage.remove();
                    }
                }, 2000); // Remove after fade animation
            }
        }




        function handleIncomingChatData(data) {
            // Don't show our own messages again (they're already shown when sent)
            showChatMessage(data.username, data.message);
        }



        // Handle incoming peer data
        function handleIncomingPlaneData(data, planeId) {
            // More detailed logging to see exactly what we're receiving
            // console.log("Raw data received:", JSON.stringify(data));
            
            if (data.type === 'position') {
                // Extract position data from the correct location in the object
                let positionData = null;
                
                // Try to find position data in various possible locations
                positionData = data.data.position;
                // console.log("Found position in data.data.position");
                
                // If we still don't have position data, log an error and return
                if (!positionData) {
                    console.error("Could not find position data in:", data);
                    return;
                }
                
                // console.log(`üõ©Ô∏è Using position data:`, positionData);
                

                // Skip planes without username
                if (!data.username) {
                    return;
                }
                
                
                // Create or update other player's plane
                let otherPlane = otherPlayers.get(data.planeId);
                if (!otherPlane) {
                    // console.log(`‚úàÔ∏è Creating new plane for ${planeIdentifier}`);
                    otherPlane = createOtherPlayerPlane();

                    // Set initial health for new planes
                    otherPlane.userData.username = data.data.username;
                    otherPlane.userData.health = data.data.health;
                    otherPlane.userData.kills  = data.data.kills;
                    otherPlane.userData.deaths  = data.data.deaths;
                    otherPlane.userData.lastUpdate = Date.now();
                    
                    
                    // Create initial name sprite with health
                    const nameSprite = createNameLabel(data.username, data.data.health);
                    otherPlane.add(nameSprite);
                    
                    
                    scene.add(otherPlane);
                    otherPlayers.set(data.planeId, otherPlane);
                    // console.log(`‚úÖ New plane added to scene. Total planes: ${otherPlayers.size}`);
                }
                else {
                     // Update the last update timestamp
                    otherPlane.userData.lastUpdate = Date.now();
                    // Update health in userData
                    otherPlane.userData.health = data.data.health;

                    // Update the name sprite with new health
                    const sprite = otherPlane.children.find(child => child instanceof THREE.Sprite);
                        if (sprite) {
                            const canvas = document.createElement('canvas');
                            const context = canvas.getContext('2d');
                            canvas.width = 256;
                            canvas.height = 64;
                            
                            context.font = '24px system-ui';
                            context.fillStyle = 'white';
                            context.textAlign = 'center';
                            const text = `${data.username} (${data.data.health}%)`;
                            context.fillText(text, canvas.width/2, canvas.height/2);
                            
                            // Update sprite texture
                            sprite.material.map.dispose();
                            sprite.material.map = new THREE.CanvasTexture(canvas);
                            sprite.material.needsUpdate = true;
                        }
                }
                
                // Always update position - log every update for debugging
                // console.log(`üîÑ Updating plane ${planeIdentifier} position:`, {
                //     x: positionData.x,
                //     y: positionData.y,
                //     z: positionData.z
                // });
                
                // Check if we have valid position data before updating
                if (positionData.x !== undefined && positionData.y !== undefined && positionData.z !== undefined) {
                    // Update position
                    otherPlane.position.set(positionData.x, positionData.y, positionData.z);
                    
                    // Check if rotation data exists before setting
                    if (positionData.rotationX !== undefined && 
                        positionData.rotationY !== undefined && 
                        positionData.rotationZ !== undefined) {
                        otherPlane.rotation.set(positionData.rotationX, positionData.rotationY, positionData.rotationZ);
                    }
            
                    // Store speed and heading directly on the plane object
                    otherPlane.userData.lastUpdateTime = Date.now();
                    otherPlane.userData.speed = positionData.speed || 0;
                    otherPlane.userData.heading = positionData.heading || 0;
                    
                    // Calculate distance of OTHER PLANE from runway spawnpoint
                    const otherPlaneDistanceFromSpawn = Math.sqrt(
                        Math.pow(otherPlane.position.x - SPAWN_POINT_X, 2) + 
                        Math.pow(otherPlane.position.z - SPAWN_POINT_Z, 2) +
                        Math.pow(otherPlane.position.y - SPAWN_POINT_Y, 2)
                    );

                    minimumOpacityOnRunway=0.1;

                    // Fade in planes based on OTHER PLANE's distance from runway
                    if (otherPlaneDistanceFromSpawn < RUNWAY_FADE_START) {
                        // Other plane is close to runway, make it almost invisible
                        otherPlane.traverse(child => {
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.transparent = true;
                                        mat.opacity = minimumOpacityOnRunway;
                                    });
                                } else {
                                    child.material.transparent = true;
                                    child.material.opacity = minimumOpacityOnRunway;
                                }
                            }
                        });
                    } else if (otherPlaneDistanceFromSpawn < RUNWAY_FADE_DISTANCE) {
                        // Other plane is in the fade zone, gradually increase opacity
                        const fadeRatio = (otherPlaneDistanceFromSpawn - RUNWAY_FADE_START) / 
                                         (RUNWAY_FADE_DISTANCE - RUNWAY_FADE_START);
                        otherPlane.traverse(child => {
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.transparent = true;
                                        mat.opacity = Math.max(0.1, Math.min(fadeRatio, 1.0));
                                    });
                                } else {
                                    child.material.transparent = true;
                                    child.material.opacity = Math.max(0.1, Math.min(fadeRatio, 1.0));
                                }
                            }
                        });
                    } else {
                        // Other plane is far from runway, make it fully visible
                        otherPlane.traverse(child => {
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(mat => {
                                        mat.transparent = false;
                                        mat.opacity = 1.0;
                                    });
                                } else {
                                    child.material.transparent = false;
                                    child.material.opacity = 1.0;
                                }
                            }
                        });
                    }
                    
                    // Update the name sprite to face the camera
                    const sprite = otherPlane.children.find(child => child instanceof THREE.Sprite);
                    if (sprite) {
                        sprite.quaternion.copy(camera.quaternion);
                        // Also apply the same opacity to the name sprite
                        if (otherPlaneDistanceFromSpawn < RUNWAY_FADE_DISTANCE) {
                            const fadeRatio = otherPlaneDistanceFromSpawn < RUNWAY_FADE_START ? minimumOpacityOnRunway : 
                                             (otherPlaneDistanceFromSpawn - RUNWAY_FADE_START) / 
                                             (RUNWAY_FADE_DISTANCE - RUNWAY_FADE_START);
                            sprite.material.opacity = Math.min(fadeRatio, 1.0);
                        } else {
                            sprite.material.opacity = 1.0;
                        }
                    }
                } else {
                    console.warn(`‚ö†Ô∏è Invalid position data for plane ${planeId}:`, positionData);
                }
            }
        }



        // Add cleanup function for stale players
        function cleanupStalePlayers() {
            const currentTime = Date.now();
            let playersRemoved = false;
            
            otherPlayers.forEach((plane, planeId) => {
                if (currentTime - plane.userData.lastUpdate > PLAYER_TIMEOUT) {
                    console.log(`üßπ Removing stale player ${planeId} (no updates for ${PLAYER_TIMEOUT/1000}s)`);
                    
                    // Remove plane from scene
                    scene.remove(plane);
                    otherPlayers.delete(planeId);
                    playersRemoved = true;
                }
            });
            
            // Update score display if any players were removed
            if (playersRemoved) {
                updateScoreDisplay();
            }
        }


        // Add cleanup interval
        setInterval(cleanupStalePlayers, 5000); // Check every 5 seconds

        // Update function to use actual delta time
        function interpolateMoveOtherPlanes() {
            otherPlayers.forEach((plane, planeId) => {
                if (!plane.userData.speed || !plane.userData.heading) return;

                const speed = plane.userData.speed;
                const heading = plane.userData.heading;
                const headingRad = (heading * Math.PI) / 180;

                // Corrected movement calculation
                const distanceMoved = speed  * deltaTime; // Match updatePlayer scale

                const dx = -Math.sin(headingRad) * distanceMoved;
                const dz = -Math.cos(headingRad) * distanceMoved;

                // Vertical speed correction
                const verticalSpeed = plane.userData.verticalSpeed || 0;
                const dy = verticalSpeed * deltaTime; 

                // console.log(planeId,dx,dy,dz);

                // Target positions
                const targetX = plane.position.x + dx;
                const targetZ = plane.position.z + dz;
                const targetY = plane.position.y + dy;

                // Smoothed interpolation
                const lerpFactor = 1 - Math.exp(-10 * deltaTime); 

                plane.position.x += (targetX - plane.position.x) * lerpFactor;
                plane.position.z += (targetZ - plane.position.z) * lerpFactor;
                plane.position.y += (targetY - plane.position.y) * lerpFactor;

                // Update plane rotation
                plane.rotation.y = -headingRad;

                // Ensure name sprite faces the camera
                const sprite = plane.children.find(child => child instanceof THREE.Sprite);
                if (sprite) {
                    sprite.quaternion.copy(camera.quaternion);
                }
            });
        }

        // Initialize WebRTC when the game starts
        window.addEventListener('load', () => {
            // Call setupWebSocket without expecting a Promise
            try {
                setupWebSocket();
            } catch (error) {
                console.error('Failed to setup WebSocket:', error);
                showMessage('Connection failed');
            }
        });

        // Add after other global variables
        let metricsVisible = true;

        // Add click handler to metrics div
        document.getElementById('metrics').addEventListener('click', function() {
            metricsVisible = !metricsVisible;
            this.style.opacity = metricsVisible ? '1' : '0';
            this.style.pointerEvents = metricsVisible ? 'auto' : 'none';
        });

        // Modify the metrics div style to add smooth transition
        document.getElementById('metrics').style.transition = 'opacity 0.3s ease';
        document.getElementById('metrics').style.cursor = 'pointer';

      
        let selfPlaneId = generatePlaneId(); // Generate a unique ID for this plane

        
        
        // Force window resize on page load to ensure proper rendering
        // this fixes the half black load screen
        document.addEventListener('DOMContentLoaded', function() {
            // Trigger window resize event after a short delay to ensure all elements are loaded
            setTimeout(function() {
                window.dispatchEvent(new Event('resize'));
                console.log('‚úàÔ∏è Window resize triggered for proper rendering');
            }, 100);
        });

        
        // <ticker tape>
            function createTickerTape() {
                // Add ticker tape
                const tickerTape = document.createElement('div');
                tickerTape.id = 'tickerTape';
                tickerTape.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    background-color: rgba(255, 0, 0, 0.5);
                    color: white;
                    padding: 5px 0;
                    font-family: Arial, sans-serif;
                    font-weight: bold;
                    white-space: nowrap;
                    overflow: hidden;
                    z-index: 10;
                `;

                const tickerContent = document.createElement('div');
                tickerContent.style.cssText = `
                    display: inline-block;
                    animation: tickerScroll 20s linear infinite;
                    transform: translateX(-50%); /* Start in middle */
                `;
                
                tickerContent.textContent = `ATIS: Pieter International Airport, ATIS Information Bravo. Wind ${Math.round(windDirection).toString().padStart(3, '0')} at ${Math.round(windSpeed)} knots, visibility 10 miles, temperature 15¬∞C, dew point 10¬∞C, altimeter 29.92. Runway 42 in use. Contact ground on 121.8.`;

                // Add animation keyframes
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes tickerScroll {
                        0% { transform: translateX(50%); }
                        100% { transform: translateX(-150%); }
                    }
                `;

                document.head.appendChild(style);
                tickerTape.appendChild(tickerContent);
                document.body.appendChild(tickerTape);

                // Fade out ticker tape after 15 seconds
                setTimeout(function() {
                    const tickerTape = document.getElementById('tickerTape');
                    if (tickerTape) {
                        // Add transition style
                        tickerTape.style.transition = 'opacity 1s';
                        tickerTape.style.opacity = '0';
                        
                        // Remove element after fade completes
                        setTimeout(function() {
                            tickerTape.remove();
                        }, 1000);
                    }
                }, 15000);

                return;
                // Play morse code audio for 5 seconds
                const morseCode = new Audio('data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAAABmYWN0BAAAAAAAAABkYXRhAAAAAA==');
                morseCode.volume = 0.3;

                // Create oscillator for morse code beeps
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.value = 600;
                gainNode.gain.value = 0;
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();

                // Morse code timing (in seconds)
                const dot = 0.1;
                const dash = dot * 3;
                const gap = dot;
                const letterGap = dot * 3;
                
                // Convert text to morse code timing
                const message = "HI";
                let currentTime = audioContext.currentTime;

                const morsePatterns = {
                    'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 
                    'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---',
                    'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---',
                    'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-',
                    'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--',
                    'Z': '--..'
                };

                // Play each character
                for (let char of message) {
                    if (char === ' ') {
                        currentTime += letterGap;
                        continue;
                    }
                    
                    const pattern = morsePatterns[char];
                    if (pattern) {
                        for (let symbol of pattern) {
                            gainNode.gain.setValueAtTime(0.2, currentTime);
                            currentTime += symbol === '.' ? dot : dash;
                            gainNode.gain.setValueAtTime(0, currentTime);
                            currentTime += gap;
                        }
                        currentTime += letterGap;
                    }
                }

                // Stop after 5 seconds
                setTimeout(() => {
                    oscillator.stop();
                    oscillator.disconnect();
                    gainNode.disconnect();
                }, 2500);
            }


        // Function to generate a unique plane ID
        function generatePlaneId() {
            // Generate a random string of letters and numbers
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let id = '';
            for (let i = 0; i < 6; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            console.log('‚úàÔ∏è My plane ID:', id);
            return id;
        }

       
        

        // Modify broadcastPosition function
        function broadcastPosition() {
                        
            if (typeof socket === 'undefined' || !socket || socket.readyState !== WebSocket.OPEN) {
                if (Math.random() < 0.01) { // Log only occasionally
                    console.log('‚è≥ Waiting for WebSocket connection...');
                }
                return;
            }

            const currentTime = Date.now();
            if (currentTime - lastPositionUpdate < BROADCAST_INTERVAL * 1000) {
                return;
            }

            // Round position data to 2 decimal places to save space
            const positionData = {
                x: Math.round(player.position.x * 100) / 100,
                y: Math.round(player.position.y * 100) / 100,
                z: Math.round(player.position.z * 100) / 100,
                rotationX: Math.round(player.rotation.x * 100) / 100,
                rotationY: Math.round(player.rotation.y * 100) / 100,
                rotationZ: Math.round(player.rotation.z * 100) / 100,
                speed: Math.round(currentSpeed),
                heading: currentHeading,
                verticalSpeed: Math.round(currentVerticalSpeed * 100) / 100,
                timestamp: currentTime
            };
            
            const message = {
                type: 'position',
                planeId: selfPlaneId, // Include our own plane ID in the broadcast
                username: selfUsername,                
                data: positionData,
                verifyToken: verifyToken
            };

            // Log position updates occasionally
            // console.log('üì° Broadcasting position:', message);

            try {
                socket.send(JSON.stringify(message));
                lastPositionUpdate = currentTime;
            } catch (err) {
                console.error('‚ùå Failed to send position:', err);
            }
        }

        // Add after other global variables
        const otherPlayers = new Map(); // Store other players' models

        // Make sure updateScoreDisplay can find the element
        function updateScoreDisplay(shake = false) {
            const scoreDiv = document.getElementById('scoreDisplay');

            if (scoreDiv) {
                
                if (balloonsHit > 0 || currentKills > 0) {
                    if (scoreDiv.style.display === 'none') {
                        scoreDiv.style.display = 'block';
                    }
                }

                const playerCount = (typeof otherPlayers !== 'undefined' ? otherPlayers.size : 0);
                scoreDiv.innerHTML = `üéà${balloonsHit}/${totalBalloons}<br>‚ò†Ô∏è${currentKills}/${playerCount}`;
                
                // Visual feedback only if shake is true
                if (shake) {
                    scoreDiv.style.transform = 'scale(1.5)';
                    setTimeout(() => {
                        scoreDiv.style.transform = 'scale(1.3)';
                        setTimeout(() => {
                            scoreDiv.style.transform = 'scale(1)';
                        }, 150);
                    }, 150);
                }
            }
        }
        

        // Add this function to update plane color based on health
        function updatePlaneColorBasedOnHealth(plane) {
                // Get health value (default to 100 if not set)
            const health = plane.userData.health !== undefined ? plane.userData.health : 100;
            

            
            // If health is zero or less, hide the plane
            if (health <= 0) {
                plane.visible = false;
                return;
            } else {
                // Make sure plane is visible if it has health
                plane.visible = true;
            }

                // Calculate color based on health percentage
                let color;
                if (health <= 0) {
                    // Black if dead
                color = new THREE.Color(0x000000);
                } else if (health <= 30) {
                    // Very dark grey for critical health (0-30%)
                color = new THREE.Color(0x222222);
                } else if (health <= 99) {
                    // Yellow for medium health (31-60%)
                color = new THREE.Color(0xffff00);
                } else {
                    // Red for good health (61-100%)
                color = new THREE.Color(0xff0000);
            }
            
            // Apply color to all meshes in the plane
            plane.traverse((object) => {
                if (object instanceof THREE.Mesh && object.material) {
                    // Clone the material if it's shared to avoid affecting other objects
                    if (object.material.userData.originalColor === undefined) {
                        object.material = object.material.clone();
                        // Store original color for potential future use
                        object.material.userData.originalColor = object.material.color.clone();
                    }
                    object.material.color = color;
                }
            });
        }

        // Add function to create other player's plane
        function createOtherPlayerPlane() {
            const otherPlane = new THREE.Group();
            
            // Simplified plane model (similar to player plane but different color)
            const fuselage = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 4),
                new THREE.MeshPhongMaterial({ color: 0xff0000,fog: true }) // Red color to distinguish
            );
            
            const wings = new THREE.Mesh(
                new THREE.BoxGeometry(7, 0.2, 2),
                new THREE.MeshPhongMaterial({ color: 0xff0000,fog: true })
            );
            wings.position.y = 0.1;
            
            const tail = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.8, 0.5),
                new THREE.MeshPhongMaterial({ color: 0xff0000,fog: true })
            );
            tail.position.z = -1.8;
            tail.position.y = 0.4;
            
            otherPlane.add(fuselage);
            otherPlane.add(wings);
            otherPlane.add(tail);
            
            // Set initial health
            otherPlane.userData.health = 100;

            return otherPlane;
        }

        // Add after other global variables
        let isMouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Add after other event listeners
        document.addEventListener('mousedown', (event) => {
            isMouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        

        document.addEventListener('touchend', () => {
            isMouseDown = false;
        });


        // Add pointer lock setup
        document.addEventListener('click', () => {
            // Only request pointer lock if game has started and we're not already locked
            if (gameStarted && !isPointerLocked) {
                // Request pointer lock on the document body
                document.body.requestPointerLock = document.body.requestPointerLock ||
                                                 document.body.mozRequestPointerLock ||
                                                 document.body.webkitRequestPointerLock;
                document.body.requestPointerLock();
            }
        });

        // Track pointer lock state
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === document.body;
        }, false);

        document.addEventListener('mozpointerlockchange', () => {
            isPointerLocked = document.mozPointerLockElement === document.body;
        }, false);

        // Single mouse move handler for both locked and unlocked states
        document.addEventListener('mousemove', (event) => {
            if(isMobileDevice) return;
            if (!gameStarted) return;
            
            if (isPointerLocked) {
                // Use movementX/Y when pointer is locked
                mouseX -= event.movementX * mouseSensitivity;
                mouseY -= event.movementY * mouseSensitivity;
                } else {
                // Use regular mouse position when unlocked
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                mouseX = -(event.clientX - centerX) * 0.001;
                mouseY = -(event.clientY - centerY) * 0.001;
            }
            
            // Update last mouse move time for auto-centering
            lastMouseMoveTime = Date.now();
        });

        // Add escape key handler to exit pointer lock
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Escape') {
                document.exitPointerLock = document.exitPointerLock ||
                                         document.mozExitPointerLock ||
                                         document.webkitExitPointerLock;
                document.exitPointerLock();
            }
        });

        // <bolt.new cloud>
            // Function to create a line segment for letters
            function createLetterSegment(width, height, depth, x, y, z) {
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    metalness: 0.1,
                    roughness: 0.9,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0x555555,
                    emissiveIntensity: 0.2
                });
                const segment = new THREE.Mesh(geometry, material);
                segment.position.set(x, y, z);
                return segment;
            }

            // Create a group to hold all letters
            const textCloudGroup = new THREE.Group();

            // B (using segments)
            const b1 = createLetterSegment(5, 40, 5, 0, 0, 0); // vertical
            const b2 = createLetterSegment(15, 5, 5, 10, 15, 0); // top curve
            const b3 = createLetterSegment(15, 5, 5, 10, -15, 0); // bottom curve
            const b4 = createLetterSegment(15, 5, 5, 10, 0, 0); // middle
            const b5 = createLetterSegment(5, 15, 5, 20, 7.5, 0); // top right vertical
            const b6 = createLetterSegment(5, 15, 5, 20, -7.5, 0); // bottom right vertical
            textCloudGroup.add(b1, b2, b3, b4, b5, b6);

            // O (using segments)
            const o1 = createLetterSegment(5, 40, 5, 35, 0, 0); // left
            const o2 = createLetterSegment(5, 40, 5, 55, 0, 0); // right
            const o3 = createLetterSegment(15, 5, 5, 45, 15, 0); // top
            const o4 = createLetterSegment(15, 5, 5, 45, -15, 0); // bottom
            textCloudGroup.add(o1, o2, o3, o4);

            // L
            const l1 = createLetterSegment(5, 40, 5, 80, 0, 0); // vertical
            const l2 = createLetterSegment(15, 5, 5, 90, -15, 0); // bottom
            textCloudGroup.add(l1, l2);

            // T
            const t1 = createLetterSegment(5, 40, 5, 115, 0, 0); // vertical
            const t2 = createLetterSegment(25, 5, 5, 115, 15, 0); // top
            textCloudGroup.add(t1, t2);

            // Period
            const period = createLetterSegment(5, 5, 5, 140, -15, 0);
            textCloudGroup.add(period);

            // N
            const n1 = createLetterSegment(5, 40, 5, 165, 0, 0); // left vertical
            const n2 = createLetterSegment(5, 40, 5, 185, 0, 0); // right vertical
            const n3 = createLetterSegment(5, 45, 5, 175, 0, 0); // diagonal
            n3.rotation.z = Math.PI / 6;
            textCloudGroup.add(n1, n2, n3);

            // E
            const e1 = createLetterSegment(5, 40, 5, 210, 0, 0); // vertical
            const e2 = createLetterSegment(15, 5, 5, 220, 15, 0); // top
            const e3 = createLetterSegment(15, 5, 5, 220, 0, 0); // middle
            const e4 = createLetterSegment(15, 5, 5, 220, -15, 0); // bottom
            textCloudGroup.add(e1, e2, e3, e4);

            // W
            const w1 = createLetterSegment(5, 40, 5, 245, 0, 0); // left vertical
            const w2 = createLetterSegment(5, 40, 5, 255, 0, 0); // middle vertical 
            const w3 = createLetterSegment(5, 40, 5, 265, 0, 0); // right vertical
            const w4 = createLetterSegment(5, 25, 5, 250, -7, 0); // left diagonal
            const w5 = createLetterSegment(5, 25, 5, 260, -7, 0); // right diagonal
            w4.rotation.z = Math.PI / 6;
            w5.rotation.z = -Math.PI / 6;
            textCloudGroup.add(w1, w2, w3, w4, w5);

            // Position the entire text group
            textCloudGroup.position.set(-450, 250, -200); // Adjust position as needed
            textCloudGroup.rotation.y=0.5;
            
            // Add floating animation
            function animateText() {
                textCloudGroup.position.y += Math.sin(Date.now() * 0.001) * 0.5;
                requestAnimationFrame(animateText);
            }
            animateText();

            scene.add(textCloudGroup);
        // </bolt.new cloud>

        // <lofty.ai floating house>
            // Create floating house group
            const floatingHouseGroup = new THREE.Group();

            // Create house body
            const floatingHouseBody = new THREE.BoxGeometry(20, 15, 20);
            const floatingHouseWallMaterial = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });
            const floatingHouseWalls = new THREE.Mesh(floatingHouseBody, floatingHouseWallMaterial);
            floatingHouseGroup.add(floatingHouseWalls);

            // Create red roof (triangular prism)
            const floatingHouseRoofGeometry = new THREE.CylinderGeometry(0, 15, 10, 4, 1);
            const floatingHouseRoofMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
            const floatingHouseRoof = new THREE.Mesh(floatingHouseRoofGeometry, floatingHouseRoofMaterial);
            floatingHouseRoof.rotation.y = Math.PI / 4; // Rotate 45 degrees
            floatingHouseRoof.position.y = 12.5;
            floatingHouseGroup.add(floatingHouseRoof);

            // Create door
            const floatingHouseDoorGeometry = new THREE.PlaneGeometry(5, 8);
            const floatingHouseDoorMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const floatingHouseDoor = new THREE.Mesh(floatingHouseDoorGeometry, floatingHouseDoorMaterial);
            floatingHouseDoor.position.set(0, -3.5, 10.1);
            floatingHouseGroup.add(floatingHouseDoor);

            // Create windows
            const floatingHouseWindowGeometry = new THREE.PlaneGeometry(4, 4);
            const floatingHouseWindowMaterial = new THREE.MeshPhongMaterial({ color: 0x87CEEB });

            // Left window
            const floatingHouseWindowLeft = new THREE.Mesh(floatingHouseWindowGeometry, floatingHouseWindowMaterial);
            floatingHouseWindowLeft.position.set(-6, 2, 10.1);
            floatingHouseGroup.add(floatingHouseWindowLeft);

            // Right window
            const floatingHouseWindowRight = new THREE.Mesh(floatingHouseWindowGeometry, floatingHouseWindowMaterial);
            floatingHouseWindowRight.position.set(6, 2, 10.1);
            floatingHouseGroup.add(floatingHouseWindowRight);

            // Create text label
            const floatingHouseLabelCanvas = document.createElement('canvas');
            const floatingHouseLabelContext = floatingHouseLabelCanvas.getContext('2d');
            floatingHouseLabelCanvas.width = 512;
            floatingHouseLabelCanvas.height = 64;

            floatingHouseLabelContext.fillStyle = '#FFFFFF';
            floatingHouseLabelContext.fillRect(0, 0, floatingHouseLabelCanvas.width, floatingHouseLabelCanvas.height);
            floatingHouseLabelContext.font = 'bold 24px system-ui';
            floatingHouseLabelContext.fillStyle = '#000000';
            floatingHouseLabelContext.textAlign = 'center';
            floatingHouseLabelContext.fillText('Invest in rental properties on LOFTY.AI', 256, 40);

            const floatingHouseLabelTexture = new THREE.CanvasTexture(floatingHouseLabelCanvas);
            const floatingHouseLabelGeometry = new THREE.PlaneGeometry(30, 4);
            const floatingHouseLabelMaterial = new THREE.MeshBasicMaterial({ 
                map: floatingHouseLabelTexture,
                transparent: true
            });
            const floatingHouseLabel = new THREE.Mesh(floatingHouseLabelGeometry, floatingHouseLabelMaterial);
            floatingHouseLabel.position.set(0, -10, 25);
            floatingHouseGroup.add(floatingHouseLabel);

            // Create cloud group
            const cloudGroup = new THREE.Group();
            const blockGeometry = new THREE.BoxGeometry(4, 2, 4);
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.9,
                flatShading: true
            });

            const width = 7 + Math.floor(Math.random() * 3);
            const length = 7 + Math.floor(Math.random() * 4);
            
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < length; z++) {
                    const height = Math.random() > 0.5 ? 2 : 3;
                    for (let y = 0; y < height; y++) {
                        const block = new THREE.Mesh(blockGeometry, cloudMaterial);
                        block.position.set(
                            x * 3.5 + (Math.random() - 0.5) * 0.5,
                            y * 1.5,
                            z * 3.5 + (Math.random() - 0.5) * 0.5
                        );
                        cloudGroup.add(block);
                    }
                }
            }

            // Position cloud relative to house
            cloudGroup.position.set(-10, -10, -10);
            floatingHouseGroup.add(cloudGroup);

            // Position entire house group in sky
            floatingHouseGroup.position.set(200, 250, -100);
            floatingHouseGroup.rotation.y=-1;

            // Add floating animation
            function animateFloatingHouse() {
                floatingHouseGroup.position.y = 200 + Math.sin(Date.now() * 0.001) * 5;
                requestAnimationFrame(animateFloatingHouse);
            }
            animateFloatingHouse();

            scene.add(floatingHouseGroup);
        // </lofty.ai floating house>


        // <fly through ring - @pattybuilds>
            // Create a fly through ring with @pattybuilds text
            const flyThroughRingGroup = new THREE.Group();
            
            // Create the ring
            const flyThroughRingOuterRadius = 15;
            const flyThroughRingInnerRadius = 12;
            const flyThroughRingTubeRadius = flyThroughRingOuterRadius - flyThroughRingInnerRadius;
            const flyThroughRingRadialSegments = 32;
            const flyThroughRingTubularSegments = 32;
            
            const flyThroughRingGeometry = new THREE.TorusGeometry(
                flyThroughRingInnerRadius + flyThroughRingTubeRadius/2, 
                flyThroughRingTubeRadius/2, 
                flyThroughRingRadialSegments, 
                flyThroughRingTubularSegments
            );
            
            const flyThroughRingMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF0000, // Bright red
                shininess: 50,
                emissive: 0x330000, // Slight glow effect
                emissiveIntensity: 0.5 // Increase emissive intensity
            });
            
            const flyThroughRing = new THREE.Mesh(flyThroughRingGeometry, flyThroughRingMaterial);
            flyThroughRingGroup.add(flyThroughRing);
            
            // Create text for the top of the ring
            const flyThroughRingCanvas = document.createElement('canvas');
            const flyThroughRingContext = flyThroughRingCanvas.getContext('2d');
            flyThroughRingCanvas.width = 512;
            flyThroughRingCanvas.height = 128;
            
            // Clear background
            flyThroughRingContext.fillStyle = 'rgba(0, 0, 0, 0)';
            flyThroughRingContext.fillRect(0, 0, flyThroughRingCanvas.width, flyThroughRingCanvas.height);
            
            // Draw text
            flyThroughRingContext.font = 'bold 80px system-ui';
            flyThroughRingContext.textAlign = 'center';
            flyThroughRingContext.textBaseline = 'middle';
            flyThroughRingContext.fillStyle = 'red';
            flyThroughRingContext.strokeStyle = 'white';
            flyThroughRingContext.lineWidth = 4;
            flyThroughRingContext.strokeText('@pattybuilds', flyThroughRingCanvas.width/2, flyThroughRingCanvas.height/2);
            flyThroughRingContext.fillText('@pattybuilds', flyThroughRingCanvas.width/2, flyThroughRingCanvas.height/2);
            
            const flyThroughRingTextTexture = new THREE.CanvasTexture(flyThroughRingCanvas);
            const flyThroughRingTextMaterial = new THREE.MeshBasicMaterial({
                map: flyThroughRingTextTexture,
                transparent: true,
                side: THREE.DoubleSide,
                fog:false
            });
            
            const flyThroughRingTextGeometry = new THREE.PlaneGeometry(20, 5);
            const flyThroughRingText = new THREE.Mesh(flyThroughRingTextGeometry, flyThroughRingTextMaterial);
            flyThroughRingText.position.y = flyThroughRingOuterRadius + 3;
            flyThroughRingGroup.add(flyThroughRingText);
            
            // Position the ring in a more visible location
            flyThroughRingGroup.position.set(0, 35, 40);
            // flyThroughRingGroup.position.set(-100, 100, -100);
            flyThroughRingGroup.rotation.x = 0; // Make the ring stand up straight (no rotation)
            // flyThroughRingGroup.rotation.y=1;;
            flyThroughRingGroup.scale.set(1, 1, 1); // Make the ring 0.5x the size (changed from 2 to 1)

            // // Add subtle floating animation
            // function animateFlyThroughRing() {
            //     flyThroughRingGroup.position.y = 50 + Math.sin(Date.now() * 0.0005) * 2;
            //     flyThroughRingGroup.rotation.z = Math.sin(Date.now() * 0.0003) * 0.05;
                
            //     // Add a slight rotation to make it more noticeable
            //     flyThroughRingGroup.rotation.y = Math.sin(Date.now() * 0.0002) * 0.1;
                
            //     requestAnimationFrame(animateFlyThroughRing);
            // }
            // animateFlyThroughRing();
            
            scene.add(flyThroughRingGroup);
                    // </fly through ring - @pattybuilds>

        // <leaderboard in-game>
        /*
            // Create in-game leaderboard as a jumbotron
            const inGameLeaderboardGroup = new THREE.Group();

            // Create leaderboard canvas
            const inGameLeaderboardCanvas = document.createElement('canvas');
            const inGameLeaderboardContext = inGameLeaderboardCanvas.getContext('2d');
            inGameLeaderboardCanvas.width = 1024;
            inGameLeaderboardCanvas.height = 768;

            // Create texture from canvas
            const inGameLeaderboardTexture = new THREE.CanvasTexture(inGameLeaderboardCanvas);
            const inGameLeaderboardMaterial = new THREE.MeshBasicMaterial({
                map: inGameLeaderboardTexture,
                transparent: false,
                side: THREE.DoubleSide
            });

            // Create leaderboard plane
            const inGameLeaderboardGeometry = new THREE.PlaneGeometry(40, 30);
            const inGameLeaderboardMesh = new THREE.Mesh(inGameLeaderboardGeometry, inGameLeaderboardMaterial);
            inGameLeaderboardGroup.add(inGameLeaderboardMesh);

            // Position near the runway
            inGameLeaderboardGroup.position.set(50, 50, 0);
            inGameLeaderboardGroup.rotation.y = Math.PI / 4; // Angle it for better visibility

            // Add to scene
            scene.add(inGameLeaderboardGroup);

            // Update function to refresh leaderboard with real player data
            function updateLeaderboard() {

                if(!gameStarted) return;
                
                // Clear the canvas
                inGameLeaderboardContext.fillStyle = '#000000';
                inGameLeaderboardContext.fillRect(0, 0, inGameLeaderboardCanvas.width, inGameLeaderboardCanvas.height);
                
                // White border
                inGameLeaderboardContext.strokeStyle = '#FFFFFF';
                inGameLeaderboardContext.lineWidth = 8;
                inGameLeaderboardContext.strokeRect(10, 10, inGameLeaderboardCanvas.width - 20, inGameLeaderboardCanvas.height - 20);
                
                // Title
                inGameLeaderboardContext.font = 'bold 60px system-ui';
                inGameLeaderboardContext.fillStyle = '#FFFFFF';
                inGameLeaderboardContext.textAlign = 'center';
                inGameLeaderboardContext.fillText('LEADERBOARD', inGameLeaderboardCanvas.width/2, 80);
                
                // Column headers
                inGameLeaderboardContext.font = 'bold 40px system-ui';
                inGameLeaderboardContext.fillText('RANK', 100, 150);
                inGameLeaderboardContext.fillText('PLAYER', inGameLeaderboardCanvas.width/2, 150);
                inGameLeaderboardContext.fillText('KILLS', inGameLeaderboardCanvas.width - 200, 150);
                inGameLeaderboardContext.fillText('DEATHS', inGameLeaderboardCanvas.width - 80, 150);
                
                // Divider line
                inGameLeaderboardContext.strokeStyle = '#FFFFFF';
                inGameLeaderboardContext.lineWidth = 2;
                inGameLeaderboardContext.beginPath();
                inGameLeaderboardContext.moveTo(50, 170);
                inGameLeaderboardContext.lineTo(inGameLeaderboardCanvas.width - 50, 170);
                inGameLeaderboardContext.stroke();
                
                // Get all players (including self)
                const allPlayers = [];
                
                // Add self to the list
                if (selfPlaneId) {
                    allPlayers.push({
                        planeId: selfPlaneId,
                        username: selfUsername || 'You',
                        kills: killCount || 0,
                        deaths: deathCount || 0
                    });
                }
                
                // Add other players
                if (otherPlayers && otherPlayers.size > 0) {
                    otherPlayers.forEach((playerData, planeId) => {
                        if (playerData && playerData.username) {
                            allPlayers.push({
                                planeId: planeId,
                                username: playerData.username,
                                kills: playerData.kills || 0,
                                deaths: playerData.deaths || 0
                            });
                        }
                    });
                }
                
                // Sort players by kills (descending)
                allPlayers.sort((a, b) => b.kills - a.kills);
                
                // Assign ranks
                allPlayers.forEach((player, index) => {
                    player.rank = index + 1;
                });
                
                // Draw player entries (top 10 only)
                inGameLeaderboardContext.font = '36px system-ui';
                const rowHeight = 55;
                const startY = 220;
                
                // Take only top 10 players
                const topPlayers = allPlayers.slice(0, 10);
                
                topPlayers.forEach((player, index) => {
                    const y = startY + (index * rowHeight);
                    
                    // Highlight self
                    if (player.planeId === selfPlaneId) {
                        // Draw highlight background
                        inGameLeaderboardContext.fillStyle = 'rgba(0, 255, 0, 0.2)';
                        inGameLeaderboardContext.fillRect(50, y - 36, inGameLeaderboardCanvas.width - 100, rowHeight);
                    }
                    
                    // Highlight top 3 players with gold, silver, bronze
                    if (index === 0) inGameLeaderboardContext.fillStyle = '#FFD700'; // Gold
                    else if (index === 1) inGameLeaderboardContext.fillStyle = '#C0C0C0'; // Silver
                    else if (index === 2) inGameLeaderboardContext.fillStyle = '#CD7F32'; // Bronze
                    else inGameLeaderboardContext.fillStyle = '#FFFFFF'; // White
                    
                    // If it's self, make it brighter
                    if (player.planeId === selfPlaneId) {
                        inGameLeaderboardContext.fillStyle = '#00FF00'; // Bright green
                    }
                    
                    inGameLeaderboardContext.textAlign = 'center';
                    inGameLeaderboardContext.fillText(player.rank, 100, y);
                    
                    // Truncate long usernames
                    let displayName = player.username;
                    if (displayName.length > 15) {
                        displayName = displayName.substring(0, 12) + '...';
                    }
                    
                    inGameLeaderboardContext.fillText(displayName, inGameLeaderboardCanvas.width/2, y);
                    inGameLeaderboardContext.fillText(player.kills, inGameLeaderboardCanvas.width - 200, y);
                    inGameLeaderboardContext.fillText(player.deaths, inGameLeaderboardCanvas.width - 80, y);
                });
                
                // Add timestamp
                inGameLeaderboardContext.fillStyle = '#FFFFFF';
                inGameLeaderboardContext.font = '24px system-ui';
                inGameLeaderboardContext.textAlign = 'right';
                inGameLeaderboardContext.fillText('Updated: ' + new Date().toLocaleTimeString(), inGameLeaderboardCanvas.width - 50, inGameLeaderboardCanvas.height - 15);
                
                // Update the texture
                inGameLeaderboardTexture.needsUpdate = true;
            }

            // Initial update
            updateLeaderboard();

            // Also update periodically in case we miss some updates
            setInterval(updateLeaderboard, 10000); // Update every 10 seconds
            */
        // </leaderboard in-game>


        
        
        // <mailbox - mailtrap.com>
            // Create mailbox group
            const mailboxGroup = new THREE.Group();

            // Create pole
            const mailboxPoleGeometry = new THREE.CylinderGeometry(0.4, 0.4, 16, 8); // 4x dimensions
            const mailboxPoleMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 }); // Gray
            const mailboxPole = new THREE.Mesh(mailboxPoleGeometry, mailboxPoleMaterial);
            mailboxPole.position.y = 8; // Half height to place bottom at ground
            mailboxGroup.add(mailboxPole);

            // Create mailbox
            const mailboxGeometry = new THREE.BoxGeometry(8, 4, 4); // 4x dimensions
            const mailboxMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000 }); // Red
            const mailboxBox = new THREE.Mesh(mailboxGeometry, mailboxMaterial);
            mailboxBox.position.y = 14; // Doubled from 7
            mailboxGroup.add(mailboxBox);

            // Create text texture
            const mailboxCanvas = document.createElement('canvas');
            const mailboxContext = mailboxCanvas.getContext('2d');
            mailboxCanvas.width = 1024; // Doubled resolution
            mailboxCanvas.height = 256; // Doubled resolution

            // White background
            mailboxContext.fillStyle = '#FF0000';
            mailboxContext.fillRect(0, 0, mailboxCanvas.width, mailboxCanvas.height);

            // Black text
            mailboxContext.fillStyle = 'white';
            mailboxContext.font = 'bold 120px system-ui'; // Doubled font size
            mailboxContext.textAlign = 'center';
            mailboxContext.textBaseline = 'middle';
            mailboxContext.fillText('MAILTRAP.IO', mailboxCanvas.width/2, mailboxCanvas.height/2);

            const mailboxTexture = new THREE.CanvasTexture(mailboxCanvas);

            // Create text plane
            const mailboxTextGeometry = new THREE.PlaneGeometry(7.2, 1.8); // 4x dimensions
            const mailboxTextMaterial = new THREE.MeshBasicMaterial({ 
                map: mailboxTexture,
                side: THREE.DoubleSide
            });
            const mailboxTextMesh = new THREE.Mesh(mailboxTextGeometry, mailboxTextMaterial);
            mailboxTextMesh.position.y = 14; // Doubled from 7
            mailboxTextMesh.position.z = 2.04; // Doubled from 1.02
            mailboxGroup.add(mailboxTextMesh);

            // Create check sign
            const checkSignGeometry = new THREE.BoxGeometry(2, 2, 0.4); // 4x dimensions
            const checkSignMaterial = new THREE.MeshPhongMaterial({ color: 0xFF0000 }); // Red
            const checkSign = new THREE.Mesh(checkSignGeometry, checkSignMaterial);
            checkSign.position.y = 16.8; // Doubled from 8.4
            checkSign.position.z = 2.04; // Doubled from 1.02
            checkSign.position.x = -2; // Doubled from -1
            checkSign.visible = true;
            mailboxGroup.add(checkSign);

            // Position entire mailbox group next to runway
            mailboxGroup.position.set(12, 0, -90); // Doubled position
            scene.add(mailboxGroup);
        // </mailbox - mailtrap.com>


        // <hot air balloon - freelancer.com>
            // Create hot air balloon with Freelancer.com text
            const hotAirBalloonGroup = new THREE.Group();
            
            // Create balloon texture with text
            const balloonCanvas = document.createElement('canvas');
            const balloonContext = balloonCanvas.getContext('2d');
            balloonCanvas.width = 1024; // Increased resolution
            balloonCanvas.height = 512; // Increased resolution

            // Pink background
            balloonContext.fillStyle = '#FF69B4';
            balloonContext.fillRect(0, 0, balloonCanvas.width, balloonCanvas.height);

            // White text with larger font size and anti-aliasing
            balloonContext.imageSmoothingEnabled = true;
            balloonContext.imageSmoothingQuality = 'high';
            balloonContext.font = 'bold 24px system-ui'; // Increased font size
            balloonContext.fillStyle = 'white';
            balloonContext.textAlign = 'center';
            balloonContext.textBaseline = 'middle';
            
            // Add stroke to make text sharper
            balloonContext.strokeStyle = 'rgba(0,0,0,0.3)';
            balloonContext.lineWidth = 2;
            
            // Draw multiple lines of text
            const lines = 10;
            const lineHeight = 40;
            const startY = balloonCanvas.height/2 - (lineHeight * (lines-1))/2;
            
            for(let i = 0; i < lines; i++) {
                const y = startY + (i * lineHeight);
                balloonContext.fillText('FREELANCER.COM FREELANCER.COM FREELANCER.COM', balloonCanvas.width/2, y);
            }

            const balloonTexture = new THREE.CanvasTexture(balloonCanvas);

            // Create balloon shape - 1.5x bigger
            const balloonGeometry = new THREE.SphereGeometry(12, 32, 32); // Increased from 8 to 12
            const balloonMaterial = new THREE.MeshPhongMaterial({
                map: balloonTexture,
                shininess: 10
            });
            const hotAirBalloon = new THREE.Mesh(balloonGeometry, balloonMaterial);
            hotAirBalloonGroup.add(hotAirBalloon);

            // Create basket - 1.5x bigger
            const basketGeometry = new THREE.BoxGeometry(4.5, 4.5, 4.5); // Increased from 3 to 4.5
            const basketMaterial = new THREE.MeshPhongMaterial({color: 0x8B4513});
            const basket = new THREE.Mesh(basketGeometry, basketMaterial);
            basket.position.y = -18; // Increased from -12 to -18 to maintain proportions
            hotAirBalloonGroup.add(basket);

            // Create ropes connecting balloon to basket - adjusted for larger size
            const ropePositions = [
                [-2, 0, -2], 
                [2, 0, -2],
                [-2, 0, 2],
                [2, 0, 2]
            ];

            ropePositions.forEach(pos => {
                const ropeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 12, 8); // Increased thickness and length
                const ropeMaterial = new THREE.MeshPhongMaterial({color: 0x8B4513});
                const rope = new THREE.Mesh(ropeGeometry, ropeMaterial);
                rope.position.set(pos[0], -12, pos[2]); // Adjusted Y position
                hotAirBalloonGroup.add(rope);
            });

            // Position the balloon in the scene
            hotAirBalloonGroup.position.set(-600, 100, -100);
            hotAirBalloonGroup.rotation.y=-0.5;


            scene.add(hotAirBalloonGroup);

            // Animation function for gentle floating motion
            function animateHotAirBalloon() {
                if (hotAirBalloonGroup) {
                    const time = Date.now() * 0.001;
                    hotAirBalloonGroup.position.y += Math.sin(time) * 0.05;
                    hotAirBalloonGroup.rotation.y += 0.001;
                }
            }
        // </hot air balloon - freelancer.com>

        // <hot air balloon - quso.ai>
            // Create hot air balloon with 
            const hotAirBalloon2Group = new THREE.Group();

            // Create balloon texture with text
            const hotAirBalloon2Canvas = document.createElement('canvas');
            const hotAirBalloon2Context = hotAirBalloon2Canvas.getContext('2d');
            hotAirBalloon2Canvas.width = 1024; // Increased resolution
            hotAirBalloon2Canvas.height = 512; // Increased resolution
            // Yellow background
            hotAirBalloon2Context.fillStyle = '#FFFF00';
            hotAirBalloon2Context.fillRect(0, 0, hotAirBalloon2Canvas.width, hotAirBalloon2Canvas.height);

            // White text with larger font size and anti-aliasing
            hotAirBalloon2Context.imageSmoothingEnabled = true;
            hotAirBalloon2Context.imageSmoothingQuality = 'high';
            hotAirBalloon2Context.font = 'bold 48px system-ui'; // Increased font size
            hotAirBalloon2Context.fillStyle = '#000000';
            hotAirBalloon2Context.textAlign = 'center';
            hotAirBalloon2Context.textBaseline = 'middle';

            // Add stroke to make text sharper
            hotAirBalloon2Context.strokeStyle = 'rgba(0,0,0,0.3)';
            hotAirBalloon2Context.lineWidth = 2;

            // Draw centered text lines
            const centerY = hotAirBalloon2Canvas.height / 2;
            hotAirBalloon2Context.fillText('QUSO.AI', hotAirBalloon2Canvas.width/2, centerY - 60);
            hotAirBalloon2Context.fillText('FOR YOUR', hotAirBalloon2Canvas.width/2, centerY);
            hotAirBalloon2Context.fillText('SOCIAL MEDIA', hotAirBalloon2Canvas.width/2, centerY + 60);

            const hotAirBalloon2Texture = new THREE.CanvasTexture(hotAirBalloon2Canvas);

            // Create balloon shape - 1.5x bigger
            const hotAirBalloon2Geometry = new THREE.SphereGeometry(12, 32, 32); // Increased from 8 to 12
            const hotAirBalloon2Material = new THREE.MeshPhongMaterial({
                map: hotAirBalloon2Texture,
                shininess: 10
            });
            
            const hotAirBalloon2 = new THREE.Mesh(hotAirBalloon2Geometry, hotAirBalloon2Material);
            hotAirBalloon2Group.add(hotAirBalloon2);

            // Create basket - 1.5x bigger
            const hotAirBalloon2BasketGeometry = new THREE.BoxGeometry(4.5, 4.5, 4.5); // Increased from 3 to 4.5
            const hotAirBalloon2BasketMaterial = new THREE.MeshPhongMaterial({color: 0x8B4513});
            const hotAirBalloon2Basket = new THREE.Mesh(hotAirBalloon2BasketGeometry, hotAirBalloon2BasketMaterial);
            hotAirBalloon2Basket.position.y = -18; // Increased from -12 to -18 to maintain proportions
            hotAirBalloon2Group.add(hotAirBalloon2Basket);

            // Create ropes connecting balloon to basket - adjusted for larger size
            const hotAirBalloon2RopePositions = [
                [-2, 0, -2], 
                [2, 0, -2],
                [-2, 0, 2],
                [2, 0, 2]
            ];

            hotAirBalloon2RopePositions.forEach(pos => {
                const hotAirBalloon2RopeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 12, 8); // Increased thickness and length
                const hotAirBalloon2RopeMaterial = new THREE.MeshPhongMaterial({color: 0x8B4513});
                const hotAirBalloon2Rope = new THREE.Mesh(hotAirBalloon2RopeGeometry, hotAirBalloon2RopeMaterial);
                hotAirBalloon2Rope.position.set(pos[0], -12, pos[2]); // Adjusted Y position
                hotAirBalloon2Group.add(hotAirBalloon2Rope);
            });

            // Position the balloon in the scene
            hotAirBalloon2Group.position.set(-400, 100, -100);
            hotAirBalloon2Group.rotation.y=3.5;

            scene.add(hotAirBalloon2Group);

            // Animation function for gentle floating motion
            function animateHotAirBalloon2() {
                if (hotAirBalloon2Group) {
                    const time = Date.now() * 0.001;
                    hotAirBalloon2Group.position.y += Math.sin(time) * 0.05;
                    hotAirBalloon2Group.rotation.y += 0.001;
                }
            }
        // </hot air balloon - quso.ai>

        // <prison on the beach - pmfordie.com>
            // Create prison group
            const prisonGroup = new THREE.Group();
            
            // Create prison floor
            const prisonFloorGeometry = new THREE.BoxGeometry(6, 0.5, 4);
            const prisonFloorMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 }); // Gray concrete
            const prisonFloor = new THREE.Mesh(prisonFloorGeometry, prisonFloorMaterial);
            prisonGroup.add(prisonFloor);
            
            // Create prison roof
            const prisonRoofGeometry = new THREE.BoxGeometry(6, 0.5, 4);
            const prisonRoofMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 }); // Gray concrete
            const prisonRoof = new THREE.Mesh(prisonRoofGeometry, prisonRoofMaterial);
            prisonRoof.position.y = 4; // Position roof 4 meters above floor
            prisonGroup.add(prisonRoof);
            
            // Create prison bars
            const prisonBarGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 8);
            const prisonBarMaterial = new THREE.MeshPhongMaterial({ color: 0x444444, metalness: 0.8 }); // Steel bars
            
            // Create vertical bars around the perimeter
            const prisonBarCount = 20; // Number of bars
            const prisonBarSpacing = 0.4; // Space between bars
            
            // Front side bars
            for (let i = 0; i < 15; i++) {
                const prisonBar = new THREE.Mesh(prisonBarGeometry, prisonBarMaterial);
                prisonBar.position.set(-2.5 + i * prisonBarSpacing, 2, 2); // Front side
                prisonGroup.add(prisonBar);
            }
            
            // Back side bars
            for (let i = 0; i < 15; i++) {
                const prisonBar = new THREE.Mesh(prisonBarGeometry, prisonBarMaterial);
                prisonBar.position.set(-2.5 + i * prisonBarSpacing, 2, -2); // Back side
                prisonGroup.add(prisonBar);
            }
            
            // Left side bars
            for (let i = 0; i < 10; i++) {
                const prisonBar = new THREE.Mesh(prisonBarGeometry, prisonBarMaterial);
                prisonBar.position.set(-3, 2, -1.5 + i * prisonBarSpacing); // Left side
                prisonGroup.add(prisonBar);
            }
            
            // Right side bars
            for (let i = 0; i < 10; i++) {
                const prisonBar = new THREE.Mesh(prisonBarGeometry, prisonBarMaterial);
                prisonBar.position.set(3, 2, -1.5 + i * prisonBarSpacing); // Right side
                prisonGroup.add(prisonBar);
            }
            
            // Create horizontal bars (top and bottom)
            const prisonHorizontalBarGeometry = new THREE.CylinderGeometry(0.05, 0.05, 6, 8);
            prisonHorizontalBarGeometry.rotateZ(Math.PI / 2);
            
            // Front side horizontal bars
            const prisonFrontTopBar = new THREE.Mesh(prisonHorizontalBarGeometry, prisonBarMaterial);
            prisonFrontTopBar.position.set(0, 3.8, 2);
            prisonGroup.add(prisonFrontTopBar);
            
            const prisonFrontBottomBar = new THREE.Mesh(prisonHorizontalBarGeometry, prisonBarMaterial);
            prisonFrontBottomBar.position.set(0, 0.2, 2);
            prisonGroup.add(prisonFrontBottomBar);
            
            // Back side horizontal bars
            const prisonBackTopBar = new THREE.Mesh(prisonHorizontalBarGeometry, prisonBarMaterial);
            prisonBackTopBar.position.set(0, 3.8, -2);
            prisonGroup.add(prisonBackTopBar);
            
            const prisonBackBottomBar = new THREE.Mesh(prisonHorizontalBarGeometry, prisonBarMaterial);
            prisonBackBottomBar.position.set(0, 0.2, -2);
            prisonGroup.add(prisonBackBottomBar);
            
            // Create pmfordie.com banner
            const prisonBannerCanvas = document.createElement('canvas');
            const prisonBannerContext = prisonBannerCanvas.getContext('2d');
            prisonBannerCanvas.width = 512;
            prisonBannerCanvas.height = 128;
            
            // Set banner background
            prisonBannerContext.fillStyle = '#FF4500'; // Orange-red background
            prisonBannerContext.fillRect(0, 0, prisonBannerCanvas.width, prisonBannerCanvas.height);
            
            // Add text
            prisonBannerContext.font = 'bold 60px system-ui';
            prisonBannerContext.textAlign = 'center';
            prisonBannerContext.textBaseline = 'middle';
            prisonBannerContext.fillStyle = 'white';
            prisonBannerContext.fillText('PMFORDIE.COM', prisonBannerCanvas.width / 2, prisonBannerCanvas.height / 2);
            
            const prisonBannerTexture = new THREE.CanvasTexture(prisonBannerCanvas);
            const prisonBannerMaterial = new THREE.MeshBasicMaterial({
                map: prisonBannerTexture,
                transparent: true,
                side: THREE.DoubleSide,
                fog: false
            });
            
            const prisonBannerGeometry = new THREE.PlaneGeometry(7, 1.5);
            const prisonBanner = new THREE.Mesh(prisonBannerGeometry, prisonBannerMaterial);
            prisonBanner.position.y = 5; // Position above the prison
            prisonBanner.rotation.x = Math.PI / 12; // Slight tilt
            prisonGroup.add(prisonBanner);
            
            // Position the prison on the beach
            prisonGroup.position.set(-400,35, -150);
            
            
            scene.add(prisonGroup);
            
        // </prison on the beach - pmfordie.com>



        // <robot on land - lindy.ai>
            // Create a floating robot for lindy.ai
            const robotGroup = new THREE.Group();
            
            // Robot body
            const bodyGeometry = new THREE.BoxGeometry(10, 14, 6);
            const bodyMaterial = new THREE.MeshPhongMaterial({
                color: 0x3498db, // Blue color
                shininess: 70,
                fog: false
            });
            const robotBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            robotGroup.add(robotBody);
            
            // Robot head
            const headGeometry = new THREE.BoxGeometry(8, 6, 6);
            const headMaterial = new THREE.MeshPhongMaterial({
                color: 0x2980b9, // Darker blue
                shininess: 70,
                fog: false
            });
            const robotHead = new THREE.Mesh(headGeometry, headMaterial);
            robotHead.position.y = 10; // Position on top of body
            robotGroup.add(robotHead);
            
            // Robot eyes
            const eyeGeometry = new THREE.SphereGeometry(1, 16, 16);
            const eyeMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000, // Red eyes
                emissive: 0xff0000,
                emissiveIntensity: 0.5,
                fog: false
            });
            
            // Left eye
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-2, 10, 3);
            robotGroup.add(leftEye);
            
            // Right eye
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(2, 10, 3);
            robotGroup.add(rightEye);
            
            // Robot arms
            const armGeometry = new THREE.BoxGeometry(2, 8, 2);
            const armMaterial = new THREE.MeshPhongMaterial({
                color: 0x3498db,
                shininess: 70,
                fog: false
            });
            
            // Left arm
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-6, 0, 0);
            robotGroup.add(leftArm);
            
            // Right arm
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(6, 0, 0);
            robotGroup.add(rightArm);
            
            // Robot legs
            const legGeometry = new THREE.BoxGeometry(3, 8, 3);
            const legMaterial = new THREE.MeshPhongMaterial({
                color: 0x2980b9,
                shininess: 70,
                fog: false
            });
            
            // Left leg
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-3, -11, 0);
            robotGroup.add(leftLeg);
            
            // Right leg
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(3, -11, 0);
            robotGroup.add(rightLeg);
            
            // Create LINDY.AI banner
            const lindyBannerCanvas = document.createElement('canvas');
            const lindyBannerContext = lindyBannerCanvas.getContext('2d');
            lindyBannerCanvas.width = 512;
            lindyBannerCanvas.height = 128;
            
            // Set banner background
            lindyBannerContext.fillStyle = '#2980b9'; // Blue background
            lindyBannerContext.fillRect(0, 0, lindyBannerCanvas.width, lindyBannerCanvas.height);
            
            // Add text
            lindyBannerContext.font = 'bold 60px system-ui';
            lindyBannerContext.textAlign = 'center';
            lindyBannerContext.textBaseline = 'middle';
            lindyBannerContext.fillStyle = 'white';
            lindyBannerContext.fillText('LINDY.AI', lindyBannerCanvas.width / 2, lindyBannerCanvas.height / 2);
            
            const lindyBannerTexture = new THREE.CanvasTexture(lindyBannerCanvas);
            const lindyBannerMaterial = new THREE.MeshBasicMaterial({
                map: lindyBannerTexture,
                transparent: true,
                side: THREE.DoubleSide,
                fog: false
            });
            
            const lindyBannerGeometry = new THREE.PlaneGeometry(16, 4);
            const lindyBanner = new THREE.Mesh(lindyBannerGeometry, lindyBannerMaterial);
            lindyBanner.position.y = 18; // Position above the robot
            robotGroup.add(lindyBanner);
            
            // Position the robot in the sky
            robotGroup.position.set(-100, 50, -200);
            robotGroup.rotation.y = 1.5;
            
            scene.add(robotGroup);
            
        // </robot on land - lindy.ai>


        // <ufo - basecamp.com>
            // Create UFO with Basecamp logo
            const ufoGroup = new THREE.Group();
            
            // Create the main UFO body (saucer shape)
            const ufoBodyGeometry = new THREE.SphereGeometry(10, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            
            // Load Basecamp logo texture for the UFO body
            const ufoTextureLoader = new THREE.TextureLoader();
            const ufoTexture = ufoTextureLoader.load('/assets/fly_basecamp.png');
            
            // Configure texture to repeat in a pattern
            ufoTexture.wrapS = THREE.RepeatWrapping;
            ufoTexture.wrapT = THREE.RepeatWrapping;
            ufoTexture.repeat.set(5, 4);
            
            const ufoBodyMaterial = new THREE.MeshPhongMaterial({
                map: ufoTexture,
                color: 0xC0C0C0, // Silver/metallic color
                shininess: 80,
                fog: false
            });
            
            const ufoBody = new THREE.Mesh(ufoBodyGeometry, ufoBodyMaterial);
            ufoBody.scale.y = 0.3; // Flatten the sphere to make it saucer-like
            ufoGroup.add(ufoBody);
            // Create the bottom part of the UFO with the same texture
            const ufoBottomGeometry = new THREE.SphereGeometry(7, 32, 16, 0, Math.PI * 2, Math.PI / 2, Math.PI / 4);
            const ufoBottomMaterial = new THREE.MeshPhongMaterial({
                // map: ufoTexture,
                color: 0xC0C0C0, // Silver/metallic color
                shininess: 60,
                fog: false
            });
            const ufoBottom = new THREE.Mesh(ufoBottomGeometry, ufoBottomMaterial);
            ufoBottom.position.y = 0;;
            ufoBottom.scale.y = 0.5;
            ufoGroup.add(ufoBottom);
            


            // Create the cockpit/dome on top of the UFO
            const ufoCockpitGeometry = new THREE.SphereGeometry(4, 32, 32);

            // Load the globe texture for the cockpit
            const ufoGlobeTextureLoader = new THREE.TextureLoader();
            const ufoGlobeTexture = ufoGlobeTextureLoader.load('/assets/fly_basecamp_globe.png?3');

            // Configure the texture to wrap properly around the sphere
            ufoGlobeTexture.wrapS = THREE.RepeatWrapping;
            ufoGlobeTexture.wrapT = THREE.ClampToEdgeWrapping; // Clamp vertical to avoid stretching at poles
            ufoGlobeTexture.repeat.set(2, 1);

            const ufoCockpitMaterial = new THREE.MeshPhongMaterial({
                map: ufoGlobeTexture,
                transparent: true,
                opacity: 0.9, // Slightly transparent for a glass-like effect
                shininess: 100,
                fog: false
            });

            const ufoCockpit = new THREE.Mesh(ufoCockpitGeometry, ufoCockpitMaterial);
            ufoGroup.add(ufoCockpit);

            
            ufoCockpit.rotation.y=0.1;
            ufoCockpit.position.y=3;
            
            
            // Add a top plate for the main disc's bottom side
            const ufoTopBottomPlateGeometry = new THREE.CircleGeometry(10, 32);
            const ufoTopBottomPlateMaterial = new THREE.MeshPhongMaterial({
                // map: ufoTexture,
                color: 0xC0C0C0, // Silver/metallic color
                shininess: 60,
                side: THREE.DoubleSide,
                fog: false
            });
            const ufoTopBottomPlate = new THREE.Mesh(ufoTopBottomPlateGeometry, ufoTopBottomPlateMaterial);
            ufoTopBottomPlate.position.y = 0;
            ufoTopBottomPlate.rotation.x = Math.PI / 2; // Make it horizontal
            ufoGroup.add(ufoTopBottomPlate);
            
            // Create lights under the UFO
            const ufoLightPositions = [
                [5, -2, 0], [-5, -2, 0], [0, -2, 5], [0, -2, -5]
            ];
            
            ufoLightPositions.forEach(pos => {
                const ufoLightGeometry = new THREE.SphereGeometry(0.8, 16, 16);
                const ufoLightMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF, // Cyan color
                    fog: false
                });
                const ufoLight = new THREE.Mesh(ufoLightGeometry, ufoLightMaterial);
                ufoLight.position.set(pos[0], pos[1], pos[2]);
                ufoGroup.add(ufoLight);
            });
            
            // Position the UFO in the scene
            // ufoGroup.position.set(0, 50, 0);
            ufoGroup.position.set(0, 40, 70);
            
            
            scene.add(ufoGroup);
            
            // Create UFO sound (LFO style)
            let ufoOscillator;
            let ufoLFO;
            let ufoGain;
            
            function createUFOSound() {
                if (!window.audioContext) return;
                // disable
                return;
                
                // Create oscillator for the main tone
                ufoOscillator = window.audioContext.createOscillator();
                ufoOscillator.type = 'sine';
                ufoOscillator.frequency.value = 120; // Base frequency
                
                // Create LFO to modulate the frequency
                ufoLFO = window.audioContext.createOscillator();
                ufoLFO.type = 'sine';
                ufoLFO.frequency.value = 0.2; // Slow modulation
                
                // Create gain nodes
                ufoGain = window.audioContext.createGain();
                ufoGain.gain.value = 0.075; // Low volume (reduced by 50%)
                
                const ufoLfoGain = window.audioContext.createGain();
                ufoLfoGain.gain.value = 40; // Modulation depth
                
                // Connect LFO to oscillator frequency
                ufoLFO.connect(ufoLfoGain);
                ufoLfoGain.connect(ufoOscillator.frequency);
                
                // Connect oscillator to output
                ufoOscillator.connect(ufoGain);
                ufoGain.connect(window.audioContext.destination);
                
                // Start oscillators
                ufoOscillator.start();
                ufoLFO.start();
            }
            
            function updateUFOSound() {
                if (!ufoGain || !ufoOscillator) return;
                
                // Calculate distance from camera to UFO
                const ufoDistanceToUFO = camera.position.distanceTo(ufoGroup.position);
                
                // Adjust volume based on distance (louder when closer)
                const ufoMaxDistance = 300;
                if (ufoDistanceToUFO < ufoMaxDistance) {
                    // Linear falloff with distance
                    const ufoVolume = 0.05 * (1 - ufoDistanceToUFO / ufoMaxDistance);
                    ufoGain.gain.setTargetAtTime(ufoVolume, window.audioContext.currentTime, 0.1);
                    
                    // Adjust frequency based on UFO movement
                    const ufoBaseFreq = 120;
                    const ufoHeightVariation = (ufoGroup.position.y - 75) / 10; // -1 to 1 range
                    ufoOscillator.frequency.setTargetAtTime(
                        ufoBaseFreq + (ufoHeightVariation * 20), 
                        window.audioContext.currentTime, 
                        0.1
                    );
                } else {
                    // Too far away, mute the sound
                    ufoGain.gain.setTargetAtTime(0, window.audioContext.currentTime, 0.1);
                }
            }
            
            // Animation for the UFO
            const ufoAnimation = () => {
                const ufoTime = Date.now() * 0.001;
                
                // Circular flight pattern closer to runway (0,0)
                ufoGroup.position.x = 0 + Math.sin(ufoTime * 0.2) * 100;
                ufoGroup.position.z = -70 + Math.cos(ufoTime * 0.2) * 100;
                
                // Lower flying height between 50-100
                ufoGroup.position.y = 100 + Math.sin(ufoTime * 0.5) * 10;
                
                // Slight tilting in the direction of movement
                ufoGroup.rotation.z = Math.sin(ufoTime * 0.2) * 0.1;
                ufoGroup.rotation.x = Math.cos(ufoTime * 0.2) * 0.1;
                
                // Update UFO sound based on position
                updateUFOSound();
                
                requestAnimationFrame(ufoAnimation);
            };
            
            // Initialize UFO sound when audio context is available
            document.addEventListener('click', function initUFOSound() {
                if (window.audioContext && !ufoOscillator) {
                    createUFOSound();
                    document.removeEventListener('click', initUFOSound);
                }
            }, { once: false });
            
            ufoAnimation();
        // </ufo - basecamp.com>


        // <hot air balloon - atlantic records>
            // Create hot air balloon with Atlantic Records logo
            const hotAirBalloon3Group = new THREE.Group();

            // Create balloon using Atlantic Records texture
            const hotAirBalloon3Geometry = new THREE.SphereGeometry(12, 32, 32);
            const hotAirBalloon3TextureLoader = new THREE.TextureLoader();
            const hotAirBalloon3Texture = hotAirBalloon3TextureLoader.load('/assets/fly_atlantic_records.png?3');
            
            // Configure texture to repeat and avoid stretching
            hotAirBalloon3Texture.wrapS = THREE.RepeatWrapping;
            hotAirBalloon3Texture.wrapT = THREE.RepeatWrapping;
            hotAirBalloon3Texture.repeat.set(5, 3);
            
            const hotAirBalloon3Material = new THREE.MeshPhongMaterial({
                map: hotAirBalloon3Texture,
                shininess: 10,
                fog: false
            });

            const hotAirBalloon3 = new THREE.Mesh(hotAirBalloon3Geometry, hotAirBalloon3Material);
            hotAirBalloon3Group.add(hotAirBalloon3);

            // Create basket - 1.5x bigger
            const hotAirBalloon3BasketGeometry = new THREE.BoxGeometry(4.5, 4.5, 4.5); // Increased from 3 to 4.5
            const hotAirBalloon3BasketMaterial = new THREE.MeshPhongMaterial({color: 0x8B4513});
            const hotAirBalloon3Basket = new THREE.Mesh(hotAirBalloon3BasketGeometry, hotAirBalloon3BasketMaterial);
            hotAirBalloon3Basket.position.y = -18; // Increased from -12 to -18 to maintain proportions
            hotAirBalloon3Group.add(hotAirBalloon3Basket);

            // Create ropes connecting balloon to basket - adjusted for larger size
            const hotAirBalloon3RopePositions = [
                [-2, 0, -2], 
                [2, 0, -2],
                [-2, 0, 2],
                [2, 0, 2]
            ];

            hotAirBalloon3RopePositions.forEach(pos => {
                const hotAirBalloon3RopeGeometry = new THREE.CylinderGeometry(0.15, 0.15, 12, 8); // Increased thickness and length
                const hotAirBalloon3RopeMaterial = new THREE.MeshPhongMaterial({color: 0x8B4513});
                const hotAirBalloon3Rope = new THREE.Mesh(hotAirBalloon3RopeGeometry, hotAirBalloon3RopeMaterial);
                hotAirBalloon3Rope.position.set(pos[0], -12, pos[2]); // Adjusted Y position
                hotAirBalloon3Group.add(hotAirBalloon3Rope);
            });

            // Position the balloon in the scene
            hotAirBalloon3Group.position.set(-50, 90, 0);

            hotAirBalloon3Group.rotation.y=3.5;

            scene.add(hotAirBalloon3Group);

            // Animation function for gentle floating motion
            function animatehotAirBalloon3() {
                if (hotAirBalloon3Group) {
                    const time = Date.now() * 0.001;
                    hotAirBalloon3Group.position.y += Math.sin(time) * 0.05;
                    hotAirBalloon3Group.rotation.y += 0.001;
                }
            }
        // </hot air balloon - atlantic records>




        // <mars>
            // Add after other scene setup code, before the animation loop
            // Create mars (now Mars)
            const marsTextureLoader = new THREE.TextureLoader();
            const marsGeometry = new THREE.SphereGeometry(500, 32, 16);
            marsMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0, // Start invisible
                fog: false  // Make mars ignore scene fog
            });

            // Increase the base color brightness
            marsMaterial.color.multiplyScalar(1.5); // Makes the base color twice as bright

            // Changed texture URL to Mars texture
            marsTextureLoader.load('/assets/fly_mars.jpg', (texture) => {
                // Flip the texture horizontally
                texture.repeat.x = -1;
                texture.offset.x = 1;
                marsMaterial.map = texture;
                marsMaterial.needsUpdate = true;
            });

            const mars = new THREE.Mesh(marsGeometry, marsMaterial);
            mars.position.set(5000, 5000, -7000);
            // Rotate the mars to show the desired side
            mars.rotation.y = Math.PI;
            scene.add(mars);


            // <ad on mars>
                // Advertisement banner on Mars
                const createMarsTextTexture = () => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 128;
                    
                    // Background
                    context.fillStyle = '#000000'; // Black background
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Text
                    context.font = 'bold 48px system-ui';
                    context.fillStyle = 'white';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText('TRYCOMP.AI', canvas.width / 2, canvas.height / 2);
                    
                    return new THREE.CanvasTexture(canvas);
                };

                // Create banner with the text
                const marsBannerGeometry = new THREE.PlaneGeometry(800, 200);
                const marsBannerMaterial = new THREE.MeshBasicMaterial({ 
                    map: createMarsTextTexture(),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8,
                    fog:false
                });
                const marsBanner = new THREE.Mesh(marsBannerGeometry, marsBannerMaterial);
                
                // Position banner on Mars surface
                // mars.position.set(5000, 5000, -7000);
                marsBanner.position.set(4600, 4600, -6450); 
                marsBanner.lookAt(0, 50, 0); // Make banner face towards runway
                scene.add(marsBanner);
            // </ad on mars>
        // </mars>

            
        // <nomaddial iphone billboard>
            const iphoneBillboardGeometry = new THREE.PlaneGeometry(10, 20);
            const iphoneBillboardTexture = new THREE.TextureLoader().load('/assets/fly_nomaddial.webp?3');
            const iphoneBillboardMaterial = new THREE.MeshBasicMaterial({
                map: iphoneBillboardTexture,
                side: THREE.DoubleSide,
                transparent: true,
                fog: false,
                alphaTest: 0.5 // Add alphaTest to handle transparency properly
            });
            const iphoneBillboard = new THREE.Mesh(iphoneBillboardGeometry, iphoneBillboardMaterial);

            // Create poles to hold the billboard
            const iphoneBillboardPoleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 40);
            const iphoneBillboardPoleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                fog: false
            });

            // Create two poles
            const iphoneBillboardPoleLeft = new THREE.Mesh(iphoneBillboardPoleGeometry, iphoneBillboardPoleMaterial);
            const iphoneBillboardPoleRight = new THREE.Mesh(iphoneBillboardPoleGeometry, iphoneBillboardPoleMaterial);

            // Position billboard in front of runway
            iphoneBillboard.position.set(-75, 125, -60);
            iphoneBillboard.rotation.y = 0.75;
            iphoneBillboard.rotation.z = 0.15;

            // Add floating animation to iPhone billboard
            function animateIphoneBillboard() {
                const time = performance.now() * 0.001; // Convert to seconds
                const floatAmplitude = 2; // How high it floats
                const floatSpeed = 1.5; // Speed of floating motion
                
                // Create smooth floating motion using sine wave
                iphoneBillboard.position.y = 100 + floatAmplitude * Math.sin(time * floatSpeed);
                requestAnimationFrame(animateIphoneBillboard);
            }

            // Position poles relative to billboard
            iphoneBillboardPoleLeft.position.set(-22, 23, -34);
            iphoneBillboardPoleRight.position.set(-8, 23, -47);
            iphoneBillboardPoleLeft.rotation.y = 0.75;
            iphoneBillboardPoleRight.rotation.y = 0.75;

            scene.add(iphoneBillboard);
            scene.add(iphoneBillboardPoleLeft);
            scene.add(iphoneBillboardPoleRight);
        // </nomaddial iphone billboard>


        
        // <lambda chat billboard>
            // Create billboard geometry with 1600:500 ratio
            const shapedBillboardGeometry = new THREE.PlaneGeometry(20, 20);
            const shapedBillboardTexture = new THREE.TextureLoader().load('/assets/fly_lambdachat.png?3');
            const shapedBillboardMaterial = new THREE.MeshBasicMaterial({
                map: shapedBillboardTexture,
                side: THREE.DoubleSide,
                transparent: true,
                fog: false,
                alphaTest: 0.5 // Add alphaTest to handle transparency properly
            });
            const shapedBillboard = new THREE.Mesh(shapedBillboardGeometry, shapedBillboardMaterial);

            // Create poles to hold the billboard
            const shapedBillboardPoleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 40);
            const shapedBillboardPoleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                fog: false
            });

            // Create two poles
            const shapedBillboardPoleLeft = new THREE.Mesh(shapedBillboardPoleGeometry, shapedBillboardPoleMaterial);
            const shapedBillboardPoleRight = new THREE.Mesh(shapedBillboardPoleGeometry, shapedBillboardPoleMaterial);

            // Position billboard in front of runway
            shapedBillboard.position.set(15, 45, -40);
            shapedBillboard.rotation.y = -0.75;

            // Position poles relative to billboard
            shapedBillboardPoleLeft.position.set(-22, 23, -34);
            shapedBillboardPoleRight.position.set(-8, 23, -47);
            shapedBillboardPoleLeft.rotation.y = 0.75;
            shapedBillboardPoleRight.rotation.y = 0.75;

            scene.add(shapedBillboard);
            scene.add(shapedBillboardPoleLeft);
            scene.add(shapedBillboardPoleRight);
        // </lambda chat billboard>

        // <daveyswift billboard>
            // Create billboard2 geometry with 1078:339 ratio
            const billboard2Geometry = new THREE.PlaneGeometry(20, 6.29); // Adjusted height to match 1078:339 ratio
            const billboard2Texture = new THREE.TextureLoader().load('/assets/fly_daveyswift.png');
            const billboard2Material = new THREE.MeshBasicMaterial({
                map: billboard2Texture,
                side: THREE.DoubleSide,
                transparent: false,
                fog: true
            });
            const billboard2 = new THREE.Mesh(billboard2Geometry, billboard2Material);

            // Create white border frame
            const billboard2BorderGeometry = new THREE.PlaneGeometry(20.5, 6.79); // Slightly larger than billboard2
            const billboard2BorderMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                side: THREE.DoubleSide,
                fog: false
            });
            const billboard2Border = new THREE.Mesh(billboard2BorderGeometry, billboard2BorderMaterial);
            billboard2Border.position.z = -0.1; // Slightly behind billboard2
            billboard2.add(billboard2Border); // Add border as child of billboard2

            // Create poles to hold the billboard2
            const billboard2PoleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 40);
            const billboard2PoleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                fog: false
            });

            // Create two poles
            const billboard2PoleLeft = new THREE.Mesh(billboard2PoleGeometry, billboard2PoleMaterial);
            const billboard2PoleRight = new THREE.Mesh(billboard2PoleGeometry, billboard2PoleMaterial);

            // Position billboard2 in front of runway
            billboard2.position.set(-15, 40, 50);
            billboard2.rotation.y = 0.75;

            // Position poles relative to billboard2 - Fixed pole positions to match billboard2 position
            billboard2PoleLeft.position.set(-22, 23, 56);
            billboard2PoleRight.position.set(-10, 23, 45);
            billboard2PoleLeft.rotation.y = 0.75;
            billboard2PoleRight.rotation.y = 0.75;

            scene.add(billboard2);
            scene.add(billboard2PoleLeft);
            scene.add(billboard2PoleRight);
        // </daveyswift billboard2>


        // <magnific ai billboard>
            // Create billboard geometry with 1600:500 ratio
            const billboardGeometry = new THREE.PlaneGeometry(20, 6);
            const billboardTexture = new THREE.TextureLoader().load('/assets/fly_magnific.png');
            const billboardMaterial = new THREE.MeshBasicMaterial({
                map: billboardTexture,
                side: THREE.DoubleSide,
                transparent: false,
                fog: true
            });
            const billboard = new THREE.Mesh(billboardGeometry, billboardMaterial);

            // Create white border frame
            const billboardBorderGeometry = new THREE.PlaneGeometry(20.5, 6.5); // Slightly larger than billboard
            const billboardBorderMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                side: THREE.DoubleSide,
                fog: false
            });
            const billboardBorder = new THREE.Mesh(billboardBorderGeometry, billboardBorderMaterial);
            billboardBorder.position.z = -0.1; // Slightly behind billboard
            billboard.add(billboardBorder); // Add border as child of billboard

            // Create poles to hold the billboard
            const billboardPoleGeometry = new THREE.CylinderGeometry(0.2, 0.2, 40);
            const billboardPoleMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                fog: false
            });
            
            // Create two poles
            const billboardPoleLeft = new THREE.Mesh(billboardPoleGeometry, billboardPoleMaterial);
            const billboardPoleRight = new THREE.Mesh(billboardPoleGeometry, billboardPoleMaterial);

            // Position billboard in front of runway
            billboard.position.set(-15, 40, -40);
            billboard.rotation.y = 0.75;

            // Position poles relative to billboard
            billboardPoleLeft.position.set(-22, 23, -34);
            billboardPoleRight.position.set(-8, 23, -47);
            billboardPoleLeft.rotation.y = 0.75;
            billboardPoleRight.rotation.y = 0.75;

            scene.add(billboard);
            scene.add(billboardPoleLeft);
            scene.add(billboardPoleRight);
        // </magnific ai billboard>


        // <jupiter>
            // Add after other scene setup code, before the animation loop
            // Create jupiter (now Jupiter)
            const jupiterTextureLoader = new THREE.TextureLoader();
            const jupiterGeometry = new THREE.SphereGeometry(500, 32, 16);
            jupiterMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0, // Start invisible
                fog: false  // Make jupiter ignore scene fog
            });

            // Increase the base color brightness
            jupiterMaterial.color.multiplyScalar(1.5); // Makes the base color twice as bright

            // Changed texture URL to Jupiter texture
            jupiterTextureLoader.load('/assets/fly_jupiter.jpg', (texture) => {
                // Flip the texture horizontally
                texture.repeat.x = -1;
                texture.offset.x = 1;
                jupiterMaterial.map = texture;
                jupiterMaterial.needsUpdate = true;
            });

            const jupiter = new THREE.Mesh(jupiterGeometry, jupiterMaterial);
            jupiter.position.set(-5000, 6000, -7000);
            // Rotate the jupiter to show the desired side
            jupiter.rotation.y = Math.PI;
            scene.add(jupiter);


            // <ad on jupiter>
                // Advertisement banner on Jupiter
                const createJupiterTextTexture = () => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 512;
                    canvas.height = 128;
                    
                    // Background
                    context.fillStyle = '#000000'; // Black background
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Text
                    context.font = 'bold 48px system-ui';
                    context.fillStyle = 'white';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText('SOFTGEN.AI', canvas.width / 2, canvas.height / 2);
                    
                    return new THREE.CanvasTexture(canvas);
                };

                // Create banner with the text
                const jupiterBannerGeometry = new THREE.PlaneGeometry(800, 200);
                const jupiterBannerMaterial = new THREE.MeshBasicMaterial({ 
                    map: createJupiterTextTexture(),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8,
                    fog:false
                });
                const jupiterBanner = new THREE.Mesh(jupiterBannerGeometry, jupiterBannerMaterial);
                
                // Position banner on Jupiter surface
                // jupiter.position.set(5000, 5000, -7000);
                jupiterBanner.position.set(-4600, 5700, -6450); 
                jupiterBanner.lookAt(0, 50, 0); // Make banner face towards runway
                scene.add(jupiterBanner);
            // </ad on jupiter>
        // </jupiter>


        // Add after other building creation functions
        function createCastle() {
            const castleGroup = new THREE.Group();
            
            // Main castle body - large central keep
            const keepGeometry = new THREE.BoxGeometry(40, 60, 40);
            const stoneMaterial = new THREE.MeshPhongMaterial({
                color: 0x808080,
                flatShading: true
            });
            const keep = new THREE.Mesh(keepGeometry, stoneMaterial);
            keep.position.y = 30;
            castleGroup.add(keep);
            
            // Create text banner above castle door
            const createCastleTextTexture = () => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                
                const context = canvas.getContext('2d');
                
                // Clear canvas with transparent background
                context.clearRect(0, 0, canvas.width, canvas.height);
                
                // Text
                context.font = 'bold 36px system-ui';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText('VIBE.CO', canvas.width / 2, canvas.height / 3);
                context.fillText('CASTLE', canvas.width / 2, canvas.height * 2/3);
                
                return new THREE.CanvasTexture(canvas);
            };

            // Create banner with castle text
            const castleBannerGeometry = new THREE.PlaneGeometry(30, 15);
            const castleBannerMaterial = new THREE.MeshBasicMaterial({ 
                map: createCastleTextTexture(),
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9,
                fog: false
            });
            const castleBanner = new THREE.Mesh(castleBannerGeometry, castleBannerMaterial);
            
            // Position banner above castle door
            castleBanner.position.set(0, 40, 20.1); // Slightly in front of castle wall
            castleGroup.add(castleBanner);

            // Four corner towers
            const towerGeometry = new THREE.CylinderGeometry(6, 8, 70, 8);
            const towerPositions = [
                [-22, 35, -22],
                [22, 35, -22],
                [-22, 35, 22],
                [22, 35, 22]
            ];
            
            towerPositions.forEach((pos, index) => {
                const tower = new THREE.Mesh(towerGeometry, stoneMaterial);
                tower.position.set(...pos);
                castleGroup.add(tower);
                
                // Add conical roof to each tower
                const roofGeometry = new THREE.ConeGeometry(8, 15, 8);
                const roofMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8B4513
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(pos[0], pos[1] + 42, pos[2]);
                castleGroup.add(roof);
            });
            
            // Add crenellations
            for(let x = -18; x <= 18; x += 4) {
                for(let z = -18; z <= 18; z += 4) {
                    if(x === -18 || x === 18 || z === -18 || z === 18) {
                        const merlon = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 4, 3),
                            stoneMaterial
                        );
                        merlon.position.set(x, 62, z);
                        castleGroup.add(merlon);
                    }
                }
            }
            
            // Position the castle
            castleGroup.position.set(100, 35.2, -300);
            return castleGroup;
        }

        // Add after other scene setup code
        const castle = createCastle();
        scene.add(castle);


        function broadcastChatMessage(message) {
            // Skip broadcasting if running locally or not connected
            if (typeof socket === 'undefined' || !socket || socket.readyState !== WebSocket.OPEN) {
                if (Math.random() < 0.01) { // Log only occasionally
                    console.log('‚è≥ Waiting for WebSocket connection to broadcast chat...');
                }
                return;
            }

            const chatMessage = {
                type: 'chat',
                message: message,
                timestamp: Date.now(),
                username: selfUsername,
                planeId: selfPlaneId,
                verifyToken: verifyToken
            };

            console.log('üì° Broadcasting chat:', chatMessage);

            try {
                socket.send(JSON.stringify(chatMessage));
            } catch (err) {
                console.error('‚ùå Failed to send chat data:', err);
            }
        }


        function broadcastHit(targetPlaneId, damage, isKill) {
            // Skip broadcasting if running locally or not connected
            if (typeof socket === 'undefined' || !socket || socket.readyState !== WebSocket.OPEN) {
                if (Math.random() < 0.01) { // Log only occasionally
                    console.log('‚è≥ Waiting for WebSocket connection to broadcast hit...');
                }
                return;
            }

            // Check if target is already dead
            const targetPlane = otherPlayers.get(targetPlaneId);
            if (!targetPlane || targetPlane.userData.health <= 0) {
                return; // Don't broadcast hit if target is already dead
            }

            const message = {
                type: 'hit',
                attackerId: selfPlaneId,
                attackerName: selfUsername,
                targetId: targetPlaneId,
                damage: damage,
                isKill: isKill,
                timestamp: Date.now(),
                username:selfUsername,
                planeId:selfPlaneId,
                verifyToken: verifyToken
            };

            console.log('üì° Broadcasting hit:', message);

            try {
                socket.send(JSON.stringify(message));
            } catch (err) {
                console.error('‚ùå Failed to send hit data:', err);
            }
        }

        function broadcastCrash(verb) {
            // Skip broadcasting if running locally or not connected
            if (typeof socket === 'undefined' || !socket || socket.readyState !== WebSocket.OPEN) {
                if (Math.random() < 0.01) { // Log only occasionally
                    console.log('‚è≥ Waiting for WebSocket connection to broadcast crash...');
                }
                return;
            }

            // Prevent multiple calls to gameOver
            if (window.gameEnded) return;


            showMessage(`<b>${selfUsername}</b> ${CRASH_MESSAGES[verb]}`);

            const message = {
                type: 'crash',
                planeId: selfPlaneId,
                username: selfUsername,
                verb: verb,
                timestamp: Date.now(),
                verifyToken: verifyToken
            };

            console.log('üì° Broadcasting crash:', message);

            try {
                socket.send(JSON.stringify(message));
            } catch (err) {
                console.error('‚ùå Failed to send crash data:', err);
            }
        }
     
        // Modify checkMissileCollisions function
        function checkMissileCollisions() {
            // Check each missile
            for (let i = missiles.length - 1; i >= 0; i--) {
                const missile = missiles[i];
                const missileBox = new THREE.Box3().setFromObject(missile);
                let missileHit = false;



                // Calculate distance of player from both spawn points
                const distanceFromRunway = Math.sqrt(
                    Math.pow(player.position.x - RUNWAY_SPAWN_X, 2) + 
                    Math.pow(player.position.y - RUNWAY_SPAWN_Y, 2) + 
                    Math.pow(player.position.z - RUNWAY_SPAWN_Z, 2)
                );
                const distanceFromCarrier = Math.sqrt(
                    Math.pow(player.position.x - CARRIER_SPAWN_X, 2) + 
                    Math.pow(player.position.y - CARRIER_SPAWN_Y, 2) + 
                    Math.pow(player.position.z - CARRIER_SPAWN_Z, 2)
                );

                // If too close to either spawn point, show message and return
                if (player.position.y < 40 && 
                    (
                        distanceFromRunway < RUNWAY_SHOOT_DISTANCE || 
                        distanceFromCarrier < RUNWAY_SHOOT_DISTANCE
                    )
                ) {
                    showMessage('‚õîÔ∏è Cannot shoot from spawn points, take off first',true);
                    return;
                }
                    

                    
                // Calculate distance of missile from both spawn points
                const missileDistanceFromRunway = Math.sqrt(
                    Math.pow(missile.position.x - RUNWAY_SPAWN_X, 2) + 
                    Math.pow(missile.position.y - RUNWAY_SPAWN_Y, 2) + 
                    Math.pow(missile.position.z - RUNWAY_SPAWN_Z, 2)
                );
                const missileDistanceFromCarrier = Math.sqrt(
                    Math.pow(missile.position.x - CARRIER_SPAWN_X, 2) + 
                    Math.pow(missile.position.y - CARRIER_SPAWN_Y, 2) + 
                    Math.pow(missile.position.z - CARRIER_SPAWN_Z, 2)
                );

                // Skip collision detection if missile is too close to either spawn point
                if (missileDistanceFromRunway < RUNWAY_SHOOT_DISTANCE || 
                    missileDistanceFromCarrier < RUNWAY_SHOOT_DISTANCE) {
                    showMessage('‚õîÔ∏è Cannot shoot at planes on spawn points - protected area',true);
                    continue; // Skip this missile's collision checks
                }

                // Check other player collisions first (most important gameplay element)
                // Only check planes that are reasonably close to the missile for efficiency
                const COLLISION_CHECK_DISTANCE = 50; // Only check planes within this distance
                
                otherPlayers.forEach((otherPlane, otherPlayerPlaneId) => {
                    // Skip collision check if plane is too far away (distance optimization)
                    const distanceToPlane = missile.position.distanceTo(otherPlane.position);
                    if (distanceToPlane > COLLISION_CHECK_DISTANCE) return;
                    
                    // Skip collision check if plane is invisible
                    // because then it's dead
                    if (!otherPlane.visible) return;
                    
                    // Now do the more expensive bounding box check
                    const planeBox = new THREE.Box3().setFromObject(otherPlane);
                    
                    if (missileBox.intersectsBox(planeBox)) {
                        // Create explosion effect at the hit position
                        createExplosionEffect(otherPlane.position.clone());
                        playExplosionSound();
                        
                        // Remove missile
                        scene.remove(missile);
                        missiles.splice(i, 1);
                        missileHit = true;
                        
                        // Reduce the other player's health
                        console.log('otherPlane ', otherPlane);
                        console.log('health before hit ', otherPlane.userData.health);
                        otherPlane.userData.health -= HIT_DAMAGE; // Reduce health by N per hit
                        console.log('health after hit ', otherPlane.userData.health);
                        
                       // Check if this hit resulted in a kill
                        const isKill = otherPlane.userData.health <= 0;
                        
                        if(isKill) {
                            // add 1 to currentKills
                            currentKills++;
                            // update score display and shake
                            updateScoreDisplay(true);


                            // Create visual feedback for killing somone
                            const killIndicator = document.createElement('div');
                            killIndicator.style.position = 'fixed';
                            killIndicator.style.top = '0';
                            killIndicator.style.left = '0';
                            killIndicator.style.width = '100%';
                            killIndicator.style.height = '100%';
                            killIndicator.style.border = '10px solid #00ff00';
                            killIndicator.style.boxSizing = 'border-box';
                            killIndicator.style.pointerEvents = 'none';
                            killIndicator.style.zIndex = '1000';
                            killIndicator.style.opacity = '0.7';
                            document.body.appendChild(killIndicator);

                            // Fade out and remove the kill indicator
                            setTimeout(() => {
                                killIndicator.style.transition = 'opacity 0.5s';
                                killIndicator.style.opacity = '0';
                                setTimeout(() => {
                                    document.body.removeChild(killIndicator);
                                }, 500);
                            }, 1000);
                            
                        }


                        // Broadcast hit to server
                        broadcastHit(otherPlayerPlaneId, HIT_DAMAGE, isKill);
                        
                        
                        // Update plane color based on health
                        updatePlaneColorBasedOnHealth(otherPlane);
        
                        
                        scoreToAddForKill=100;
                        // Add score for hitting another player
                        score += 25;
                        
                        // Create hit effect
                        createHitEffect(otherPlane.position.clone());
                                        
                        // Get the username from the plane's userData if available
                        const otherPlayerUsername = otherPlane.userData.username || otherPlayerPlaneId;
                        
                        // Show message
                        if (isKill) {
                            const attackerName = selfUsername || selfPlaneId;
                            const targetName = otherPlayerUsername || otherPlayerPlaneId;
                            showMessage(`<b>${escapeHtml(attackerName)}</b> (${player.userData.health || 100}%) killed <b>${escapeHtml(targetName)}</b> +${scoreToAddForKill}`, true);
                        } else {
                            const attackerName = selfUsername || selfPlaneId;
                            const targetName = otherPlayerUsername || otherPlayerPlaneId;
                            showMessage(`<b>${escapeHtml(attackerName)}</b> (${player.userData.health || 100}%) hit <b>${escapeHtml(targetName)}</b> (${otherPlane.userData.health || 100}%)`, true);
                        }
                        // Broadcast hit to other players (if we implement this feature)
                        // broadcastHit(planeId);
                        
                        return; // Exit the forEach loop early
                    }
                });
                
                // If missile already hit something, skip the rest of the checks
                if (missileHit) continue;


                // Create castle bounding box
                const castleBox = new THREE.Box3().setFromObject(castle);
                
                // Check castle collision
                if (missileBox.intersectsBox(castleBox)) {
                    // Remove missile
                    scene.remove(missile);
                    missiles.splice(i, 1);
                    missileHit = true;
                    
                    // Create explosion effect at the castle position
                    const explosionPosition = new THREE.Vector3();
                    castle.getWorldPosition(explosionPosition);
                    createExplosionEffect(explosionPosition, true);
                    
                    // Play explosion sound
                    playExplosionSound();
                    
                    // Remove the entire castle
                    scene.remove(castle);
                    
                    // Add a big score bonus
                    score += 30;
                }

                // Check house collisions
                if (!missileHit) {
                    for (let j = houses.length - 1; j >= 0; j--) {
                        const house = houses[j];
                        const houseBox = new THREE.Box3().setFromObject(house);
                        
                        if (missileBox.intersectsBox(houseBox)) {
                            // Create explosion effect at the house position
                            createExplosionEffect(house.position.clone(), false);
                            playExplosionSound();
                            
                            // Remove house and missile
                            scene.remove(house);
                            scene.remove(missile);
                            houses.splice(j, 1);
                            missiles.splice(i, 1);
                            
                            // Add score for hitting a house
                            score += 50;
                            missileHit = true;
                            break;
                        }
                    }
                }
                

                // Check building collisions
                if (!missileHit && typeof buildings !== 'undefined' && buildings.length > 0) {
                    for (let j = buildings.length - 1; j >= 0; j--) {
                        const building = buildings[j];
                        const buildingBox = new THREE.Box3().setFromObject(building);
                        
                        if (missileBox.intersectsBox(buildingBox)) {
                            // Create explosion effect at the building position
                            createExplosionEffect(building.position.clone(), true);
                            playExplosionSound();
                            
                            // Remove building and missile
                            scene.remove(building);
                            scene.remove(missile);
                            buildings.splice(j, 1);
                            missiles.splice(i, 1);
                            
                            // Add score for hitting a building
                            score += 20;
                            missileHit = true;
                            break;
                        }
                    }
                }


                // If missile hasn't hit castle, check balloon collisions
                if (!missileHit) {
                    for (let j = targets.length - 1; j >= 0; j--) {
                        const target = targets[j];
                        target.boundingBox.setFromObject(target);
                        
                        if (missileBox.intersectsBox(target.boundingBox)) {
                            // Existing balloon hit code
                            createExplosionEffect(target.position.clone());
                            playExplosionSound();
                            scene.remove(target);
                            scene.remove(missile);
                            targets.splice(j, 1);
                            missiles.splice(i, 1);
                            balloonsHit++;
                            score += 5;
                            updateScoreDisplay(true);
                            break;
                        }
                    }
                }
            }
        }

        // Modify createExplosionEffect to handle larger castle explosions
        function createExplosionEffect(position, isLarge = false) {
            const particles = new THREE.Group();
            const particleCount = isLarge ? 50 : 20; // More particles for castle explosions
            const particleSize = isLarge ? 2 : 0.5; // Larger particles for castle
            const explosionRadius = isLarge ? 10 : 3; // Larger radius for castle
            const explosionSpeed = isLarge ? 30 : 10; // Faster particles for castle

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.BoxGeometry(particleSize, particleSize, particleSize);
                const material = new THREE.MeshPhongMaterial({
                    color: isLarge ? 0xff4400 : 0xff0000,
                    emissive: isLarge ? 0xff4400 : 0xff0000,
                    emissiveIntensity: 0.5
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                // Random velocity in sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const speed = Math.random() * explosionSpeed;
                
                particle.velocity = new THREE.Vector3(
                    Math.sin(phi) * Math.cos(theta),
                    Math.cos(phi),
                    Math.sin(phi) * Math.sin(theta)
                ).multiplyScalar(speed);
                
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Animate explosion
            let elapsedTime = 0;
            function animateExplosion() {
                elapsedTime += deltaTime;
                
                particles.children.forEach((particle) => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(deltaTime * 60));
                    particle.velocity.y -= 0.1 * deltaTime * 60; // More gravity for castle debris
                    particle.material.opacity = 1 - (elapsedTime);
                    particle.material.transparent = true;
                    
                    // Add rotation to the particles
                    particle.rotation.x += 0.1 * deltaTime * 60;
                    particle.rotation.y += 0.1 * deltaTime * 60;
                });
                
                if (elapsedTime < 1) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    scene.remove(particles);
                }
            }
            animateExplosion();
        }

        
        function setupWebSocket() {
            // Skip WebSocket setup if running locally
            // if (isLocalGame) {
            //     console.log('üîß Running in local debug mode - multiplayer disabled');
            //     return;
            // }

            
            try {
                console.log('üåê Connecting to WebSocket server...');
                socket = new WebSocket(WS_SERVER);

                socket.onopen = () => {
                    console.log('‚úÖ Connected to WebSocket server');
                    if(selfUsername) {
                        showMessage(`<b>${selfUsername}</b> joined the game`);
                    }
                    else {
                        showMessage('Connected to server');
                    }
                };

                socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // <sync time>
                            if(data.time !== undefined) {
                                // Only sync if the time difference is significant (more than 1000 units)
                                const timeDifference = Math.abs(gameTime - data.time);
                                if (timeDifference > 100) {
                                    // console.log('üïí Synced game time to server:', data.time, '(difference was', timeDifference, ')');
                                    gameTime = data.time;
                                }
                            }
                        // </sync time>


                        
                        // <sync round time>
                            if(
                                data.roundTimeElapsed !== undefined &&
                                data.roundTimeRemaining !== undefined
                            ) {
                                console.log('üïí Synced round time to server:', data.roundTimeElapsed, data.roundTimeRemaining);
                                roundTimeElapsed=data.roundTimeElapsed;
                                roundTimeRemaining=data.roundTimeRemaining;
                                // if roundTimeRemaining is defined and below 10 seconds, show a giant countdown timer
                                // like big white letters on screen 10 9 8 7 6 5 4 3 2 1 etc.
                                // use the font-size of 100px in white
                                if(roundTimeRemaining < 10) {
                                    // Use the existing roundTimeCountdown element
                                    const roundTimeCountdown = document.getElementById('roundTimeCountdown');
                                    if (roundTimeCountdown) {
                                        roundTimeCountdown.innerHTML = `<span style="font-size:24px">Round ends in</span><br/><span style="font-size:40vw">${Math.ceil(roundTimeRemaining)}</span>`;
                                        roundTimeCountdown.style.display = 'block';
                                    }
                                }
                                else {
                                    // Hide the countdown element
                                    const roundTimeCountdown = document.getElementById('roundTimeCountdown');
                                    if (roundTimeCountdown) {
                                        roundTimeCountdown.style.display = 'none';
                                    }
                                }
                                // if rounded roundTimeRemaining is 0, move player to spawn point
                                if(Math.round(roundTimeRemaining) == 0) {
                                    // move player to spawn point
                                    player.position.set(SPAWN_POINT_X, SPAWN_POINT_Y, SPAWN_POINT_Z);
                                    currentSpeed=0;
                                    currentPitch = 0;
                                    currentYaw = 0;
                                    currentRoll = 0;
                                    player.rotation.set(0, 0, 0);
                                    player.quaternion.identity();
                                }
                                // if selfCountryFlagEmoji exists prepend that in username
                            }
                        // </sync round time>


                        // <process hits>
                            if(data.hits !== undefined) {
                                // Handle hit data
                                if(data.hits.length > 0) {
                                    // console.log('üì° Received hit data:', data.hits);
                                    data.hits.forEach(hit => {
                                        handleIncomingHitData(hit);
                                    });
                                }
                            }
                        // </process hits>


                        // <process chat messages>
                            if(data.chats !== undefined) {
                                // Handle chat messages
                                if(data.chats.length > 0) {
                                    console.log('üì° Received chat data:', data.chats);
                                    data.chats.forEach(message => {
                                        handleIncomingChatData(message);
                                    });
                                }
                            }
                        // </process chat messages>

                        // <process joins>
                            if(data.joins !== undefined) {
                                if(data.joins.length > 0) { 
                                    console.log('üì° Received join data:', data.joins);
                                    data.joins.forEach(join => {
                                        showMessage(`<b>${join.username}</b> joined the game`);
                                    });
                                }
                            }
                        // </process joins>

                        // <process crashes>
                            if(data.crashes !== undefined) {
                                // Handle crash data
                                if(data.crashes.length > 0) {
                                    // console.log('üì° Received crash data:', data.crashes);
                                    data.crashes.forEach(crash => {
                                        console.log('üì° Received crash data:', crash);
                                        showMessage(`<b>${crash.username}</b> ${CRASH_MESSAGES[crash.verb]}`);
                                    });
                                }
                            }
                        // </process crashes>

                        if (data.type === 'positions') {
                            // Convert batch to individual updates
                            // console.log(`üì° Received batch of ${data.data.length} plane positions`);
                            
                            // In local game mode, only process first batch of positions
                            if (isLocalGame) {
                                if (!window.hasProcessedFirstBatch) {
                                    console.log('üè† Local game mode - processing first batch only');
                                    window.hasProcessedFirstBatch = true;
                                 } else {
                                    return; // Skip subsequent position updates
                                }
                            }
                            
                            updateScoreDisplay();

                            // Process each position in the array
                            data.data.forEach(positionData => {
                                // console.log(positionData);
                                if (positionData.planeId && positionData.planeId !== selfPlaneId) { /* if not self */
                                    // Create a position update object and process it
                                    const singleUpdate = {
                                        type: 'position',
                                        planeId: positionData.planeId,
                                        username: positionData.username,
                                        data: positionData
                                    };
                                    handleIncomingPlaneData(singleUpdate, positionData.planeId);
                                }
                            });
                        }
                        else {
                            console.log('üì® Received unknown data type:', data.type, 'from plane:', data.planeId);
                        }
                    } catch (error) {
                        console.error('‚ùå Error parsing WebSocket message:', error);
                    }
                };

                socket.onclose = () => {
                    console.log('üëã Disconnected from WebSocket server');

                    // Clear all other players from the scene
                    clearAllPlayers();
                    
                    // Try to reconnect after 5 seconds
                    setTimeout(setupWebSocket, 5000);

                    
                };

                socket.onerror = (error) => {
                    console.error('‚ùå WebSocket error:', error);
                };

            } catch (error) {
                console.error('‚ùå Failed to connect to WebSocket server:', error);
            }
        }

        // Function to handle going offline
        window.addEventListener('offline', () => {
            console.log('üî¥ Browser went offline - clearing players');
            clearAllPlayers();
        });

        // Add this new function to handle cleanup
        function clearAllPlayers() {
            // Remove all other player planes from the scene
            otherPlayers.forEach((plane, planeId) => {
                scene.remove(plane);
            });
            
            // Clear the otherPlayers Map
            otherPlayers.clear();
            
            // Update the score display since player count changed
            updateScoreDisplay();
            
            console.log('üßπ Cleared all other players from scene');
        }

        // Modify the mouse/touch movement handlers
        function handleMouseMove(event) {
            if (isMouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                // Update angles without any clamping/limits
                cameraAngleHorizontal += deltaX * 0.01;
                cameraAngleVertical += deltaY * 0.01;
                
                // No angle limits - allow full 360¬∞ rotation
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            }
        }

        function updateEngineSound() {
            // ‚úÖ Update Engine Sound (Only if Initialized)
            if (window.engineSound) {
                if(vehicleName == 'cessna') {
                    const normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);
                    const baseFreq = 40 + normalizedSpeed * 100;
                    
                    // Apply turbo multiplier to frequency when Shift is held
                    const turboMultiplier = !skipControls && keys['ShiftRight'] ? 2 : 1;
                    
                    window.engineSound.osc1.frequency.setValueAtTime(baseFreq * turboMultiplier, window.audioContext.currentTime);
                    window.engineSound.osc2.frequency.setValueAtTime(baseFreq * 1.5 * turboMultiplier, window.audioContext.currentTime);
                    window.engineSound.osc3.frequency.setValueAtTime(baseFreq * 2 * turboMultiplier, window.audioContext.currentTime);

                    // Increase gain during turbo for more intense sound
                    const gainMultiplier = !skipControls && keys['ShiftRight'] ? 1.5 : 1;
                    window.engineSound.gain1.gain.setValueAtTime((0.1 + normalizedSpeed * 0.3) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.gain2.gain.setValueAtTime((0.05 + normalizedSpeed * 0.15) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.gain3.gain.setValueAtTime((0.02 + normalizedSpeed * 0.06) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.noise.gain.setValueAtTime((0.1 + normalizedSpeed * 0.3) * gainMultiplier, window.audioContext.currentTime);
                    
                    // Increase filter frequency during turbo for a sharper sound
                    window.engineSound.filter.frequency.setValueAtTime(800 + normalizedSpeed * 3000 * turboMultiplier, window.audioContext.currentTime);
                }
                if(vehicleName == 'ski') {
                    const normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);
                    
                    // Apply turbo multiplier to frequency when Shift is held
                    const turboMultiplier = !skipControls && keys['ShiftRight'] ? 1.5 : 1;
                    
                    // Set oscillator types for ski sound
                    window.engineSound.osc1.type = 'noise'; // Use noise for snow friction sound
                    window.engineSound.osc2.type = 'sine';  // Subtle sine wave for smooth gliding
                    window.engineSound.osc3.type = 'sine';  // Additional harmonic
                    
                    // Only need minimal oscillator frequencies for ski sounds
                    window.engineSound.osc1.frequency.setValueAtTime(100 * normalizedSpeed, window.audioContext.currentTime);
                    window.engineSound.osc2.frequency.setValueAtTime(80 * normalizedSpeed, window.audioContext.currentTime);
                    window.engineSound.osc3.frequency.setValueAtTime(120 * normalizedSpeed, window.audioContext.currentTime);

                    // Adjust gain based on speed - skis are silent when not moving
                    const skiGain = normalizedSpeed * normalizedSpeed * turboMultiplier; // Quadratic relationship with speed
                    window.engineSound.gain1.gain.setValueAtTime(0.2 * skiGain, window.audioContext.currentTime);
                    window.engineSound.gain2.gain.setValueAtTime(0.05 * skiGain, window.audioContext.currentTime);
                    window.engineSound.gain3.gain.setValueAtTime(0.02 * skiGain, window.audioContext.currentTime);
                    window.engineSound.noise.gain.setValueAtTime(0.3 * skiGain, window.audioContext.currentTime);
                    
                    // Use filter to create the "shhhh" sound of skis on snow
                    // Higher speeds create more high-frequency content
                    window.engineSound.filter.type = 'lowpass';
                    window.engineSound.filter.frequency.setValueAtTime(500 + 2000 * normalizedSpeed, window.audioContext.currentTime);
                    window.engineSound.filter.Q.setValueAtTime(1 + normalizedSpeed * 5, window.audioContext.currentTime);
                }
                else if(vehicleName == 'f16' || vehicleName=='a10') {
                    // a10 sound
                    // f16 sound
                    const normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);
                    const baseFreq = 20 + normalizedSpeed * 50;
                    
                    // Apply turbo multiplier to frequency when Shift is held
                    const turboMultiplier = !skipControls && keys['ShiftRight'] ? 2 : 1;
                    
                    // Set oscillator types to square wave for jet engine sound
                    window.engineSound.osc1.type = 'sine';
                    window.engineSound.osc2.type = 'sine'; 
                    window.engineSound.osc3.type = 'square';

                    window.engineSound.osc1.frequency.setValueAtTime(baseFreq * turboMultiplier, window.audioContext.currentTime);
                    window.engineSound.osc2.frequency.setValueAtTime(baseFreq * 1.5 * turboMultiplier, window.audioContext.currentTime);
                    window.engineSound.osc3.frequency.setValueAtTime(baseFreq * 2 * turboMultiplier, window.audioContext.currentTime);

                    // Increase gain during turbo for more intense sound
                    const gainMultiplier = !skipControls && keys['ShiftRight'] ? 1.5 : 1;
                    window.engineSound.gain1.gain.setValueAtTime((0.1 + normalizedSpeed * 0.3) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.gain2.gain.setValueAtTime((0.05 + normalizedSpeed * 0.15) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.gain3.gain.setValueAtTime((0.02 + normalizedSpeed * 0.06) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.noise.gain.setValueAtTime((0.1 + normalizedSpeed * 0.3) * gainMultiplier, window.audioContext.currentTime);
                    
                    // Increase filter frequency during turbo for a sharper sound
                    window.engineSound.filter.frequency.setValueAtTime(800 + normalizedSpeed * 3000 * turboMultiplier, window.audioContext.currentTime);
                }
                else if(vehicleName == 'apache') {
                    // apache sound
                    let normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);

                    // if normalizespeed is a number
                    if(isNaN(normalizedSpeed)) {
                        normalizedSpeed = 0;
                    }

                    // Base frequency for main rotor sound (tuned to real-world rotor speed)
                    // Apache main rotor spins at ~290 RPM (4.83 Hz), but perceived pitch is higher due to blade pass rate (4 blades)
                    const mainRotorFreq = 19 + Math.abs(normalizedSpeed) * 12; // 19-31 Hz range for realism

                    // Tail rotor frequency (Apache tail rotor is ~4-5x faster due to gearing and blade count)
                    const tailRotorFreq = mainRotorFreq * 4.8; // Slightly higher multiplier for sharper whine

                    // Set oscillator types for helicopter sound characteristics
                    window.engineSound.osc1.type = 'triangle'; // Main rotor: distinctive "whump-whump" sound
                    window.engineSound.osc2.type = 'square';   // Tail rotor: higher pitched whine
                    window.engineSound.osc3.type = 'sawtooth'; // Engine/turbine sound: harsh mechanical component

                    // Apply frequencies with subtle modulation for realism
                    window.engineSound.osc1.frequency.setValueAtTime(mainRotorFreq, window.audioContext.currentTime);
                    window.engineSound.osc2.frequency.setValueAtTime(tailRotorFreq, window.audioContext.currentTime);
                    window.engineSound.osc3.frequency.setValueAtTime(mainRotorFreq * 3.2, window.audioContext.currentTime); // Turbine harmonic

                    // Add blade slap effect with LFO if not already created
                    if (!window.engineSound.bladeSlap) {
                        window.engineSound.bladeSlap = window.audioContext.createOscillator();
                        window.engineSound.bladeSlapGain = window.audioContext.createGain();
                        window.engineSound.bladeSlap.type = 'sine';
                        window.engineSound.bladeSlap.frequency.setValueAtTime(mainRotorFreq / 4, window.audioContext.currentTime); // One slap per blade
                        window.engineSound.bladeSlapGain.gain.setValueAtTime(0.15, window.audioContext.currentTime);
                        window.engineSound.bladeSlap.connect(window.engineSound.bladeSlapGain);
                        window.engineSound.bladeSlapGain.connect(window.engineSound.gain1.gain); // Modulate main rotor volume
                        window.engineSound.bladeSlap.start();
                    }

                    // Dynamic gain adjustments for rotor and turbine balance
                    window.engineSound.gain1.gain.setValueAtTime(0.3 + normalizedSpeed * 0.2, window.audioContext.currentTime);  // Main rotor
                    window.engineSound.gain2.gain.setValueAtTime(0.08 + normalizedSpeed * 0.12, window.audioContext.currentTime); // Tail rotor
                    window.engineSound.gain3.gain.setValueAtTime(0.1 + normalizedSpeed * 0.15, window.audioContext.currentTime);  // Turbine
                    window.engineSound.noise.gain.setValueAtTime(0.2 + normalizedSpeed * 0.3, window.audioContext.currentTime);   // Air noise/wash
                    
                    // Filter settings for helicopter sound characteristics
                    window.engineSound.filter.type = 'lowpass';
                    window.engineSound.filter.frequency.setValueAtTime(1200 + normalizedSpeed * 2000, window.audioContext.currentTime);
                    window.engineSound.filter.Q.setValueAtTime(2 + normalizedSpeed * 3, window.audioContext.currentTime);
                }
                else if(vehicleName == 'tank') {
                    const normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);
                    const baseFreq = 20 + normalizedSpeed * 40; // Lower base frequency for tank engine
                    
                    // disable turbo on tank
                    const turboMultiplier = 1;
                    
                    // Lower frequencies for tank engine rumble
                    window.engineSound.osc1.frequency.setValueAtTime(baseFreq * turboMultiplier, window.audioContext.currentTime);
                    window.engineSound.osc2.frequency.setValueAtTime(baseFreq * 1.2 * turboMultiplier, window.audioContext.currentTime);
                    window.engineSound.osc3.frequency.setValueAtTime(baseFreq * 1.5 * turboMultiplier, window.audioContext.currentTime);

                    // Higher base gain for more rumble
                    const gainMultiplier = !skipControls && keys['ShiftRight'] ? 1.2 : 1; // Reduced gain boost for tank
                    window.engineSound.gain1.gain.setValueAtTime((0.2 + normalizedSpeed * 0.4) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.gain2.gain.setValueAtTime((0.15 + normalizedSpeed * 0.3) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.gain3.gain.setValueAtTime((0.1 + normalizedSpeed * 0.2) * gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.noise.gain.setValueAtTime((0.3 + normalizedSpeed * 0.4) * gainMultiplier, window.audioContext.currentTime);
                    
                    // Lower filter frequency for deeper rumble
                    window.engineSound.filter.frequency.setValueAtTime(200 + normalizedSpeed * 1000 * turboMultiplier, window.audioContext.currentTime);
                }
                else if(vehicleName == 'triangle') {
                    const normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);

                    // Base frequency influenced by speed, starting lower like the mothership
                    const baseFreq = 250 + normalizedSpeed * 200; // Alien sound starts at 50 Hz, varies with speed

                    // Set up oscillators with alien characteristics
                    window.engineSound.osc1.type = 'sawtooth'; // Main eerie tone
                    window.engineSound.osc1.frequency.setValueAtTime(baseFreq, window.audioContext.currentTime);
                    window.engineSound.osc2.type = 'sawtooth'; // Secondary tone, slightly detuned
                    window.engineSound.osc2.frequency.setValueAtTime(baseFreq * 1.05, window.audioContext.currentTime);
                    window.engineSound.osc3.type = 'sawtooth'; // Third tone for richness
                    window.engineSound.osc3.frequency.setValueAtTime(baseFreq * 1.1, window.audioContext.currentTime);

                    // Add modulation for alien effect (from mothership sound)
                    if (!window.engineSound.modulator) {
                        window.engineSound.modulator = window.audioContext.createOscillator();
                        window.engineSound.modulatorGain = window.audioContext.createGain();
                        window.engineSound.modulator.frequency.setValueAtTime(0.2, window.audioContext.currentTime); // Slow waver
                        window.engineSound.modulatorGain.gain.setValueAtTime(20, window.audioContext.currentTime); // Modulation depth
                        window.engineSound.modulator.connect(window.engineSound.modulatorGain);
                        window.engineSound.modulatorGain.connect(window.engineSound.osc1.frequency); // Modulate osc1
                        window.engineSound.modulator.start();
                    }

                    // Volume control with speed influence (alien-style fade)
                    const gainMultiplier = 0.3 + normalizedSpeed * 0.3; // Max volume 0.6, starts quieter
                    window.engineSound.gain1.gain.setValueAtTime(gainMultiplier, window.audioContext.currentTime);
                    window.engineSound.gain2.gain.setValueAtTime(gainMultiplier * 0.8, window.audioContext.currentTime); // Slightly less for osc2
                    window.engineSound.gain3.gain.setValueAtTime(gainMultiplier * 0.6, window.audioContext.currentTime); // Even less for osc3
                    window.engineSound.noise.gain.setValueAtTime(0, window.audioContext.currentTime); // Disable noise (alien sound doesn't use it)

                    // Alien-inspired low-pass filter
                    window.engineSound.filter.type = 'lowpass';
                    window.engineSound.filter.frequency.setValueAtTime(1000, window.audioContext.currentTime); // Fixed at 1000 Hz like mothership
                }
            }
        }

        function addTurbulence() {

            // ‚úÖ Add Turbulence
            // always have 0.1 turbulence cause engine shaking
            let turbulenceIntensity = 0.002 + baseTurbulenceIntensity * (currentSpeed / maxSpeed) * deltaTime * 60;
            let turbulenceFrequency = baseTurbulenceFrequency * (currentSpeed / maxSpeed) * deltaTime * 60;

            // Add extra turbulence when using turbo boost (Shift key)
            if (!skipControls && keys['ShiftRight']) {
                turbulenceIntensity *= 5;  // Significantly increase turbulence intensity during boost
                turbulenceFrequency *= 5;  // Increase turbulence frequency during boost
            }

            if (keys['Space']) {
                turbulenceIntensity *= 3;
                turbulenceFrequency *= 2;
            }

            // Increase base turbulence values
            player.position.x += (Math.random() - 0.5) * turbulenceIntensity * 3;  // Tripled
            player.position.y += (Math.random() - 0.5) * turbulenceIntensity * 3;  // Tripled
            player.position.z += (Math.random() - 0.5) * turbulenceIntensity * 3;  // Tripled

            // console.log('turbulence',(Math.random() - 0.5) * turbulenceIntensity * 3);

        }


        // Add after other global variables
        // Define named event handlers
        function handleKeyDown(event) { 
            keys[event.code] = true; 

            if(!skipControls && gameStarted) {

                // Show leaderboard on Tab
                if (event.code === 'Tab') {
                    event.preventDefault(); // Prevent Tab from changing focus
                    const leaderboard = document.getElementById('leaderboard');
                    if (leaderboard) {
                        leaderboard.style.display = 'block';
                        updateLeaderboard();
                    }
                }
                
                if (event.code === 'KeyM') {
                    toggleMute();
                }

                if (event.key === 't') {
                    event.preventDefault();
                    skipControls = true;
                    chatInput.style.display = 'block';
                    chatInput.focus();
                }
                
            }

        }
        function handleKeyUp(event) { 
            keys[event.code] = false; 


            // Hide leaderboard when Tab is released
            if (event.code === 'Tab') {
                event.preventDefault();
                const leaderboard = document.getElementById('leaderboard');
                if (leaderboard) {
                    leaderboard.style.display = 'none';
                }
            }

            // Add this line to stop A-10 sound on space key up
            if (event.code === 'Space') {
                if (vehicleName === 'a10') {
                    stopA10GunSound();
                }
            }
            
        }

        function handleTouchStart(event) {
            if (!event.target.closest('#leftJoystick') && 
                !event.target.closest('#rightJoystick')) {
                keys['Space'] = true;
            }
        }

        function handleTouchEnd(event) {
            if (!event.target.closest('#leftJoystick') && 
                !event.target.closest('#rightJoystick')) {
                keys['Space'] = false;
                // Add this line to stop A-10 sound on touch end
                if (vehicleName === 'a10') {
                    stopA10GunSound();
                }
            }
        }

        // Replace anonymous event listeners with named functions
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        document.addEventListener('touchstart', handleTouchStart);
        document.addEventListener('touchend', handleTouchEnd);

        // Add after other global variables
        let wastedSound;

        // Add function to load wasted sound
        function loadWastedSound() {
            wastedSound = new Audio('/assets/fly_wasted.mp3');
            wastedSound.volume = 0.7; // Set volume to 70%
        }

        // Call this after audio context creation in startGame
        loadWastedSound();

        // Add with other keyboard event listeners
        window.addEventListener('keydown', function(event) {
            if (event.code === 'KeyV') {
                isThirdPerson = !isThirdPerson;  // Toggle camera view
                
                // Reset mouse position when switching views to prevent sudden camera jumps
                mouseX = 0;
                mouseY = 0;
                
                // Reset last mouse move time to prevent auto-centering immediately
                lastMouseMoveTime = Date.now();
            }
        });

        // Remove the old FOV update code from the keyboard handlers
        window.addEventListener('keydown', (event) => { 
            keys[event.code] = true;
        });

        window.addEventListener('keyup', (event) => { 
            keys[event.code] = false;
            
            // Only reset engine sound when releasing shift
            if (event.code === 'ShiftRight') {
                // Reset engine sound
                if (window.engineSound) {
                    const normalizedSpeed = Math.pow((currentSpeed - minSpeed) / (maxSpeed - minSpeed), 0.5);
                    window.engineSound.gain1.gain.setValueAtTime(0.1 + normalizedSpeed * 0.3, window.audioContext.currentTime);
                    window.engineSound.osc1.frequency.setValueAtTime(40 + normalizedSpeed * 100, window.audioContext.currentTime);
                }
            }
        });

        // Add after other scene setup code, before animation loop
        // Create star field
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 2.5,
                    transparent: true,
            opacity: 0, // Start invisible
            fog: false,
            sizeAttenuation: false
        });

        const starVertices = [];
        for(let i = 0; i < 500; i++) {
            const r = 10000;
            const theta = 2 * Math.PI * Math.random();
            const phi = Math.acos(2 * Math.random() - 1);
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            starVertices.push(x, y, z);
        }

        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        stars.renderOrder = 1;
        scene.add(stars);
        

        // Add this to your animation loop or update function
        function updateStars() {
            const HIGH_ALTITUDE = 5000;
            const NIGHT_START = 18000; // 6 PM in game time
            const NIGHT_END = 6000;    // 6 AM in game time
            
            // Calculate star visibility based on altitude
            if(gameStarted) {
                const altitudeRatio = Math.max(0, Math.min(1, (player.position.y - 1000) / HIGH_ALTITUDE));
            }
            else {
                altitudeRatio = 0;
            }
            
            // Calculate star visibility based on time
            let timeRatio = 0;
            if (gameTime > NIGHT_START || gameTime < NIGHT_END) {
                // At night
                timeRatio = 1;
            } else if (gameTime > NIGHT_START - 2000 && gameTime <= NIGHT_START) {
                // Dusk transition (2000 units before night)
                timeRatio = (gameTime - (NIGHT_START - 2000)) / 2000;
            } else if (gameTime >= NIGHT_END && gameTime < NIGHT_END + 2000) {
                // Dawn transition (2000 units after night)
                timeRatio = 1 - ((gameTime - NIGHT_END) / 2000);
            }
            
            // Use the maximum of both ratios for final opacity
            const targetOpacity = Math.max(altitudeRatio, timeRatio);
            
            // Smooth transition
            starMaterial.opacity += (targetOpacity - starMaterial.opacity) * 0.1;

        }

        // create flying username label with the plane
        function createNameLabel(username, health = 100) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.font = '24px system-ui';
            context.fillStyle = 'white';
            context.textAlign = 'center';
            const text = `${username} (${health}%)`;
            context.fillText(text, canvas.width/2, canvas.height/2);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true 
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(10, 2.5, 1);
            sprite.position.y = 5;  // Adjust height above plane
            
            return sprite;
        }

        // Add after the aircraft carrier code but before the beach creation
        // Banner plane parked next to runway
        const bannerPlaneGroup = new THREE.Group();

        // Main body (fuselage) - smaller than player plane
        const bannerBodyGeometry = new THREE.BoxGeometry(0.6, 0.6, 3);
        const bannerBodyMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 }); // Gold color
        const bannerBody = new THREE.Mesh(bannerBodyGeometry, bannerBodyMaterial);
        bannerPlaneGroup.add(bannerBody);

        // Nose
        const bannerNoseGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.6);
        const bannerNose = new THREE.Mesh(bannerNoseGeometry, bannerBodyMaterial);
        bannerNose.position.z = -1.6;
        bannerNose.position.y = -0.1;
        bannerPlaneGroup.add(bannerNose);

        

        // Wings
        const bannerWingGeometry = new THREE.BoxGeometry(5, 0.1, 1);
        const bannerWingMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
        const bannerWings = new THREE.Mesh(bannerWingGeometry, bannerWingMaterial);
        bannerWings.position.y = 0.2;
        bannerPlaneGroup.add(bannerWings);

        // Tail wings
        const bannerTailWingGeometry = new THREE.BoxGeometry(1.8, 0.1, 0.6);
        const bannerTailWing = new THREE.Mesh(bannerTailWingGeometry, bannerWingMaterial);
        bannerTailWing.position.z = 1.4;
        bannerTailWing.position.y = 0.2;
        bannerPlaneGroup.add(bannerTailWing);

        // Vertical stabilizer
        const bannerStabilizerGeometry = new THREE.BoxGeometry(0.1, 0.6, 1);
        const bannerStabilizer = new THREE.Mesh(bannerStabilizerGeometry, bannerWingMaterial);
        bannerStabilizer.position.z = 1.4;
        bannerStabilizer.position.y = 0.4;
        bannerPlaneGroup.add(bannerStabilizer);

        // Windows (cockpit)
        const bannerWindowGeometry = new THREE.BoxGeometry(0.62, 0.62, 0.8);
        const bannerWindowMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.5
                });
        const bannerWindows = new THREE.Mesh(bannerWindowGeometry, bannerWindowMaterial);
        bannerWindows.position.z = -0.6;
        bannerWindows.position.y = 0.1;
        bannerPlaneGroup.add(bannerWindows);

                // Landing gear
        const bannerWheelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 8);
        const bannerWheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });

        // Main landing gear
        const bannerLeftWheel = new THREE.Mesh(bannerWheelGeometry, bannerWheelMaterial);
        bannerLeftWheel.rotation.z = Math.PI / 2;
        bannerLeftWheel.position.set(-0.8, -0.5, 0);
        bannerPlaneGroup.add(bannerLeftWheel);

        const bannerRightWheel = new THREE.Mesh(bannerWheelGeometry, bannerWheelMaterial);
        bannerRightWheel.rotation.z = Math.PI / 2;
        bannerRightWheel.position.set(0.8, -0.5, 0);
        bannerPlaneGroup.add(bannerRightWheel);
                
        // Nose wheel
        const bannerNoseWheel = new THREE.Mesh(bannerWheelGeometry, bannerWheelMaterial);
        bannerNoseWheel.rotation.z = Math.PI / 2;
        bannerNoseWheel.position.set(0, -0.5, -1.2);
        bannerPlaneGroup.add(bannerNoseWheel);
        
        // Create the banner with correct aspect ratio (570:320)
        const bannerWidth = 12;
        const bannerHeight = bannerWidth * (320/570); // Maintain aspect ratio
        const bannerGeometry = new THREE.PlaneGeometry(bannerWidth, bannerHeight);

        // Load the image texture
        const bannerTexture = new THREE.TextureLoader().load('/assets/fly_fal.jpg');
        const bannerMaterial = new THREE.MeshPhongMaterial({ 
            map: bannerTexture,
            side: THREE.DoubleSide
        });

        const banner = new THREE.Mesh(bannerGeometry, bannerMaterial);

        // Create rope connecting plane to banner
        const ropeLength = 5;
        const ropeGeometry = new THREE.CylinderGeometry(0.05, 0.05, ropeLength, 8);
        const ropeMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 }); // Brown rope
        const rope = new THREE.Mesh(ropeGeometry, ropeMaterial);

        // Position rope horizontally behind the plane
        rope.rotation.z = Math.PI / 2;
        rope.rotation.y = 30 // Rotate 90 degrees to align with plane
        rope.position.z = 2 + ropeLength / 2;

        // Position banner behind the rope
        banner.position.y=3;
        banner.position.z = 5 + ropeLength;
        banner.rotation.y = 35; // Rotate 90 degrees to align with plane

        // Add rope and banner to plane group
        bannerPlaneGroup.add(rope);
        bannerPlaneGroup.add(banner);

        // Position the entire plane group next to the runway
        bannerPlaneGroup.position.set(15, 35.5, 50); // Positioned to the right of the runway
        bannerPlaneGroup.rotation.y = Math.PI / 6; // Slight angle

        // Add to scene
        scene.add(bannerPlaneGroup);

        // Animation variables for the banner
        let bannerWaveTime = 0;

        // Add this to your animate function
        function animateBanner() {
            bannerWaveTime += deltaTime;
            
            // Make the banner wave slightly
            if (banner) {
                banner.rotation.x = Math.sin(bannerWaveTime * 2) * 0.1;
                banner.rotation.y = Math.sin(bannerWaveTime * 1.5) * 0.05;
            }
        }

        let mountainSign;

        // Add after other scene setup code, before the animation loop
        function createMountain() {
            const mountainGroup = new THREE.Group();
            
            // Create main mountain peak
            const mountainGeometry = new THREE.ConeGeometry(100, 200, 6);
            const mountainMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B4513, // Brown base color
                flatShading: true
            });
            
            const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
            mountain.position.y = 100; // Half height to place base at ground level
            mountainGroup.add(mountain);

            // <create Hollywood-style sign text texture>
                const createMountainSignTextTexture = () => {
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.width = 1024;
                    canvas.height = 256;
                    
                    // Transparent background
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Text style
                    context.font = 'bold 60px system-ui';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    // Load custom font
                    const font = new FontFace('SF Hollywood Hills', 'url(/assets/hollywood.ttf)');
                    font.load().then(() => {
                        document.fonts.add(font);
                        
                        // Add black stroke
                        context.font = 'bold 60px "SF Hollywood Hills"';
                        context.strokeStyle = '#000000';
                        // context.lineWidth = 8;
                        // context.strokeText('CHARGEBACKSTOP.COM', canvas.width/2, canvas.height/2);
                        
                        // Add white fill
                        context.fillStyle = '#FFFFFF';
                        context.fillText('CHARGEBACKSTOP.COM', canvas.width/2, canvas.height/2);
                    });
                    return new THREE.CanvasTexture(canvas);
                };

                // Create sign banner
                const mountainSignGeometry = new THREE.PlaneGeometry(120, 30);
                const mountainSignMaterial = new THREE.MeshBasicMaterial({
                    map: createMountainSignTextTexture(),
                    transparent: true,
                    side: THREE.DoubleSide
                });
                mountainSign = new THREE.Mesh(mountainSignGeometry, mountainSignMaterial);
                
                // Position sign on mountain slope
                mountainSign.position.set(-60, 70, 40);
                mountainSign.rotation.z=0;
                mountainSign.rotation.x=0;
                mountainSign.rotation.y=-1.1;
                mountainGroup.add(mountainSign);
            // </create Hollywood-style sign text texture>



            // Add snow cap
            const snowCapGeometry = new THREE.ConeGeometry(40, 50, 6);
            const snowMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF, // White snow
                flatShading: true
            });
            
            const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
            snowCap.position.y = 175; // Position at top of mountain
            mountainGroup.add(snowCap);
            
            // Add some smaller peaks around the main one
            const smallPeakPositions = [
                [-50, -30, -40],
                [60, -50, 30],
                [-30, -60, 50]
            ];
            
            smallPeakPositions.forEach(pos => {
                const smallPeakHeight = 80 + Math.random() * 60;
                const smallPeakGeometry = new THREE.ConeGeometry(30 + Math.random() * 20, smallPeakHeight, 5);
                const smallPeak = new THREE.Mesh(smallPeakGeometry, mountainMaterial);
                
                smallPeak.position.set(
                    pos[0],
                    smallPeakHeight / 2, // Half height to place base at ground level
                    pos[1]
                );
                
                // Random rotation for variety
                smallPeak.rotation.y = Math.random() * Math.PI;
                mountainGroup.add(smallPeak);
                
                // Add small snow caps to some peaks
                if (Math.random() > 0.3) {
                    const smallSnowGeometry = new THREE.ConeGeometry(15, 20, 5);
                    const smallSnow = new THREE.Mesh(smallSnowGeometry, snowMaterial);
                    smallSnow.position.y = smallPeakHeight * 0.4;
                    smallPeak.add(smallSnow);
                }
            });
            
            // Add trees on the lower slopes
            for (let i = 0; i < 50; i++) {
                // Calculate position on the mountain slope
                const angle = Math.random() * Math.PI * 2;
                const distance = 70 + Math.random() * 100; // Increased minimum and maximum distance
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // Calculate height based on distance from center (higher = lower on slope)
                const height = 10 + Math.random() * 15;
                
                // Create tree trunk
                const trunkGeometry = new THREE.CylinderGeometry(2, 3, height, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                // Create tree top (pine tree style)
                const treeTopGeometry = new THREE.ConeGeometry(8, height * 1.5, 8);
                const treeTopMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x006400, // Dark green
                    flatShading: true
                });
                const treeTop = new THREE.Mesh(treeTopGeometry, treeTopMaterial);
                treeTop.position.y = height * 0.75;
                
                // Create tree group
                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(treeTop);
                
                // Position tree on mountain slope
                tree.position.set(x, height/2, z);
                
                // Random rotation and slight tilt based on slope
                tree.rotation.y = Math.random() * Math.PI * 2;
                const slopeTilt = distance / 100; // More tilt further from center
                tree.rotation.x = (Math.random() - 0.5) * 0.2 * slopeTilt;
                tree.rotation.z = (Math.random() - 0.5) * 0.2 * slopeTilt;
                
                mountainGroup.add(tree);
            }

            // Position the mountain in the village area
            mountainGroup.position.set(300, 35, -200);
            
            return mountainGroup;
        }

        // Create and add mountain to scene
        const mountain = createMountain();
        scene.add(mountain);


        
        // Add this function after other audio setup functions
        function toggleMute() {
            isMuted = !isMuted;
            
            // Mute/unmute all audio sources
            if (window.audioContext) {
                // Get the master gain node (destination)
                const masterGain = window.audioContext.createGain();
                masterGain.gain.value = isMuted ? 0 : 1;
                
                // Connect to destination
                masterGain.connect(window.audioContext.destination);
                
                // Reconnect all audio sources through this gain node
                if (window.engineSound) {
                    window.engineSound.filter.disconnect();
                    window.engineSound.filter.connect(masterGain);
                }
            }
            
            
            // Show visual feedback
            const muteIndicator = document.createElement('div');
            muteIndicator.textContent = isMuted ? 'SOUND OFF' : 'SOUND ON';
            muteIndicator.style.position = 'fixed';
            muteIndicator.style.top = '20%';
            muteIndicator.style.left = '50%';
            muteIndicator.style.transform = 'translate(-50%, -50%)';
            muteIndicator.style.padding = '10px 20px';
            muteIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            muteIndicator.style.color = isMuted ? '#ff0000' : '#00ff00';
            muteIndicator.style.borderRadius = '5px';
            muteIndicator.style.fontFamily = 'system-ui, sans-serif';
            muteIndicator.style.fontSize = '24px';
            muteIndicator.style.zIndex = '1000';
            document.body.appendChild(muteIndicator);
            
            // Remove the indicator after 2 seconds
            setTimeout(() => {
                document.body.removeChild(muteIndicator);
            }, 2000);
        }


        // Add chat input element to the page
        const chatInput = document.createElement('input');
        chatInput.id = 'chatInput';
        chatInput.type = 'text';
        chatInput.maxLength = 100;
        chatInput.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            outline:none;
            display: none;
            z-index: 1000;
            width: 300px;
            font-family: system-ui, sans-serif;
        `;
        document.body.appendChild(chatInput);



        // Handle chat input submission
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                chatInput.value = '';
                chatInput.style.display = 'none';
                skipControls = false;
                event.preventDefault();
                return;
            }
            if (event.key === 'Enter' && chatInput.value.trim()) {
               
                broadcastChatMessage(chatInput.value.trim());
                
                // Clear and hide input
                chatInput.value = '';
                chatInput.style.display = 'none';
                skipControls = false;
            } else if (event.key === 'Escape') {
                // Cancel chat
                chatInput.value = '';
                chatInput.style.display = 'none';
                skipControls = false;
            }
        });



        // <sideshift.ai blimp>
            // Create blimp group
            const blimpGroup = new THREE.Group();
            
            // Main blimp body (ellipsoid) - increased length by 1.5x
            const mainBodyGeometry = new THREE.SphereGeometry(20, 32, 32);
            mainBodyGeometry.scale(1, 1, 2.7); // Changed from 1.8 to 2.7 (1.5x longer)
            const mainBodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF
            });
            const mainBody = new THREE.Mesh(mainBodyGeometry, mainBodyMaterial);
            blimpGroup.add(mainBody);
            
            // Blimp tail section - moved further back
            const tailGeometry = new THREE.ConeGeometry(15, 20, 32);
            tailGeometry.rotateX(Math.PI / 2);
            tailGeometry.translate(0, 0, 45); // Changed from 30 to 45 to match the longer body
            const tailMaterial = new THREE.MeshPhongMaterial({ color: 0xE0E0E0 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            blimpGroup.add(tail);
            
            // Gondola (cabin beneath blimp)
            const gondolaGeometry = new THREE.BoxGeometry(10, 5, 7);
            const gondolaMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 }); // Dark grey
            const gondola = new THREE.Mesh(gondolaGeometry, gondolaMaterial);
            gondola.position.y = -20;
            blimpGroup.add(gondola);
            
            // Fins (rudders)
            const finGeometry = new THREE.ConeGeometry(8, 15, 4);
            finGeometry.rotateX(Math.PI / 2);
            
            const finMaterial = new THREE.MeshPhongMaterial({ color: 0xD0D0D0 });
            
            // Vertical fin - moved further back
            const verticalFin = new THREE.Mesh(finGeometry, finMaterial);
            verticalFin.position.set(0, 0, 50); // Changed from 35 to 50
            verticalFin.rotation.x = Math.PI / 2;
            blimpGroup.add(verticalFin);
            
            // Horizontal fin - moved further back
            const horizontalFin = new THREE.Mesh(finGeometry, finMaterial);
            horizontalFin.position.set(0, 0, 50); // Changed from 35 to 50
            horizontalFin.rotation.z = Math.PI / 2;
            blimpGroup.add(horizontalFin);
            
            // Advertisement banner
            const createBlimpTextTexture = () => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 512;
                canvas.height = 128;
                
                // Background
                context.fillStyle = '#000000'; // Black background
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Text
                context.font = 'bold 48px system-ui';
                context.fillStyle = '#ffffff';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText('SIDESHIFT.AI/JOBS', canvas.width / 2, canvas.height / 2);
                
                return new THREE.CanvasTexture(canvas);
            };
            
            // Create banner with the text - attach to blimp side
            // Fix the banner proportions to maintain aspect ratio
            const blimpBannerGeometry = new THREE.PlaneGeometry(52, 13); // Adjusted height to maintain aspect ratio
            const blimpBannerMaterial = new THREE.MeshBasicMaterial({ 
                map: createBlimpTextTexture(),
                side: THREE.DoubleSide
            });
            const blimpBanner = new THREE.Mesh(blimpBannerGeometry, blimpBannerMaterial);
            
            // Position the banner on the side of the blimp
            blimpBanner.position.set(21, 0, 0); // Move it to the side of the blimp
            blimpBanner.rotation.y = Math.PI / 2; // Rotate to face outward from the blimp side
            blimpGroup.add(blimpBanner);
            
            // Add a second banner on the other side
            const blimpBanner2 = blimpBanner.clone();
            blimpBanner2.position.set(-21, 0, 0);
            blimpBanner2.rotation.y = -Math.PI / 2; // Rotate to face outward from the opposite side
            blimpGroup.add(blimpBanner2);
            
            // Position the blimp high in the sky
            blimpGroup.position.set(
                -50, // Fixed position near runway
                150,  // Lower altitude at 100
                -200   // Moved further in front of the runway (negative Z moves it forward)
            );
            
            // Rotate the blimp 90 degrees leftwards (counter-clockwise around Y axis)
            blimpGroup.rotation.y = Math.PI / 2;
            scene.add(blimpGroup);
        // </sideshift.ai blimp>





        // <medvi.org blimp>
            // Create blimp group
            const medviBlimpGroup = new THREE.Group();

            // Main blimp body (ellipsoid) - increased length by 1.5x
            const medviBlimpMainBodyGeometry = new THREE.SphereGeometry(20, 32, 32);
            medviBlimpMainBodyGeometry.scale(1, 1, 2.7); // Changed from 1.8 to 2.7 (1.5x longer)
            const medviBlimpMainBodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x779d7c // Changed to the requested color
            });
            const medviBlimpMainBody = new THREE.Mesh(medviBlimpMainBodyGeometry, medviBlimpMainBodyMaterial);
            medviBlimpGroup.add(medviBlimpMainBody);

            // Blimp tail section - moved further back
            const medviBlimpTailGeometry = new THREE.ConeGeometry(15, 20, 32);
            medviBlimpTailGeometry.rotateX(Math.PI / 2);
            medviBlimpTailGeometry.translate(0, 0, 45); // Changed from 30 to 45 to match the longer body
            const medviBlimpTailMaterial = new THREE.MeshPhongMaterial({ color: 0x779d7c }); // Changed to the requested color
            const medviBlimpTail = new THREE.Mesh(medviBlimpTailGeometry, medviBlimpTailMaterial);
            medviBlimpGroup.add(medviBlimpTail);

            // Gondola (cabin beneath blimp)
            const medviBlimpGondolaGeometry = new THREE.BoxGeometry(10, 5, 7);
            const medviBlimpGondolaMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 }); // Dark grey
            const medviBlimpGondola = new THREE.Mesh(medviBlimpGondolaGeometry, medviBlimpGondolaMaterial);
            medviBlimpGondola.position.y = -20;
            medviBlimpGroup.add(medviBlimpGondola);

            // Fins (rudders)
            const medviBlimpFinGeometry = new THREE.ConeGeometry(8, 15, 4);
            medviBlimpFinGeometry.rotateX(Math.PI / 2);

            const medviBlimpFinMaterial = new THREE.MeshPhongMaterial({ color: 0x779d7c }); // Changed to the requested color

            // Vertical fin - moved further back
            const medviBlimpVerticalFin = new THREE.Mesh(medviBlimpFinGeometry, medviBlimpFinMaterial);
            medviBlimpVerticalFin.position.set(0, 0, 50); // Changed from 35 to 50
            medviBlimpVerticalFin.rotation.x = Math.PI / 2;
            medviBlimpGroup.add(medviBlimpVerticalFin);

            // Horizontal fin - moved further back
            const medviBlimpHorizontalFin = new THREE.Mesh(medviBlimpFinGeometry, medviBlimpFinMaterial);
            medviBlimpHorizontalFin.position.set(0, 0, 50); // Changed from 35 to 50
            medviBlimpHorizontalFin.rotation.z = Math.PI / 2;
            medviBlimpGroup.add(medviBlimpHorizontalFin);

            // Advertisement banner
            const medviBlimpCreateBlimpTextTexture = () => {
                const medviBlimpCanvas = document.createElement('canvas');
                const medviBlimpContext = medviBlimpCanvas.getContext('2d');
                medviBlimpCanvas.width = 512;
                medviBlimpCanvas.height = 128;
                
                // Background
                medviBlimpContext.fillStyle = '#779d7c'; // Changed to the requested color
                medviBlimpContext.fillRect(0, 0, medviBlimpCanvas.width, medviBlimpCanvas.height);
                
                // Text - use a system font instead of loading custom font
                medviBlimpContext.font = 'bold 36px system-ui';
                medviBlimpContext.fillStyle = '#000000';
                medviBlimpContext.textAlign = 'center';
                medviBlimpContext.textBaseline = 'middle';
                
                // First line
                medviBlimpContext.fillText('ARE YOU AS BIG AS A BLIMP?', medviBlimpCanvas.width / 2, medviBlimpCanvas.height / 3);
                
                // Second line
                medviBlimpContext.fillText('LOSE WEIGHT AT MEDVI.ORG', medviBlimpCanvas.width / 2, medviBlimpCanvas.height * 2/3);
                
                // Return the texture directly instead of a Promise
                return new THREE.CanvasTexture(medviBlimpCanvas);
            };

            // Create banner with the text - attach to blimp side
            // Fix the banner proportions to maintain aspect ratio
            const medviBlimpBannerGeometry = new THREE.PlaneGeometry(78, 19.5); // Increased by 1.5x (52*1.5=78, 13*1.5=19.5)
            const medviBlimpBannerMaterial = new THREE.MeshBasicMaterial({ 
                map: medviBlimpCreateBlimpTextTexture(),
                side: THREE.DoubleSide
            });
            const medviBlimpBanner = new THREE.Mesh(medviBlimpBannerGeometry, medviBlimpBannerMaterial);

            // Position the banner on the side of the blimp
            medviBlimpBanner.position.set(21, 0, 0); // Move it to the side of the blimp
            medviBlimpBanner.rotation.y = Math.PI / 2; // Rotate to face outward from the blimp side
            medviBlimpGroup.add(medviBlimpBanner);

            // Add a second banner on the other side
            const medviBlimpBanner2 = medviBlimpBanner.clone();
            medviBlimpBanner2.position.set(-21, 0, 0);
            medviBlimpBanner2.rotation.y = -Math.PI / 2; // Rotate to face outward from the opposite side
            medviBlimpGroup.add(medviBlimpBanner2);

            // Position the blimp high in the sky
            medviBlimpGroup.position.set(100,100,0);
            medviBlimpGroup.rotation.y=0.5;

            scene.add(medviBlimpGroup);
            
            // Animation parameters for the blimp
            const medviBlimpStartY = 100; // Starting Y position
            const medviBlimpFloatAmplitude = 5; // How high/low it floats
            const medviBlimpFloatSpeed = 0.001; // Speed of the floating motion
            let medviBlimpTime = 0; // Time counter for animation
            
            // Add animation to the render loop
            const animateMedviBlimp = () => {
                medviBlimpTime += 1;
                // Sine wave motion for smooth up and down floating
                const newY = medviBlimpStartY + Math.sin(medviBlimpTime * medviBlimpFloatSpeed) * medviBlimpFloatAmplitude;
                // Apply the new position
                medviBlimpGroup.position.y = newY;
                
                // Add a slight tilt to simulate air resistance
                const tiltAngle = Math.sin(medviBlimpTime * medviBlimpFloatSpeed * 0.5) * 0.02;
                medviBlimpGroup.rotation.x = tiltAngle;
                
                // Continue the animation
                requestAnimationFrame(animateMedviBlimp);
            };
            
            // Start the animation
            animateMedviBlimp();
        // </medvi.org blimp>


        
        // <tavus.io blimp>
            // Create blimp group
            const blimp2Group = new THREE.Group();

            // Load texture for blimp body
            const blimp2Texture = new THREE.TextureLoader().load('/assets/fly_tavus.jpg');
            blimp2Texture.wrapS = THREE.RepeatWrapping;
            blimp2Texture.wrapT = THREE.RepeatWrapping;
            blimp2Texture.repeat.set(5, 3);

            // Main blimp body (ellipsoid) - increased length by 1.5x
            const blimp2MainBodyGeometry = new THREE.SphereGeometry(20, 32, 32);
            blimp2MainBodyGeometry.scale(1, 1, 2.7); // Changed from 1.8 to 2.7 (1.5x longer)
            const blimp2MainBodyMaterial = new THREE.MeshPhongMaterial({ 
                map: blimp2Texture,
                color: 0xFFFFFF,
                fog:false
            });
            const blimp2MainBody = new THREE.Mesh(blimp2MainBodyGeometry, blimp2MainBodyMaterial);
            blimp2Group.add(blimp2MainBody);

            // Blimp tail section - moved further back
            const blimp2TailGeometry = new THREE.ConeGeometry(15, 20, 32);
            blimp2TailGeometry.rotateX(Math.PI / 2);
            blimp2TailGeometry.translate(0, 0, 45); // Changed from 30 to 45 to match the longer body
            const blimp2TailMaterial = new THREE.MeshPhongMaterial({ 
                map: blimp2Texture,
                color: 0xE0E0E0 
            });
            const blimp2Tail = new THREE.Mesh(blimp2TailGeometry, blimp2TailMaterial);
            blimp2Group.add(blimp2Tail);

            // Gondola (cabin beneath blimp)
            const blimp2GondolaGeometry = new THREE.BoxGeometry(10, 5, 7);
            const blimp2GondolaMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 }); // Dark grey
            const blimp2Gondola = new THREE.Mesh(blimp2GondolaGeometry, blimp2GondolaMaterial);
            blimp2Gondola.position.y = -20;
            blimp2Group.add(blimp2Gondola);

            // Fins (rudders)
            const blimp2FinGeometry = new THREE.ConeGeometry(8, 15, 4);
            blimp2FinGeometry.rotateX(Math.PI / 2);

            const blimp2FinMaterial = new THREE.MeshPhongMaterial({ 
                map: blimp2Texture,
                color: 0xD0D0D0 
            });

            // Vertical fin - moved further back
            const blimp2VerticalFin = new THREE.Mesh(blimp2FinGeometry, blimp2FinMaterial);
            blimp2VerticalFin.position.set(0, 0, 50); // Changed from 35 to 50
            blimp2VerticalFin.rotation.x = Math.PI / 2;
            blimp2Group.add(blimp2VerticalFin);

            // Horizontal fin - moved further back
            const blimp2HorizontalFin = new THREE.Mesh(blimp2FinGeometry, blimp2FinMaterial);
            blimp2HorizontalFin.position.set(0, 0, 50); // Changed from 35 to 50
            blimp2HorizontalFin.rotation.z = Math.PI / 2;
            blimp2Group.add(blimp2HorizontalFin);

            // Position the blimp high in the sky
            blimp2Group.position.set(
                -200, // Fixed position near runway
                150,  // Lower altitude at 100
                -100   // Moved further in front of the runway (negative Z moves it forward)
            );

            // Rotate the blimp 90 degrees leftwards (counter-clockwise around Y axis)
            blimp2Group.rotation.y=0;
            scene.add(blimp2Group);
        // </tavus.io blimp>
        



            
        // <synthflow.ai blimp>
            // Create blimp group
            const blimp3Group = new THREE.Group();

            // Load texture for blimp body
            const blimp3Texture = new THREE.TextureLoader().load('/assets/fly_synthflow.png');
            blimp3Texture.wrapS = THREE.RepeatWrapping;
            blimp3Texture.wrapT = THREE.RepeatWrapping;
            blimp3Texture.repeat.set(5, 3);

            // Main blimp body (ellipsoid) - increased length by 1.5x
            const blimp3MainBodyGeometry = new THREE.SphereGeometry(20, 32, 32);
            blimp3MainBodyGeometry.scale(1, 1, 2.7); // Changed from 1.8 to 2.7 (1.5x longer)
            const blimp3MainBodyMaterial = new THREE.MeshPhongMaterial({ 
                map: blimp3Texture,
                color: 0xFFFFFF
            });
            const blimp3MainBody = new THREE.Mesh(blimp3MainBodyGeometry, blimp3MainBodyMaterial);
            blimp3Group.add(blimp3MainBody);

            // Blimp tail section - moved further back
            const blimp3TailGeometry = new THREE.ConeGeometry(15, 20, 32);
            blimp3TailGeometry.rotateX(Math.PI / 2);
            blimp3TailGeometry.translate(0, 0, 45); // Changed from 30 to 45 to match the longer body
            const blimp3TailMaterial = new THREE.MeshPhongMaterial({ 
                map: blimp3Texture,
                color: 0xE0E0E0 
            });
            const blimp3Tail = new THREE.Mesh(blimp3TailGeometry, blimp3TailMaterial);
            blimp3Group.add(blimp3Tail);

            // Gondola (cabin beneath blimp)
            const blimp3GondolaGeometry = new THREE.BoxGeometry(10, 5, 7);
            const blimp3GondolaMaterial = new THREE.MeshPhongMaterial({ color: 0x404040 }); // Dark grey
            const blimp3Gondola = new THREE.Mesh(blimp3GondolaGeometry, blimp3GondolaMaterial);
            blimp3Gondola.position.y = -20;
            blimp3Group.add(blimp3Gondola);

            // Fins (rudders)
            const blimp3FinGeometry = new THREE.ConeGeometry(8, 15, 4);
            blimp3FinGeometry.rotateX(Math.PI / 2);

            const blimp3FinMaterial = new THREE.MeshPhongMaterial({ 
                map: blimp3Texture,
                color: 0xD0D0D0 
            });

            // Vertical fin - moved further back
            const blimp3VerticalFin = new THREE.Mesh(blimp3FinGeometry, blimp3FinMaterial);
            blimp3VerticalFin.position.set(0, 0, 50); // Changed from 35 to 50
            blimp3VerticalFin.rotation.x = Math.PI / 2;
            blimp3Group.add(blimp3VerticalFin);

            // Horizontal fin - moved further back
            const blimp3HorizontalFin = new THREE.Mesh(blimp3FinGeometry, blimp3FinMaterial);
            blimp3HorizontalFin.position.set(0, 0, 50); // Changed from 35 to 50
            blimp3HorizontalFin.rotation.z = Math.PI / 2;
            blimp3Group.add(blimp3HorizontalFin);

            // Position the blimp high in the sky
            blimp3Group.position.set(
                -650, // Fixed position near runway
                90,  // Lower altitude at 100
                -50   // Moved further in front of the runway (negative Z moves it forward)
            );

            // Rotate the blimp 90 degrees leftwards (counter-clockwise around Y axis)
            blimp3Group.rotation.y=-0.5;;
            scene.add(blimp3Group);
        // </synthflow.ai blimp>


        // <runway number>
            // Create runway number text
            // Create a canvas to draw the text
            const runwayNumberCanvas = document.createElement('canvas');
            runwayNumberCanvas.width = 1024;
            runwayNumberCanvas.height = 1024;
            const runwayNumberContext = runwayNumberCanvas.getContext('2d');
            
            // Draw white text on transparent background
            runwayNumberContext.fillStyle = '#FFFFFF';
            runwayNumberContext.font = 'bold 85px system-ui';
            runwayNumberContext.textAlign = 'center';
            runwayNumberContext.textBaseline = 'middle';
            runwayNumberContext.fillText('42', runwayNumberCanvas.width/2, runwayNumberCanvas.height/2);
            
            // Create texture from canvas
            const runwayNumberTexture = new THREE.CanvasTexture(runwayNumberCanvas);
            // Set texture filtering to prevent blurriness
            runwayNumberTexture.minFilter = THREE.LinearFilter;
            runwayNumberTexture.magFilter = THREE.LinearFilter;
            
            const runwayNumberMaterial = new THREE.MeshBasicMaterial({
                map: runwayNumberTexture,
                transparent: true,
                side: THREE.DoubleSide
            });
            
            // Create plane geometry for the text
            const runwayNumberGeometry = new THREE.PlaneGeometry(40, 40);
            const runwayNumberMesh = new THREE.Mesh(runwayNumberGeometry, runwayNumberMaterial);
            
            // Position the text at the start of the runway
            runwayNumberMesh.position.set(0, 35.1, 87.5);
            runwayNumberMesh.rotation.x = -Math.PI / 2; // Lay flat on runway
            runwayNumberMesh.rotation.z = 0
            
            scene.add(runwayNumberMesh);

        // </runway number>

        // After scene creation
        createRain();


        function escapeHtml(text) {
            return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
        }


    </script>
    
</body>
<a target="_blank" class="featurebase" href="https://ideasandbugs.com/?b=67bf044fffab95c913394529">
    üí° Ideas + ü™≤ Bugs
</a>
<style>
    .featurebase {
        font-family:"system-ui",sans-serif;
            position: fixed;
        bottom: -1px;
        right: -1px;
        padding: 7px;
        font-size: 14px;
        font-weight: bold;
        background: #fff;
        color: #000;
        text-decoration: none;
        z-index: 10;
        border-top-left-radius: 12px;
        z-index: 99;
        border:1px solid #fff;
    }
    stripe-buy-button {
        z-index: 1000;
        position: absolute;
        bottom: 19px;
        left: 19px;
        }
        @media (max-width:800px) {
        .featurebase {
            display:none;
        }
        stripe-buy-button {
            display:none;
        }
    }

</style>
</html>